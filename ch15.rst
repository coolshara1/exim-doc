
.. _ch15_00:

Общие опции для роутеров
========================

Эта глава описывает общие опции, применяемые ко всем роутерам.  Те, которые являются предварительными условиями, помечены символом “‡”, в поле “использование”.

Для общего описания, как работает маршрутизатор, смотрите раздел :ref:`3.10 <ch03_10>` и :ref:`3.12 <ch03_12>`. Последний, определяет порядок в котором проверяются предварительные условия. Порядок раскрытия опций, которые предоставляют данные для транспортов, таков: **errors_to**, **headers_add**, **headers_remove**, **transport**.

================  ============  =============  ==============
**address_data**  Use: routers  Type: string†  Default: unset
================  ============  =============  ==============

Строка раскрывается лишь до запуска роутера, т.е. после успешного прохождения всех тестов предварительных условий. Если раскрытие принудительно неудачно, роутер отклоняется, значение **address_data** остаётся неизменённым, и опция  **more** контролирует, что происходит дальше. Другие ошибки раскрытия вызывают задержку доставки адреса.

Когда раскрытие успешно, значение сохраняется вместе с адресом, и может быть доступно использованием переменной $address_data в текушем роутере,последующих маршрутизаторах, и возможном окончательном транспорте.

.. warning:: Если текущий, или последующий роутер - роутер **redirect**, выполняющий файл фильтра пользователя, содержимое $address_data доступно в фильтре. Обычно, это не проблема, поскольку обычно, эти данные не конфиденциальны, или они принадлежат текущему пользователю, но если вы помещаете конфиденциальные данные в $address_data, вы должны помнить о этом пункте.

Даже если маршрутизатор отклоняется или принимается, значение $address_data остаётся с адресом, хотя оно может быть изменено, путём установки иной $address_data в последующем маршрутизаторе. Если роутер генерит дочерние адреса, значение $address_data размножается на них. Также это применяется к специальному виду “детей”, которые генерятся роутерами с опцией **unseen**.

Идея **address_data** в том, что вы можете использовать её для поиска большого количества данных за раз, и позднее выбирать части данных. Для примера, вы можете использовать один поиск в LDAP, для возврата строки формы

::

    uid=1234 gid=5678 mailbox=/mail/xyz forward=/home/xyz/.forward

В транспорте, вы могли бы выбрать почтовый ящик установкой типа

::

    file = ${extract{mailbox}{$address_data}}

Это делает конфигурационный файл менее грязным, и также уменьшает число поисков (хотя Exim кэширует поиски).

Средство **address_data** также полезно как средство передачи информации от одного роутера к другому, и от роутера к транспорту. В дополнение, если **address_data** установлена роутером при проверке адреса получателя из ACL, она остаётся доступной для использования в остальной части утверждения ACL. После проверки отправителя, значение передаётся в $sender_address_data.

================  =============  =============  ==============
**address_test**  Use: routers‡  Type: boolean  Default: true
================  =============  =============  ==============

Если эта опция установлена в ложь, маршрутизатор пропускается, когда роутинг тестируется при помощи опции командной строки **-bt**. Это может быть удобным, когда ваш первый роутер посылает сообщения на внешний сканер, поскольку он сохраняет необходимость установки индикатора “already scanned”, при тестировании реальной маршрутизации адреса

========================  ============  =============  ==============
**cannot_route_message**  Use: routers  Type: string†  Default: unset
========================  ============  =============  ==============

Эта опция определяет текстовое сообщение, используемое когда адрес не может быть смаршрутизирован, поскольку Exim исчерпал все маршруты. Дефолтовое сообщение - “Unrouteable address”. Эта опция полезна лишь в роутерах, где опция **more** установлена в ложь, или последнем роутере конфигурации, поскольку используемое значение берётся из последнего просматриваемого роутера. Она включает роутеры, которые были пропущены, поскольку несоответствовали их предварительные условия, также как и отклоняемые маршрутизаторы. Например, используя дефолтовую конфигурацию, вы могли бы поместить::

    cannot_route_message = Remote domain not found in DNS

в первом роутере, являющемся роутером **dnslookup**, с опцией **more** установленной в ложь, и

::

    cannot_route_message = Unknown local user

в последнем роутере, где проверяются локальные юзеры. Если раскрытие строки этой опции неудачно, используется дефолтовое сообщение. Если ошибка раскрытия не была неудачной принудительно, сообщение о ошибке пишется в главный лог и лог паники, в дополнение к обычному сообщению о ошибке роутинга.

======================  ============  =============  ==============
**caseful_local_part**  Use: routers  Type: boolean  Default: false
======================  ============  =============  ==============

По умолчанию, роутеры обрабатывают локальную часть адреса в регистронезависимой манере, хотя фактический регистр сохраняется, для передачи с сообщением. Если вы хотите, чтобы регистр букв был важен в роутере, вы должны установить эту опцию в истину. Для индивидуальных опций роутера, которые содержат адреса, или списки локальных частей (например, **local_parts**), сравнение с учётом регистра может быть включено путём ``+caseful``, как элемента списка. Смотрите раздел :ref:`10.20 <ch10_20>`, для получения дополнительных деталей.

Значение переменной $local_part принудительно приводится к нижнему регистру, когда роутер запущен без установленной опции **caseful_local_part**. Когда роутер назначает адрес на транспортировку, когда транспорт выполняется, значение $local_part такое же. Точно также, когда роутер генерит дочерний адрес путём альясинга или форвардинга, значение $original_local_part и $parent_local_part те, которые использовались роутером редиректа.

Эти опции применяются к обработке адресов роутером. Когда адрес получателя обрабтывается в ACL, есть отдельный модификатор **control**, который может использоваться для задания регистрозависимой обработки в пределах ACL (смотрите раздел :ref:`40.20 <ch40_20>`).

====================  =============  =============  ==============
**check_local_user**  Use: routers‡  Type: boolean  Default: false
====================  =============  =============  ==============

Когда эта опция истинна, Exim проверяет, что локальная часть адреса получателя (с удалёнными аффиксами, если они есть) - имя учётной записи в локальной системе. Проверка производиться путём вызова функции *getpwnam()*, вместо попытки напрямую прочитать */etc/passwd*. Это означает, что другие методы проверки данных пароля (типа NIS), также поддерживаются. Если локальная часть - локальный пользователь, переменная $home устанавливается из данных пароля, и может быть проверена в других предварительных условиях, оцениваемых после этого (порядок оценки даётся в разделе :ref:`3.12 <ch03_12>`). Однако, значение $home может быть перезадано **router_home_directory**. Если локальная часть - не локальный пользователь, роутер пропускается.

Если вы хотите проверить, что локальная часть является именем пользователя, или совпадает с чем-то ещё, вы не можете объединять **check_local_user** с установкой **local_parts**, поскольку это определяет логическое “и” этих условий. Однако, вы можете использовать поиск **passwd** в установке **local_parts**, для достижения этого. Например::

    local_parts = passwd;$local_part : lsearch;/etc/other/users

Отметьте, однако, что побочные эффекты **check_local_user** (типа установки домашней директории) не происходят, когда поиск **passwd** используется в **local_parts** (или любых других) предварительных условиях.

=============  =============  =============  ==============
**condition**  Use: routers‡  Type: string†  Default: unset
=============  =============  =============  ==============

Эта опция определяет главный тест предварительного условия, который должен быть успешным, для вызова роутера. Опция **condition** - последнее предварительное условие, для оценки (смотрите раздел :ref:`3.12 <ch03_12>`). Строка раскрывается, и если результат принудительно неудачен, или пустая строка, или одна из строк “0”, или “no”, или “false” (проверяется без учёта регистра), роутер пропускается, и адрес предлагается следующему.

Если результат - любое другое значение, роутер запускается (поскольку это - последнее предварительное условие для оценки, все другие предварительные условия должны быть истинными).

Опция **condition** предоставляет средство применения персональных условий для запуска роутеров. Отметьте, что в случае простого раскрытия, дефолтовое значение раскрытия - именно то что требуется. например::

    condition = ${if >{$message_age}{600}}

Из-за дефолтового поведения раскрытия строки, это эквивалентно

::

    condition = ${if >{$message_age}{600}{true}{}}

Если раскрытие неудачно (кроме принудительной неудачи), поставка отсрочена. Некоторые другие опции предварительные условий - общие специальные случаи, которые могли быть фактически определены, используя **condition**.

===============  ============  =============  ==============
**debug_print**  Use: routers  Type: string†  Default: unset
===============  ============  =============  ==============

Если эта опция установлена, и отладка включена (смотрите опцию командной строки - **-d**), строка раскрывается и включается в отладочный вывод. Если раскрытие строки неудачно, сообщение о ошибке записывается в отладочный вывод, и Exim продолжает обработку. Эта опция предоставлена для помощи проверки значения переменных, и т.п. при отладке конфигурации роутера. Например, если кажется, что опция **condition** не работает, **debug_print** может использоваться для вывода ссылающихся на неё переменных. Вывод происходит после проверки **domains**, **local_parts** и **check_local_user**, но до проверки любых других предварительных условий. Новая строка добавляется к тексту, если она не оканчивается этим символом.

===================  ============  =============  ==============
**disable_logging**  Use: routers  Type: boolean  Default: false
===================  ============  =============  ==============

Если эта опция установлена в истину, ничего не логгируется для любых ошибок роутинга или для любых доставок, вызванных этим маршрутизатором. Вы не должны устанавливать эту опцию, если вы не понимаете что вы делаете. Также смотрите общую опцию транспортов, с тем же именем.

===========  =============  ==================  ==============
**domains**  Use: routers‡  Type: domain list†  Default: unset
===========  =============  ==================  ==============

Если эта опция установлена, роутер пропускается, когда текущий домен не совпадает со списком. Если совпадение произошло путём поиска по файлу, данные возвращённые поиском для домена, помещаются в $domain_data, для использования в раскрытиях строки частных опций драйвера. Смотрите раздел :ref:`3.12 <ch03_12>`, для списка в каком порядке оцениваются предварительные условия.

==========  ============  ============  ==============
**driver**  Use: routers  Type: string  Default: unset
==========  ============  ============  ==============

Эта опция всегда должна быть установлена. Она определяет, какой из доступных маршрутизаторов должен использоваться.

=============  ============  =============  ==============
**errors_to**  Use: routers  Type: string†  Default: unset
=============  ============  =============  ==============

Если роутер успешно обрабатывает адрес, он может назначить адрес на транспорт для доставки, или он может сгенерить дочерний адрес. В обоих случаях, если происходят проблемы доставки в более поздних процессах обработки, результирующее сообщение рикошета посылается по адресу, являющемуся результатом раскрытия этой строки, при условии успешной проверки адреса. Опция **errors_to** раскрывается до **headers_add**, **headers_remove** и **transport**.

Установка **errors_to**, связанная с адресом, может быть перезадана, при последующем прохождении через другие маршрутизаторы, обладающие своими настройками **errors_to**, или если сообщение доставляется транспортом с установкой **return_path**.

Если **errors_to** незадана, или раскрытие принудительно неудачно, или ошибка при проверке результата раскрытия, используется адрес для ошибок связанный со входящим адресом. На верхнем уровне, это - отправитель конверта. Непринудительная ошибка раскрытия вызывает задержку доставки.

Если адрес, для которого установлена **errors_to**, завершается передачей через SMTP, отправитель конверта, для этой доставки, - значение **errors_to**, таким образом, любые рикошеты, сгенерённые другими MTA на маршруте доставки, шлются туда же. Вы можете установить **errors_to** в пустую строку любой из этих установок::

    errors_to =
    errors_to = ""

Элемент раскрытия, приводящий к пустой строке, имеет тот же эффект. Если вы так делаете, локально обнаруженная ошибка доставки для адресов, обработанных этим роутером, не даёт начала рикошету; от ошибки отказываются. Если адрес доставляется на удалённый хост, путь возврата устанавливается в “<>”, если это не отменяется опцией **return_path** в транспорте.

Если по каким-то причинам вы хотите отказаться от локальных ошибок, но использовать непустую команду MAIL для удалённой доставки, вы можете сохранить оригинальный обратный путь в $address_data роутера, и восстановить его в транспорте, установкой **return_path**.

Самое общее использование **errors_to** - прямой список список рассылки рикошетов к менеджерам списка, как описано в разделе :ref:`47.2 <ch47_02>`, или для осуществления VERP (Variable Envelope Return Paths) (смотрите раздел :ref:`47.6 <ch47_06>`).

========  =============  =============  =============
**expn**  Use: routers‡  Type: boolean  Default: true
========  =============  =============  =============

Если эта опция выключена, роутер пропускается когда тестируется адрес как результат обработки команды SMTP EXPN. Вы могли бы, например, захотеть включить её на роутере для пользовательских файлов *.forward*, когда оставляете их для файлов системных альясов. Смотрите раздел :ref:`3.12 <ch03_12>`, для получения порядка, в котором оцениваются предварительные условия.

Использование команды SMTP EXPN контролирутеся путём ACL (смотрите главу :ref:`40 <ch40_00>`). Когда Exim запускается командой EXPN, это подобно проверке адреса с **-bt**. Сравните VRFY, дубликат которой **-bv**.

===============  ============  =============  ==============
**fail_verify**  Use: routers  Type: boolean  Default: false
===============  ============  =============  ==============

Установка этой опции создаёт эффект установки обоих опций **fail_verify_sender** и **fail_verify_recipient** в тоже значение.

=========================  ============  =============  ==============
**fail_verify_recipient**  Use: routers  Type: boolean  Default: false
=========================  ============  =============  ==============

Если эта опция установлена в истину, и адрес принимается этим роутером когда проверяется получатель, проверка будет неудачна.

======================  ============  =============  ==============
**fail_verify_sender**  Use: routers  Type: boolean  Default: false
======================  ============  =============  ==============

Если эта опция установлена в истину, и адрес принимается этим роутером когда проверяется отправитель, проверка будет неудачна.

==================  ============  =================  ==============
**fallback_hosts**  Use: routers  Type: string list  Default: unset
==================  ============  =================  ==============

Раскрытие строки не применяется к этой опции. Аргумент должен быть списком имён хостов, или IP-адресов разделённых двоеточиями. Разделитель списка может быть изменён (смотрите раздел :ref:`6.19 <ch06_19>`), и порт может быть задан с каждым именем или адресом. Фактически, формат каждого элемента, точно такой же, как в списке хостов роутера **manualroute** (смотрите раздел :ref:`20.5 <ch20_05>`).

Если роутер стоит в очереди на адрес для удалённого транспорта, этот список хостов ассоциирован с адресом, и используется вместо запасного списка хостов транспорта. Если **hosts_randomize** установлена в транспорте, порядок списка случаен для каждого использования. Смотрите опцию **fallback_hosts** транспорта **snmp**, для дальнейших деталей.

=========  ============  =============  ==================
**group**  Use: routers  Type: string†  Default: see below
=========  ============  =============  ==================

Когда роутер стоит в очереди на адрес для транспорта, и транспорт не определяет группу, используется группа данная тут, когда работает процесс доставки. Группа может быть задана в цифровой форме, или по имени. Если раскрытие неудачно, ошибка логгируется, и доставка задерживается. По умолчанию, она не задана, если не установлена **check_local_user**, когда значение по умолчанию берётся из информации о пароле. Также смотрите **initgroups**, и **user**, и обсуждение в главе :ref:`23 <ch23_00>`.

===============  ============  =============  ==============
**headers_add**  Use: routers  Type: string†  Default: unset
===============  ============  =============  ==============

Эта опция задаёт строку текста, который раскрывается во время роутинга, и ассоциирован с любым адресом, который принят роутером. Однако, эта опция не имеет никакого эффекта, когда адрес лишь проверяется. Способ, которым используется текст для добавления строк заголовков в транспорте, описан в разделе :ref:`44.17 <ch44_17>`. Фактически, новые строки заголовков не добавлены, пока сообщение в процессе транспортировки. Это означает, что ссылки на строки заголовков, в раскрытиях строк, в конфигурации транспорта продолжают “видеть” оригинальные заголовки [#]_.

Опция **headers_add** раскрывается после **errors_to**, но до **headers_remove** и **transport**. Если раскрытая строка пуста, или если раскрытие принудительно неудачно, опция не имеет эффекта. Другие ошибки раскрытия обрабатываются как ошибки конфигурации.

.. warning:: Опция **headers_add** не может использоваться для роутера **redirect**, в котором установлена опция **one_time**.

.. warning:: Если в роутере установлена опция **unseen**, все дополнения заголовков удаляются, при передаче следующему роутеру. Для роутера **redirect**, если сгеренированный адрес - тот же самый что и входящий, это может указывать на дублирование адресов с различными модификациями заголовков. Exim не дублирует доставки (за исключением определённых случаев, в трубы - смотрите раздел :ref:`22.7 <ch22_07>`), но нездано от какого дубликата отказаться, таким образом этой неопределённой ситуации необходимо избегать. Может быть полезной опция **repeat_use**, роутера **redirect**.

==================  ============  =============  ==============
**headers_remove**  Use: routers  Type: string†  Default: unset
==================  ============  =============  ==============

Эта опция задаёт строку текста, который ракрывается во время роутинга, и ассоциирован с любым адресом, который принят роутером. Однако, эта опция не имеет никакого эффекта, когда адрес лишь проверяется. Способ, которым используется текст для удаления строк заголовков в транспорте, описан в разделе :ref:`44.17 <ch44_17>`. Фактически, строки заголовков не удалены, пока сообщение в процессе транспортировки. Это означает, что ссылки на строки заголовков, в раскрытиях строк, в конфигурации транспорта продолжают “видеть” оригинальные заголовки [#]_.

Опция **headers_remove** раскрывается после **errors_to** и **headers_add**, но до **transport**. Если раскрытие принудительно неудачно, опция не имеет эффекта. Другие ошибки раскрытия обрабатываются как ошибки конфигурации.

.. warning:: Опция **headers_remove** не может использоваться для роутера **redirect**, в котором установлена опция **one_time**.

.. warning:: Если в роутере установлена опция **unseen**, все запросы на удаление заголовков удаляются, при передаче следующему роутеру, и это может указывать на проблему с дубликатами - смотрите подобное предупреждение выше, для **headers_add**.

=======================  ============  ================  ==============
**ignore_target_hosts**  Use: routers  Type: host list†  Default: unset
=======================  ============  ================  ==============

Хотя эта опция - список хостов, обычно она содержит IP-адреса, а не имена. Если любой хост, который ищется роутером имеет IP-адрес совпадающий с элементом этого списка, Exim ведёт себя так, будто этот IP-адрес несуществует. Эта опция позволяет вам справляться с мошенническими DNS-записями, типа

::

    remote.domain.example.  A  127.0.0.1

устанавливая

::

    ignore_target_hosts = 127.0.0.1

на релевантном роутере. Если все хосты найденные роутером **dnslookup** забракованы таким образом, роутер отклоняется. В обычной конфигурации, попытка отправки почты на такой домен, обычно вызывает ошибку “unrouteable domain”, и попытка проверить адрес в домене будет неудачной. Точно также, если в роутере **ipliteral** установлена опция **ignore_target_hosts**, роутер отклоняется если представлен один из перечисленных адресов.
   
Вы можете использовать эту опцию для отключения использования IPv4 или IPv6 для доставки почты, путём первого или второго параметра настройки, сответственно::

    ignore_target_hosts = 0.0.0.0/0
    ignore_target_hosts = <; 0::0/0

Шаблон в первой строке совпадает со всеми адресами IPv4, тогда как паттерн во второй строке совпадает со всеми адресами IPv6.

Эта опция также может быть полезна для игнорирования локальных связей и локальных сайтов адресов IPv6. Поскольку, как и все списки хостов, значение **ignore_target_hosts** раскрывается до использования в качестве списка, возможно сделать его зависимым от маршрутизируемого домена.

В процессе раскрытия, $host_address устанавливается в проверяемый IP-адрес.

==============  ============  =============  ==============
**initgroups**  Use: routers  Type: boolean  Default: false
==============  ============  =============  ==============

Если роутер стоит в очереди на адрес для транспорта, и эта опция истинна, и uid, предоставленный роутером не перезадан транспортом, при работе транспорта вызывается функция *initgroups()* , для гарантии, что установлены любые дополнительные группы ассоциированные с uid. Также смотрите обсуждение **group** и **user** в главе :ref:`23 <ch23_00>`.

=====================  =============  =================  ==============
**local_part_prefix**  Use: routers‡  Type: string list  Default: unset
=====================  =============  =================  ==============

Если эта опция установлена, роутер пропускается, если локальная часть не начинается с одной из заданных строк, или если **local_part_prefix_optional** истинна. Смотрите раздел :ref:`3.12 <ch03_12>` для получения списка в котором оцениваются предварительные условия.

Список сканируется слева направо, и используется первый совпавший префикс. Доступна ограниченная форма подстановочных знаков; если префикс начинается со звёздочки, он совпадает с самой длинной последовательностью символов в начале локальной части. Поэтому, звёздочка всегда должна сопровождаться каким-то символом, который не встречается в нормальных локальных частях. Подстановочные символы могут использоваться для установки многопользовательских почтовых ящиков, как описано в разделе :ref:`47.8 <ch47_08>`.

В процессе тестирования опции **local_parts**, и когда роутер запущен, префикс удаляется из локальной части, и он доступен в переменной раскрытия $local_part_prefix. Когда сообщение доставляется, если роутер принимает адрес, это остаётся истинным в процессе последующей доставки транспортом. В частности, локальная часть, передаваемая командой RCPT для доставок LMTP, SMTP, и BSMTP, по умолчанию, удаляет префикс. Это поведение может быть перезадано путём установки **rcpt_include_affixes** в истину, в соответствующем транспорте.

Когда адрес проверяется, **local_part_prefix** затрагивает лишь поведение роутера. Если используется обратный вызов, это означает, что полный адрес, включая префикс, будет использоваться в обратном вызове.

Префиксы, обычно, используются для обработки локальных частей вида “owner-something”. Другое частое использование - поддержка локальных частей формы “real-username” для обхода пользовательского файла *.forward* - полезно, когда тяжело сказать пользователю, что его форвардинг кривой - путём помещения роутера типа такого, сразу до роутера, обрабатывающего файлы *.forward*::

    real_localuser:
           driver = accept
           local_part_prefix = real-
           check_local_user
           transport = local_delivery

В целях безопасности, возможно, хорошей идеей было бы ограничить использование этого роутера локально сгенерированными сообщениями, используя условие типа такого::

    condition = ${if match {$sender_host_address}\
                           {\N^(|127\.0\.0\.1)$\N}}

Если оба **local_part_prefix** и **local_part_suffix** установлены для роутера, оба условия должны быть не дополнительными. Нужно быть осторожным, если подстановочный знак используется в обоих - префиксе и суффиксе в одном роутере. Должны использоваться различные символы как разделители, для избежания двусмысленности.

==============================  ============  =============  ==============
**local_part_prefix_optional**  Use: routers  Type: boolean  Default: false
==============================  ============  =============  ==============

Смотрите выше, опцию **local_part_prefix**.

=====================  =============  =================  ==============
**local_part_suffix**  Use: routers‡  Type: string list  Default: unset
=====================  =============  =================  ==============

Эта опция работает точно также как и **local_part_prefix**, за исключением, что локальная часть должна заканчиваться (а не начинаться) данной строкой, опция **local_part_suffix_optional** определяет, какой суффикс обязателен, и подстановочный символ “*”, если присутствует, должен быть последним символом суффикса. Это опциональное средство обычно используется для обработки локальных частей формы “something-request”, и многопользовательских почтовых ящиков вида “username-foo”.

==============================  ============  =============  ==============
**local_part_suffix_optional**  Use: routers  Type: boolean  Default: false
==============================  ============  =============  ==============

Смотрите выше, опцию **local_part_suffix**.

===============  =============  ======================  ==============
**local_parts**  Use: routers‡  Type: local part list†  Default: unset
===============  =============  ======================  ==============

Роутер запускается лишь если локальная часть адреса совпадает с этим списком. Смотрите раздел :ref:`3.12 <ch03_12>`, для получения порядка, в котором оцениваются предварительные условия, и раздел :ref:`10.21 <ch10_21>` для обсуждения списков локальных частей. Поскольку строка раскрывается, возможно сделать её зависимой от домена, например::

    local_parts = dbm;/usr/local/specials/$domain

Если поиском достигнуто соответствие, данные, возвращённые поиском для локальных частей, помещаются в переменную $local_part_data для использования в раскрытии частных опций роутера. Вы могли бы использовать эту опцию, например, если у вас много локальных вирутальных доменов, и вы хотите слать всю почту постмастера в одно место, без необходимости установки альяса в каждом виртуальном домене::

    postmaster:
       driver = redirect
       local_parts = postmaster
       data = postmaster@real.domain.example

================  ============  =============  ==================
**log_as_local**  Use: routers  Type: boolean  Default: see below
================  ============  =============  ==================

Exim имеет два стиля логгинга для доставки, с целью более явно отделить локальные доставки от удалённых. В “локальном” стиле,  адрес получателя даётся так же как и локальная часть, без домена. Использование этого стиля контролируется этой опцией. По умолчанию, она истинна для роутера **accept**, и ложна для всех остальных. Эта опция применяется лишь когда роутер назначает адрес транспорту. Она не оказывает эффекта на роутеры, переадресовывающие адреса.

========  ============  ==============  =============
**more**  Use: routers  Type: boolean†  Default: true
========  ============  ==============  =============

Результат раскрытия строки, для этой опции, должен быть допутимым булевым значением, т.е. одна из строк “yes”, “no”, “true”, или “false”. Любой другой результат вызывает ошибку, и доставка задерживается. Если ракрытие принудительно неудачное, используется дефолтовое значение (истина) опции. Другие ошибки вызывают задержку доставки.

Если эта опция установлена в ложь, и роутер отказывается обрабатывать адрес, дальнейшие маршрутизаторы не проверяются, роутинг неудачен, и сообщение рикошетит [#]_ . Однако, если роутер явно передаёт адрес следующему роутеру, путём установки

::

    self = pass

или иначе, установка **more** игнорируется. Кроме того, установка **more** не затрагивает поведение, если одна из предварительных проверок неудачна. В этом случае, адрес всегда передаётся следующему роутеру.
      
Отметьте, что **address_data** не является предварительным условием. Если это раскрытие принудительно неудачно, роутер отклоняется, и значение **more** контролирует, что происходит дальше.

===================  ============  =============  ==============
**pass_on_timeout**  Use: routers  Type: boolean  Default: false
===================  ============  =============  ==============

Если у роутера таймаут в процессе поиска хоста, обычно это вызывает задержку адреса. Если установлена **pass_on_timeout**, адрес передаётся следующему роутеру, отменяя **more**. Это может быть полезным для систем, которые периодически связаны с интернетом, или тем, которые хотят передавать умному хосту любые сообщение, которые не могут быть немедленно доставлены.

Тут могут быть другие случайные временные ошибки, которые могут произойти при поиске в DNS. Они обрабатываются таким же образом как таймауты, и эта опция применяется ко всем ним.

===============  ============  ============  ==============
**pass_router**  Use: routers  Type: string  Default: unset
===============  ============  ============  ==============

Роутеры, которые распознают общие опции (**dnslookup**, **ipliteral** и **manualroute**) способны вернуть **pass**, принудительно продолжая роутинг сообщения, и перезадавая ложную установку **more**. Когда один из этих роутеров возвращает **pass**, адрес обычно передаётся следующему роутеру в последовательности. Это может быть изменено путём установки **pass_router** в имя другого роутера. Однако (в отличие от **redirect_router**), названный роутер должен быть ниже текущего маршрутизатора, для избежания петель. Отметьте, что эта опция применяется лишь к специальному случаю **pass**. Она не применяется, когда роутер возвращает **decline**.

===================  ============  ============  ==============
**redirect_router**  Use: routers  Type: string  Default: unset
===================  ============  ============  ==============

Иногда администратор знает, что бессмысленно заново подвергать переработке адреса в том же самом роутере, которые были сгенерены из файлов альясинга или форвардинга. Например, если файл альясов переводит реальные имена в идентификаторы логинов, нет смысла искать по файлу альясов второй раз, особенно если это большой файл.

Опция **redirect_router** может быть установлена в имя любого роутера. Это заставляет маршрутизацию любого сгенерённого адреса начаться с именованного роутера, вместо первого роутера. Эта опция не имеет эффекта, если если роутер, в котором она установлена, не генерирует новые адреса.

=================  =============  ==================  ==============
**require_files**  Use: routers‡  Type: string list†  Default: unset
=================  =============  ==================  ==============

Эта опция предоставляет главный механизм для утверждения работы роутера, на существовании или отсутствии определённых файлов или директорий. До запуска роутера, как одна из предварительных проверок, Exim обрабатывает этот способ через список **require_files**, отдельно раскрывая каждый его элемент.

Пскольку список разбивается до ракрытия, любые двоеточия в элементах раскрытия должны быть удвоены, или должно использоваться средство иного разделителя списка. Если какое-то раскрытие принудительно неудачно, этот элемент игнорируется. Другие ошибки раскрытия вызывают задержку роутинга адреса.

Если какая-либо раскрытая строка пуста, она игнорируется. Иначе, кроме как описано ниже, каждая строка должна быть полным путём к файлу, с опционально предшествующим символом “!”. Пути передаются на тестирование функции *stat()*, для проверки существования файлов или каталогов. Роутер пропускается, если какой-либо путь, которому не предшествует “!”, не существует, или существует любой путь, с предшествующим “!”.

Если *stat()* не может определить, существует файл или нет, доставка сообщения задерживается. Это может произойти, если недоступны смонтированные по NFS файловые системы.

Эта опция проверяется после опций **domains**, **local_parts** и **senders**, таким образом, вы не можете её использовать для проверки существования файла, в котором ищется домен, локальная часть адреса, или отправитель. (Смотрите раздел :ref:`3.12 <ch03_12>`, для получения порядка, в котором оцениваются предварительные условия.) Однако, поскольку все эти опции являются раскрываемыми, вы можете использовать условие раскрытия **exists**, для создания таких проверок. Опция **require_files** предназаначена для проверки файлов, которые маршрутизатор может быть будет использовать внутри себя, или которые необходимы транспорту (например, *.procmailrc*).

В процессе доставки, функция *stat()* выполняется от root`a, но есть средство для некоторых проверок доступности файла от другого пользователя. Это не точная проверка разрешений, а “грубая” проверка, работающая следующим образом:
                  
Если элемент в списке **require_files** не содержит символов прямого слэша, он берётся как пользователь (и опциональная группа, отделённая двоеточием) для проверки последующих файлов в списке. Если группа не задана, но пользователь задан символически, используется gid ассоциированный с uid. Например::

    require_files = mail:/some/file
    require_files = $local_part:$home/.procmailrc

Если имя пользователя или группы в **require_files** не существует, условие **require_files** неуспешно. Exim выполняет проверку путём сканирования компонентов пути файла, и проверяя доступ для данных gid и uid. Это проверка на “x” для директорий, и “r” для финального файла. Отметьте, это означает, что при поддержке файловых ACL, они игнорируются.


.. warning:: Когда роутер начинает работу по проверке адресов для входящего SMTP-сообщения, Exim не работает от root`a, а под своим собственным uid. Это может затронуть результта проверки **require_files**. В частности, *stat()* может привести к ошибке EACCES (“Permission denied”). Это означает, что пользователю exim`a не разрешено читать одну из директорий в пути файла.

.. warning:: Даже когда Exim выполняется от root`a при доставке сообщения, *stat()* может привести к EACCES для файлов в NFS директории, смонтированной без доступа root`y. В этом случае, если запрошена проверка на доступ специфического пользователя, exim создаёт субпроцесс, который работает от пользователя, и снова пробует проверить в этом процессе.

Дефолтовое действие для обработки EACCES полагает, что это вызвано конфигурационной ошибкой, и роутинг задерживается, поскольку существование или отсутствие файла не может быть определено. Однако, в некоторых обстоятельствах, может быть желательным обработать это условие, как будто файл не существовал. Например::

    require_files = +/some/file

Если роутер - не основная часть проверки (например, он обрабатывает пользовательские файлы *.forward*), иное решение - установить установить опцию **verify** в ложь, тогда роутер был пропущен при проверке.

========================  ============  =============  ==================
**retry_use_local_part**  Use: routers  Type: boolean  Default: see below
========================  ============  =============  ==================

Когда с доставкой присходит временная ошибка роутинга, в базе хинтов Exim`a создаётся запись о повторею Для адресов, маршрутизация которых зависит лишь от домена, ключ для записи повтора не должен содержать локальную часть, но для других адресов, обе - доменная и локальная части должны быть включены. Обычно, удалённый роутинг первого вида, и локальный роутинг - последнего.

Эта опция контролирует, используется ли локальная часть для формирования подсказок [#]_ для адресов, которые подверглись временным ошибкам, будучи обработанными этим роутером. Дефолтовое значение - истина для лубого роутера, который имеет установленную **check_local_user**, и ложь, в противном случае. Отметьте, что эта опция не применяется к ключам подсказок для транспортных задержек; они контролируются одноимённой общей транспортной опцией.

Установка опции **retry_use_local_part** применяется лишь к роутеру, в котором она фигурирует. Если роутер генерит дочерний адрес, они роутятся независимо; эта установка не прилагается к ним.

=========================  ============  =============  ==============
**router_home_directory**  Use: routers  Type: string†  Default: unset
=========================  ============  =============  ==============

Эта опция устанавливает домашнюю  директорию, для использования при работе роутера. (Сравните **transport_home_directory**, которая устанавливает домашнюю директорию для более поздней транспортировки.) В частности, если используется роутер **redirect**, эта опция устанавливает значение $home, когда работает фильтр. Значение раскрывается; принудительная ошибка раскрытия вызывает игнорирование опции - другие ошибки вызывают задержку роутинга.

Раскрытие **router_home_directory** происходит сразу после проверки **check_local_user** (если сконфигурировано), до любых будущих раскрытий. (Смотрите раздел :ref:`3.12 <ch03_12>`, для получения порядка, в котором оцениваются предварительные условия.) Когда роутер работает, **router_home_directory** перезадаёт значение $home, пришедшее из **check_local_user**.

Когда роутер принимает адрес и назначает его локальному транспорту (включая случаи, когда роутер **redirect** генерит трубу, файл, или доставку автоответа), установка домашней директории для транспорта берётся из первого установленного значения:
* Опции **home_directory** в транспорте;
* Опции **transport_home_directory** в роутере;
* Данных пароля, если опция **check_local_user** установлена в роутере;
* Опции **router_home_directory**, в роутере.

Другими словами, **router_home_directory** перезадаёт данные пароля для роутера, но не для транспорта.

========  ============  ============  ===============
**self**  Use: routers  Type: string  Default: freeze
========  ============  ============  ===============

Эта опция применяется к тем роутерам, которые используют адрес получателя для нахождения списка удалённых хостов. В настоящее время, это роутеры **dnslookup**, **ipliteral** и **manualroute**. Определённые конфигурации маршрутизатора **queryprogram** также могут задавать список удалённых хостов. Обычно, такие маршрутизаторы сконфигурированы для посылки сообщения к удалённому хосту через **smtp** транспорт. Опция **self** задаёт, что происходит когда первый хост в списке оказывается локальным хостом. Способ проверки локального хоста Exim`ом, описан в разделе :ref:`13.8 <13_08>`.

Обычно, эта ситуация указывает на ошибку конфигурации в Exim`e (например, роутер должен быть сконфигурен не обрабатывать этот домен), или ошибку в DNS (например, MX не должен указывать на этот хост). По этой причине, дефолтовое действие - залоггировать инцидент, задержать адрес, и заморозить сообщение. Следующие альтернативы предоставляются для использования в специальных случаях:

* **defer**
  Сообщение пробуется ещё раз доставить, позднее, но оно не заморожено.

* **reroute:** <domain>
  Домен изменяется на данный домен, и адрес передаётся назад, для обработки роутерами. Перезапись заголовков не производится. По существу, это поведение - переназначение.

* **reroute:** **rewrite:** <domain>
  Домен изменяется на заданный домен, и адрес возвращется назад, для повторной обработки роутером. Любые заголовки, которые содержат оригинальный домен, перезаписываются.

* **pass**
  Роутер передаёт адрес следующему роутеру, или роутеру, или роутеру названному в опции **pass_router**, если она установлена. Это перезадаёт **no_more**. В течение последующего роутинга и доставки, переменная $self_hostname содержит имя локального хоста, с которым столкнулся роутер. Это может использоваться для различения различных случаев, для хостов с несколькими именами. Комбинация

  ::
  
      self = pass
             no_more

  гарантирует, что передаются лишь те адреса, которые роутились к локальному хосту. Без **no_more**, адреса отклонённые по иным причинам, также будут передаваться следующему роутеру.

* **fail**
  Доставка неудачна, и генерится отчёт о ошибке.

* **send**
  Аномалия игнорируется, и адрес ставиться в очередь для транспорта. Эта установка должна использоваться с критическим предостережением. Для транспорта **smtp**, это имеет смысл лишь в случаях, когда программа, слушаяющая SMTP-порт, не эта версия Exim`a. Таким образом,это должен быть какой-то иной MTA, или exim с иным конфигурационным файлом, который обрабатывает домен иным способом.

===========  =============  ===================  ==============
**senders**  Use: routers‡  Type: address list†  Default: unset
===========  =============  ===================  ==============

Если эта опция установлена, роутер пропускается, если адрес отправителя сообщения не совпадает с чем-то в списке. Смотрите раздел :ref:`3.12 <ch03_12>`, для получения порядка, в котором оцениваются предварительные условия.

Существуют проблемы относительно проверки, когда работа роутеров зависит от отправителя. Когда Exim проверяет адрес в установке **errors_to**, он устанавливает отправителя в нулевую (null) строку. Когда для проверки конфигурационного файла используется опция **-bt**, также необходимо использовать опцию **-f**, для установки соответствующего отправителя. Для входящей почты, отправитель не установлен, когда проверяется отправитель, но он доступен, когда проверяется любой получатель. Если включена команда SMTP VRFY, она должна использоваться после MAIL, если имеет значение адрес отправителя.

========================  ============  =============  ==============
**translate_ip_address**  Use: routers  Type: string†  Default: unset
========================  ============  =============  ==============

Существует несколько редких сетевых ситуаций (например, пакетная радиосвязь), когда полезна возможность транслировать IP-адрес, сгенерённый нормальными механизмами роутинга, в другие IP-адреса, выполняя свого рода ручную маршрутизацию. Это должно быть сделано, лишь если нормальная IP-маршрутизация TCP/IP стека неадекватна, или не работает. Поскольку это - черезвычайно необычное требование, код для поддержки этой опции не включается в бинарник Exim`a, если в *Local/Makefile* не установлена опция 

::

    SUPPORT_TRANSLATE_IP_ADDRESS=yes.
   
Строка **translate_ip_address** раскрывается для каждого IP-адреса сгенереённого роутером, с установкой сгенерённого IP-адреса в $host_address. Если раскрытие принудительно неудачно, никаких действий не предпринимается. Для любых других ошибок раскрытия, доставка сообщения задерживается. Если результат раскрытия - IP-адрес, он заменяет оригинальный адрес; иначе, предполагается что результат является именем хоста, он ищется используя *gethostbyname()* (или *getipnodebyname()*, когда она доступна) для создания одного и более замещающих IP-адресов. Например, для отмены всех адресов в некоторых сетях, к роутеру может быть добавлено такое::

    translate_ip_address = \
       ${lookup{${mask:$host_address/26}}lsearch{/some/file}\
               {$value}fail}}

Файл содержал бы такие строки::

    10.2.3.128/26    some.host
    10.8.4.34/26     10.44.8.15

Вы не должны использовать это средство, если вы не понимаете, что оно делает.

=============  ============  =============  ==============
**transport**  Use: routers  Type: string†  Default: unset
=============  ============  =============  ==============

Эта опция определяет транспорт который будет использован когда роутер принимает адрес, и устанавливает его для доставки. Транспорт никогда не бывает нужен, если роутер используется лишь для проверки. Значение опции раскрывается во время роутинга, после раскрытия **errors_to**, **headers_add** и **headers_remove**, и результта должен быть именем одного из сконфигуренных транспортов. Если это не так, доставка задерживается.

Опция **transport** не используется роутером **redirect**, но он имеет некоторые частные опции которые устанавливают транспорты для трубы (pipe) и доставки в файл (смотрите главу :ref:`22 <ch22_00>`).

===============================  ============  =============  ==============
**transport_current_directory**  Use: routers  Type: string†  Default: unset
===============================  ============  =============  ==============

Эта опция ассоциирует текущую директорию с любым адресом, который роутится локальным транспортом. Это может происходить потому, что транспорт явно сконфигурирован для роутера, или потому что генерится доставка в файл или трубу. В течение процесса доставки (т.е. в транспортное время), строка этой опции раскрывается и устанавливает текущую директорию, исключая перезадание установкой транспорта. Если раскрытие неудачно по любой причине, включая принудительную неудачу, ошибка логгируется, и доставка задерживается. Смотрите главу :ref:`23 <ch23_00>`, для получения деталей о окружении локальной доставки.

============================  ============  =============  ==================
**transport_home_directory**  Use: routers  Type: string†  Default: see below
============================  ============  =============  ==================

Эта опция ассоциирует домашнюю директорию с любым адресом, который роутится локальным транспортом. Это может происходить потому, что транспорт явно сконфигурирован для роутера, или потому что генерится доставка в файл или трубу. В течение процесса доставки (т.е. в транспортное время), строка этой опции раскрывается и устанавливает домашнюю директорию, исключая перезадание установкой **home_directory** в транспорте. Если раскрытие неудачно по любой причине, включая принудительную неудачу, ошибка логгируется, и доставка задерживается.

Если транспорт не определяет домашнюю директорию, и **transport_home_directory** не установлена для роутера, домашняя директория для транспорта берётся из данных пароля, если для роутера установлена опция **check_local_user**. Иначе, она берётся из **router_home_directory**, если она установлена; если нет - домашняя директория для транспорта не устанавливается.

Смотрите главу :ref:`23 <ch23_00>`, для получения деталей о окружении локальной доставки.

==========  ============  ==============  ==============
**unseen**  Use: routers  Type: boolean†  Default: false
==========  ============  ==============  ==============

Результат раскрытия строки, для этой опции, должен быть допустимым булевым значением, т.е. одной из строк “yes”, “no”, “true”, или “false”. Любой другой результат вызывает ошибку, и доставка задерживается. Если раскрытие принудительно неудачно, используется дефолтовое значение этой опции (ложь). Другие ошибки вызывают задержку доставки.

Когда эта опция установленна в истину, маршрутизация не прекращается, если роутер принимает адрес. Вместо этого, копия входящего адреса передаётся следующему роутеру, перезадавая ложную установку опции **more**. Есть небольшая точка, в установке **more** в ложь, если **unseen** всегда истинно, но это может быть полезным в случаях, когда значение **unseen** содержит раскрываемый элемент (поэтому, оно иногда истинно, а иногда ложно).

Установка опции **unseen** имеет эффект подобный команде **unseen** в файлых фильтров. Она может использоваться для доставки копий сообщений на другой адрес, когда, также, необходимо выполнить нормальную доставку. В действительности, текущий адрес превращается в “родителя”, имеющего двух детей - один из которых доставляется как задано в роутере, и клон, продолжающий дальнейший роутинг. Поэтому, **unseen** не может быть объединён с опцией **one_time**, в роутере **redirect**.

.. warning:: Добавленные к адресу строки заголовков (или определённые для удаления), этим или предыдущим роутерами, затрагивают лишь “невидимую” копию сообщения. Клон, который продолжает обрабатываться будущими роутерами, не содержит добавленный или определённых на удаление заголовков. Для роутера **redirect**, если сгенерированный адрес - такой же как и входящий адрес, это может индицировать дубликацию адресов с различной модификацией заголовков. Exim не дублирует доставки (за исключением определённых случаев, в трубы - смотрите раздел :ref:`22.7 <ch22_07>`), но нездано от какого дубликата отказаться, таким образом этой неопределённой ситуации необходимо избегать. Может быть полезной опция **repeat_use**, роутера **redirect**.

В отличие от обработки модификации заголовков, любые данные установленные опцией **address_data** в текущем или предыдущем роутерах, передаются последующим роутерам.

========  ============  =============  ==================
**user**  Use: routers  Type: string†  Default: see below
========  ============  =============  ==================

Когда роутер стоит в очереди на адрес для транспорта, и транспорт не определяет пользователя, заданный тут пользователь используется при работе процесса доставки. Пользователь может быть задан числом или по имени. Если раскрытие неудачно, ошибка логгируется, и доставка задерживается. Также, этот пользователь используется роутером **redirect**, при работе файла фильтра. По умолчанию она не задана, кроме случаев когда установлена опция **check_local_user**. В этом случае, дефолт берётся из информации пароля. Если пользователь задан по имени, и “group” не задана, группа ассоциируется с используемым пользователем. Смотрите обсуждение **initgroups** и **initgroups** в главе :ref:`23 <ch23_00>`.

==========  =============  =============  =============
**verify**  Use: routers‡  Type: boolean  Default: true
==========  =============  =============  =============

Установка этой опции имеет эффект установки **verify_sender** и **verify_recipient** в тоже значение.

===============  =============  =============  ==============
**verify_only**  Use: routers‡  Type: boolean  Default: false
===============  =============  =============  ==============

Если эта опция установлена, роутер используется лишь для проверки адреса, или тетстирования с опцией **-bv**, не для фактической доставки, тестирования с опцией **-bt**, или запуска команды SMTP EXPN. Далее, она может быть ограничена только проверкойотправителя или получателя, путём **verify_sender** и **verify_recipient**.

.. warning:: Когда роутер работает проверяя адрес входящего SMTP сообщения, Exim не работает от root`a, а под своим собственным uid.  Если роутер обращается к каким-то файлам, вы должны удостовериться, что они доступны пользователю или группе Exim`a.

====================  =============  =============  =============
**verify_recipient**  Use: routers‡  Type: boolean  Default: true
====================  =============  =============  =============

Если эта опция ложна, роутер пропускается при проверке адреса получателя, или тестировании проверки получателя, с ипользованием опции **-bv**. Смотрите раздел :ref:`3.12 <ch03_12>`, для получения порядка, в котором оцениваются предварительные условия.

=================  =============  =============  =============
**verify_sender**  Use: routers‡  Type: boolean  Default: true
=================  =============  =============  =============

Если эта опция ложна, роутер пропускается при проверке адреса отправителя, или тестировании проверки отправителя, с ипользованием опции **-bvs**. Смотрите раздел :ref:`3.12 <ch03_12>`, для получения порядка, в котором оцениваются предварительные условия.

.. [#] т.е. не видят добавленные - прим. lissyara
.. [#] т.е. видят удалённые - прим. lissyara
.. [#] посылается рикошет - прим. lissyara
.. [#] хинтов - прим. lissyara
