
.. _ch20_00:

Роутер **manualroute**
======================

Роутер **manualroute** назван таким образом потому что он предоставляет возможность “ручной” маршрутизации (manual routing) адреса в соответствии с его доменом. Главным образом он используется в случае, когда вы хотите маршрутизировать почту на удаленные узлы по собственным правилам, в обход обыкновенной DNS-маршрутизации, механизм которой выполняет поиск MX-записей. Однако, роутер **manualroute** также может выполнять маршрутизацию на локальные транспорты, такая возможность может оказаться полезной, если вы хотите сохранять сообщения для входящих (dial-in) узлов в локальных файлах.

Роутер **manualroute** сравнивает список доменных шаблонов с доменной частью адреса, который он пытается маршрутизировать. Если совпадения не найдено, то роутер отклоняется. Каждый шаблон, ассоциированный с роутером представляет собой список узлов, а также другую дополнительную информацию, в которую может входить транспорт. Комбинация шаблона и других его данных называется “правилом маршрутизации”. Для шаблонов, не имеющих ассоциированного с ними транспорта, общая опция роутеров **transport** должна определять соответствующий транспорт, если только роутер не используется исключительно для проверки (verification) (см. опцию **verify_only**).

В случае, если роутер используется для проверки, то совпадения с доменным шаблоном достаточно для того, чтобы роутер принял адрес. В действительности, при маршрутизации адреса для доставки, доменная часть которого совпала с  доменным шаблоном, адрес помещается в очередь ассоциированного с роутером транспорта. Если транспорт не является локальным, то с шаблоном должен быть ассоциирован список узлов (host list); выполняется разрешение имен в IP-адреса, которые затем передаются транспорту вместе с почтовым адресом. Для локального транспорта список узлов (host list) является опциональным. Если он присутствует, то он передается в переменной $host как простая текстовая строка.

Список правил маршрутизации может быть определен как строка, включенная (inline string) в опцию **route_list**, либо как данные, полученные путем поиска домена в файле или базе данных, определенных опцией **route_data**. Только одна из них может быть определена в пределах одного экземпляра роутера manualroute. Формат правил маршрутизации описан ниже, вслед за списком частных опций **manualroute**.

.. _ch20_01:

Частные опции **manualroute**
-----------------------------

Частные опции для **manualroute** таковы:

.. index::
   pair: manualroute; host_all_ignored

====================  ================  ============  ==============
**host_all_ignored**  Use: manualroute  Type: string  Default: defer
====================  ================  ============  ==============

Смотрите **host_find_failed**.

.. index::
   pair: manualroute; host_find_failed

====================  ================  ============  ===============
**host_find_failed**  Use: manualroute  Type: string  Default: freeze
====================  ================  ============  ===============

Эта опция управляет тем, что происходит когда **manualroute** пытается найти IP-адрес узла, а его не существует. Опции может быть дано одно из следующих значений::

    decline
    defer
    fail
    freeze
    ignore
    pass

Значение по умолчанию (freeze”) предполагает, что данное состояние - серьезная конфигурационная ошибка. Разница между значениями “pass” и “decline” состоит в том, что предыдущий пункт принудительно передает адрес следующему роутеру (либо роутеру, указанному в опции **pass_router**), перекрывая опцию **no_more**, тогда как в недавнем прошлом адрес передавался следующему роутеру только в случае истинности опции **more**.

Значение “ignore” заставляет Exim полностью игнорировать хост, чей IP адрес не может быть найден. Если все хосты в списке проигнорированы, поведение контролируется опцией **host_all_ignored**. Она может принимать те же самые значения, что и **host_find_failed**, за исключением того, что эта опция не может быть установлена в “ignore”.

Опция **host_find_failed** применяется только к состоянию “не существует”; если поиск узла выдает врeменную ошибку, то доставка откладывается, только если не установлена общая опция **pass_on_timeout**.

.. index::
   pair: manualroute; hosts_randomize

===================  ================  =============  ==============
**hosts_randomize**  Use: manualroute  Type: boolean  Default: false
===================  ================  =============  ==============

Если установлена эта опция, то порядок элементов в списке узлов внутри правила маршрутизации каждый раз выбирается случайным образом при обращении к нему, если не перекрывается опцией в самом правиле маршрутизации (см. ниже). Выбор порядка узлов в списке случайным образом может быть использован для первичного распределения нагрузки. Однако, если один и тот же роутер маршрутизирует более одного почтового адреса на один и тот же список узлов, то списки должны быть одинаковыми (даже если они расположены в случайном порядке) для решения о том, помещать ли несколько доставок в одну SMTP-транзакцию. 

В случае если опция **hosts_randomize** истинна, список узлов может быть разделен на группы, порядок которых отдельно устанавливается случайным образом. Это делает возможным установить MX-подобное поведение. Границы между группами помечаются символом “+” в списке узлов. Например,

::

    route_list = * host1:host2:host3:+:host4:host5

Порядок, в котором сортируются первые три узла и порядок сортировки последних двух выбирается случайным образом при каждом использовании, но первая группа всегда располагается перед второй. Если опция **hosts_randomize** не установлена, символ разделителя “+” в списке игнорируется. Если такой список узлов со случайной внутренней сортировкой, предается транспорту **smtp**, который также имеет подобную опцию **hosts_randomize**, то список заново не генерируется в случайном порядке.

.. index::
   pair: manualroute; route_data

==============  ================  =============  ==============
**route_data**  Use: manualroute  Type: string†  Default: unset
==============  ================  =============  ==============

Если эта опция определена, то ее значение должно раскрываться, т.к. она определяет данные правила маршрутизации. Обычно, раскрываемая строка включает в себя поиск на основе домена. Например::

    route_data = ${lookup{$domain}dbm{/etc/routes}}

Если раскрытие строки принудительно завершилось неудачей, либо результатом явилась пустая строка, то роутер пропускается. Другие причины неудачного раскрытия ведут к откладыванию доставки.

.. index::
   pair: manualroute; route_list

==============  ================  =================  ==============
**route_list**  Use: manualroute  Type: string list  Default: unset
==============  ================  =================  ==============

Эта строка является списком правил маршрутизации в форме, определенной ниже. Обратите внимание, что в отличие от большинства списков строк, элементы здесь разделяются символом “;”. Так сделано, потому что данный список может содержать разделенные символом “:” списки узлов.

.. index::
   pair: manualroute; same_domain_copy_routing

============================  ================  =============  ==============
**same_domain_copy_routing**  Use: manualroute  Type: boolean  Default: false
============================  ================  =============  ==============

Обычно, адреса с одинаковой доменной частью маршрутизируются роутером **manualroute** на один и тот же список узлов. Однако, это не может быть допустимо, поскольку опции и предусловия роутера могут использовать локальную часть адреса. Поэтому по умолчанию Exim маршрутизирует каждый адрес в сообщении независимо. DNS-серверы используют кэши, поэтому повторяющиеся DNS-запросы не являются помехой, и в любом случае личные сообщения редко имеют много получателей. 

Если у вас функционируют списки рассылки с большим количеством подписчиков из одного домена, и вы используете роутер **manualroute**, который не зависит от локальной части почтового адреса, то вы можете установить опцию **same_domain_copy_routing** во избежание повторяющихся DNS-запросов для одного и того же домена получателя в сообщении. В этом случае, если роутер **manualroute** маршрутизирует адрес удаленному транспорту, то все оставшиеся несмаршрутизированные адреса в сообщении, имеющие тот же домен получателя, перенаправляются автоматически без независимой обработки. Однако, это выполняется только в том случае, если не установлены опции **headers_add** и **headers_remove**.

.. _ch20_02:

Правила маршрутизации в опции **route_list**
--------------------------------------------

Значением опции **route_list** является строка, состоящая из последовательности правил маршрутизации, разделенных символом “;”. Если “;” указыватся внутри самого правила, то оно должно быть представлено как “;;”. Пустые правила игнорируются. Формат каждого правила - следующий::

    <шаблон домена>  <список узлов>  <опции>

Следующий пример состоит из двух правил, каждое из которых содержит простой доменный шаблон и не содержит опций::

    route_list = \
           dict.ref.example  mail-1.ref.example:mail-2.ref.example ; \
           thes.ref.example  mail-3.ref.example:mail-4.ref.example

Три части правила разделяются пробелами. Шаблон домена и список узлов могут быть, если это необходимо, заключены в кавычки, и если это так, то применяются обычные правила для кавычек (quoting rules). Каждое правило опции **route_list** должно начинаться с шаблона домена (domain pattern), единственного обязательного элемента в правиле. Шаблон должен быть указан в том же формате, что и элемент в доменном списке (domain list) (см. раздел :ref:`10.8 <ch10_08>`), за тем исключением, что он не может быть именем включаемого файла. То есть, он может содержать просто шаблон, либо регулярное выражение, либо поиск в файле или базе данных (с двойным символом “;”, из-за использования “;” как разделителя в опции **route_list**).


Правила в **route_list** просматриваются до первого совпадения доменного шаблона с маршрутизируемым доменом. Затем, как описано ниже, используются список узлов  и опции.  Если совпадений не найдено, то роутер пропускается. Если установлена опция **route_list**, то не должна быть определена опция **route_data**.

.. _ch20_03:

Правила маршрутизации в опции **route_data**
--------------------------------------------

Использование опции **route_list** подходит в случае использования небольшого количества правил маршрутизации. Для больших объемов проще использовать файл или базу данных для хранения информации о маршрутах и вместо нее использовать опцию **route_data**. Значением опции **route_data** является список узлов со следующими за ним необязательными опциями. Чаще всего **route_data** определяется как строка, содержащая раскрываемый поиск (expansion lookup). Например, представьте что вы поместили 2 правила маршрутизации в файл::

    dict.ref.example:  mail-1.ref.example:mail-2.ref.example
    thes.ref.example:  mail-3.ref.example:mail-4.ref.example

Эти данные могут быть доступными путем установки::

    route_data = ${lookup{$domain}lsearch{/the/file/name}}

Не увенчавшийся успехом поиск возвращает пустую строку, вследствие этого роутер пропускается. Однако, не стоит использовать поиск в **route_data**. Единственное требование здесь, это то, что результатом преобразования строки должен быть список узлов, возможно со следующими за ним опциями, разделенные пробелами. Если список узлов содержит пробелы, то он должен быть заключен в кавычки.

.. _ch20_04:

Формат списка узлов
-------------------

Список узлов, полученный либо через **route_data**, либо через **route_list**, всегда раскрыватся отдельно перед использованием. Если раскрытие завершается неудачно, то роутер пропускается. Результат преобразования должен быть списком имен и/или IP-адресов. IP-адреса в скобки не помещаются.

* Если список узлов получен из опции **route_list**, то во время преобразования устанавливаются следующие переменные:

* Если домен удовлетворяет регулярному выражению, то могут быть установлены числовые переменные “$1”, “$2”, и т.д.

  ::

      route_list = ^domain(\d+) host-$1.text.example

* “$0” всегда содержит имя домена целиком.
* “$1” также устанавливается в случае неполного совпадения при поиске в файле.

* Если шаблон, с которым совпал домен, был элементом поиска (lookup item), то данные, поиск которых производился, доступны в переменной “$value”. Например::

      route_list = lsearch;;/some/file.routes $value

Заметьте, что удвоение “;” в шаблоне является обязательным, т.к. “;” - разделитель списка по умолчанию.

.. _ch20_05:

Формат одного элемента хоста
----------------------------

Каждый элемент в списке хостов является или именем хоста или адресом IP, опционально, с номером порта. При отсутствии номера порта, адрес даётся без квадратных скобок. Когда порт задан, то это отменяет спецификацию порта на транспорте. Порт отделяется от адреса двоеточием. Это приводит к некоторым осложнениям:

* Поскольку двоеточие - дефолтовый разделитель списка хостов, то либо необходимо удвоить двоеточия отделяющие номер порта, или изменить разделитель. Следующие два примера одинаковы::
  
      route_list = * "host1.tld::1225 : host2.tld::1226"
      route_list = * "<+ host1.tld:1225 + host2.tld:1226"

* Когда используются адреса IPv6, всё станвиться ещё хуже, т.к. в них используются двоеточия. Чтобы облегчить такие случаи, разрешено помещать адрес IPv6 или IPv4 в квадратные скобки, если за ним следует номер порта. Например::
  
      route_list = * "</ [10.1.1.1]:1225 / [::1]:1226"

.. _ch20_06:

Как используется список узлов
-----------------------------

В процессе маршрутизации адреса на транспорт **smtp** при помощи **manualroute**, пробуется каждый из узлов в определенном порядке.  Однако, порядок может быть изменен опцией **hosts_randomize** либо в конфигурации роутера (см. раздел :ref:`20.1 <ch20_01>` выше), либо в конфигурации транспорта.

Узлы могут быть перечислены по именам или по IP-адресам. Имя в списке узлов интерпретируется как имя узла. Имя с последующим за ним суффиксом “/MX” интерпретируется как косвенная ссылка на подсписок узлов, полученный путем поиска MX-записей в DNS. Например, 

::

    route_list = *  x.y.z:p.q.r/MX:e.f.g

Если в списке узлов присутствует порт, он должен указываться в последную очередь::

    route_list = * dom1.tld/mx::1225

Если установлена опция **hosts_randomize**, то перед любым поиском порядок элементов в списке сортируется случайным образом. Затем Exim просматривает список; для всех имен без суффикса “/MX”, он выполняет поиск IP-адреса. Если им оказывается адрес интерфейса локальной машины и элемент в списке не стоит первым, то поведение определяется опцией роутера **self**.

Имя в списке с суффиксом “/MX” заменяется списком узлов, полученных в результате поиска MX-записей для имени. Это всегда выполняется посредством DNS-запроса; опции **bydns** и **byname** здесь неуместны. Порядок этих узлов определяется, как обычно, по значениям приоритета MX-записей. Поскольку случайная сортировка выполняется перед MX-поиском, то она не влияет на порядок, определенный MX-записями DNS.

Если локальная машина присутствует в подсписке, полученном путем просмотра MX-записей, но не является наиболее предпочитаемым узлом в нем, то она и узлы равного и меньшего приоритета удаляются из подсписка перед тем, как он вставляется в главный список.

Если локальная машина - наиболее предпочтительный узел в MX-списке, то все зависит от того, где в главном списке узлов стоит элемент “/MX”. Если он не является в нем первым элементом (потому как в списке перед ним есть узлы), то Exim отвергает это имя, а также все последующие элементы в главном списке.

Если MX-элемент стоит первым в списке, и локальная машина является наиболее предпочтительным узлом, то все зависит от опции роутера **self**.

Неудачные результаты поиска MX-записей в DNS обрабатываются так же как и при поиске IP-адресов: там где это необходимо используются опции **pass_on_timeout** и **host_find_failed**.

Общая опция **ignore_target_hosts** применяется ко всем узлам в списке, независимо получены ли он путем поиска MX-записей или нет.

.. _ch20_07:

Как используются опции
----------------------

Опции - это последовательность слов; на практике - присутствует не более трех. Одно из слов может быть именем транспорта, перекрывая опцию роутера **transport** лишь для данного правила маршрутизации. Другие слова управляют случайной сортировкой списка узлов по каждому правилу отдельно., а также тем как ищутся IP-адреса узлов в процессе маршрутизации на удаленный транспорт. Эти опции следующие:

* **randomize**: случайно сортировать порядок узлов в списке, перекрывая опцию **hosts_randomize** только для этого правила маршрутизации.
* **no_randomize**: не сортировать случайным образом порядок узлов в списке, перекрывая опцию **hosts_randomize** только для этого правила маршрутизации.
* **byname**: использовать *getipnodebyname()* (*gethostbyname()* на старых системах) для поиска IP-адресов. Эта функция может в конечном счете сделать DNS-запрос, хотя она может выполнить поиск в */etc/hosts* или в других источниках подобной информации.
* **bydns**: искать адресные запиcи для узлов в DNS, неудачный исход - в случае отсутствмя таковых. Если существует временная ошибка DNS (например, таймаут), то доставка откладывается. 

Например::

    route_list = domain1  host1:host2:host3  randomize bydns;\
                 domain2  host4:host5

Если ни опция **byname**, ни опция **bydns** не определены, то Exim ведет себя следующим образом: Сначала выполняется DNS-запрос. Если возвращается что-либо отличное от HOST_NOT_FOUND, то используется этот результат. В противном случае, Exim пытается вызвать *getipnodebyname()* или *gethostbyname()*, и результатом поиска становится результат, возвращенный этим вызовом.

.. warning:: На некоторых системах обнаружено, что если в результате DNS-запроса, производимого через функцию *getipnodebyname()*, происходит таймаут, то возвращается HOST_NOT_FOUND вместо TRY_AGAIN. Вот почему по умолчанию сначала выполняется DNS-запрос. Локальная функция вызывается только в том случае, если ответом на него является “no such host”.

Если для узла не найдено IP-адреса, то дальнейшие действия управляются опцией **host_find_failed**.
                         

В случае, когда адрес маршрутизируется на локальный транспорт, поиск IP-адресов не производится. Список узлов передается транспорту в переменной “$host”.

.. _ch20_08:

Примеры manualroute
-------------------

В некоторых из нижеследующих примеров подразумевается присутствие транспорта **remote_smtp**, как это определено в файле конфигурации по умолчанию:

* Роутер **manualroute** может быть использован для перенаправления всей входящей почты на т.н. “быстрый узел” (“smart host”). Если в главной части конфигурации описан именованный список доменов (named domain list), содержащий к примеру,
  
  ::
  
      domainlist local_domains = my.domain.example

  то вы можете указать для всех остальных доменов отправлять почту на смартхост, при этом ваш первый роутер будет выглядеть примерно так::
  
      smart_route:
        driver = "manualroute"
        domains = !+local_domains
        transport = remote_smtp
        route_list = * smarthost.ref.example


  В результате этого все адреса, не входящие в список **local_domains**, будут направляться на узел “smarthost.ref.example”. Если указан разделенный “:” список узлов, то они пробуются все по порядку (однако вы можете использовать опцию **hosts_randomize** для того, чтобы изменять порядок каждый раз). Другой способ конфигурации той же самой задачи таков::
  
      smart_route:
        driver = "manualroute"
        transport = remote_smtp
        route_list = !+local_domains  smarthost.ref.example


  Разницы в поведении между этими роутерами нет. Однако, они ведут себя по-разному если добавить к обоим роутерам опцию **no_more**. В первом примере, роутер будет пропущен, если если домен не совпадает с предусловием **domains**; и пробуется всегда следующий роутер. Если роутер запускается, то он всегда совпадает с доменом и поэтому никогда не может быть быть отклонен. Поэтому **no_more** не будет иметь эффекта в данном случае. Во втором случае роутер никогда не пропускается; он всегда выполняется. Однако, если совпадения с доменом не происходит, то роутер отклоняется. В этом случае опция **no_more** предотвратит запуск последующих роутеров.

* “Почтовый концентратор” - это узел, который получает почту для нескольких доменов через MX-записи в DNS и доставляет их через свой механизм маршрутизации. Часто пункты назначения находятся за брандмауэром, с “почтовым концентратором” располагающимся на одной машине, которая может соединяться с машинами внутри и снаружи брандмауэра. Роутер **manualroute** обычо используют на “почтовом концентраторе” для маршрутизации входящих сообщений на корректные узлы. Для небольшого количества доменов маршрутизация может быть включением (inline) в опцию **route_list**, но для большого количества доменов проще управлять поиском в файле и базе данных.

  Если имена доменов фактически являются именами машин, на которые отправляется почта почтовым концентратором, то конфигурация может быть простой. Например,
  
  ::
  
      hub_route:
        driver = "manualroute"
        transport = remote_smtp
        route_list = *.rhodes.tvs.example  $domain

  Эта конфигурация маршрутизирует домены, совпадающие с шаблоном “\*.rhodes.tvs.example” на узлы, чьи имена такие же как и почтовые домены. Похожий результат может быть получен если имя узла извлекается из имени домена путем манипуляции со строкой. Как альтернативный вариант, можно использовать поиск узла на основе домена::
  
      through_firewall:
        driver = "manualroute"
        transport = remote_smtp
        route_data = ${lookup {$domain} cdb {/internal/host/routes}}

  Результатом поиска должно быть имя узла(узлов) или его IP-адрес на который должен быть смаршрутизирован проверяемый адрес. Если поиск завершается неудачей, то данные о маршрутах оказываются пустыми, в результате чего роутер отклоняется. Затем адрес передается следующему роутеру.

* Вы можете использовать **manualroute** для доставки сообщений в трубы (pipes) или в файлы в пакетном формате SMTP для дальнейшей транспортировки по каким-либо причинам. Это способ хранения почты для dial-up узла в течение времени когда он не подключен к сети. Запись **route_list** может быть просто доменным именем, например так::
  
        save_in_file:
          driver = "manualroute"
          transport = batchsmtp_appendfile
          route_list = saved.domain.example

  Хотя часто шаблон используется для описания более одного домена. Если есть несколько доменов или групп доменов с различными транспортными требованиями, то разные транспорты могут быть перечислены в информации о маршрутах::
  
        save_in_file:
          driver = "manualroute"
         
          route_list = \
            *.saved.domain1.example  $domain  batch_appendfile; \
            *.saved.domain2.example  \
            ${lookup{$domain}dbm{/domain2/hosts}{$value}fail} \
            batch_pipe

  Первый из них просто передает домен в переменную “$host”, которая не очень полезна (т.к. домен находится также в переменной “$domain”), но второй шаблон выполняет поиск в файле для нахождения переменной для передачи, заставляя роутер отклонять обработку адреса если поиск завершится неудачно.

* Маршрутизация почты прямиком на программный пакет UUCP - это особый вариант использования **manualroute** в роли шлюза в другое почтовое окружение. Вот пример способа как можно это сделать::
  
      # Transport
      uucp:
        driver = pipe
        user = nobody
        command = /usr/local/bin/uux -r - \
          ${substr_-5:$host}!rmail ${local_part}
        return_fail_output = true

        
      # Router
      uucphost:
        transport = uucp
        driver = "manualroute"
        route_data = \
          ${lookup{$domain}lsearch{/usr/local/exim/uucphosts}}


        
  Файл */usr/local/exim/uucphosts* состоит из записей вида::
  
      darksite.ethereal.example:           darksite.UUCP


     
  Можно описать это проще без добавления и удаления “.UUCP” но этот способ показывает различие между именем домена “darksite.ethereal.example” и именем UUCP-станции “darksite”.


