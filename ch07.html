
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Файл конфигурации по умолчанию &mdash; Specification of the Exim Mail Transfer Agent 4.70 documentation</title>
    
    <link rel="stylesheet" href="static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.70',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="static/translations.js"></script>
    <link rel="top" title="Specification of the Exim Mail Transfer Agent 4.70 documentation" href="index.html" />
    <link rel="next" title="Регулярные выражения" href="ch08.html" />
    <link rel="prev" title="Файл конфигурации Exim во время выполнения" href="ch06.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch08.html" title="Регулярные выражения"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch06.html" title="Файл конфигурации Exim во время выполнения"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Specification of the Exim Mail Transfer Agent 4.70 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ch07-00">
<span id="id1"></span><h1>Файл конфигурации по умолчанию<a class="headerlink" href="#ch07-00" title="Ссылка на этот заголовок">¶</a></h1>
<p>Конфигурационный файл по умолчанию, поставляемый с Exim`ом как <em>src/configure.default</em>, достаточен для хоста, не имеющему особых требований к почтовой системе. В качестве вводной главы, в конфигурировании Exim`а, этот раздел представляет собой “путь через значения по-умолчанию”, давая краткие пояснения параметров настройки. Детальные описания параметров, даются в последующих главах. Конфигурационный файл по умолчанию содержит много комментариев о том, как изменить значения по умолчанию. Однако, необходимо отметить, что имеется множество параметров, которые вообще не упомянуты в конфигурации по умолчанию.</p>
<div class="section" id="ch07-01">
<span id="id2"></span><h2>Главные конфигурационные настройки<a class="headerlink" href="#ch07-01" title="Ссылка на этот заголовок">¶</a></h2>
<p>Главные (глобальные) конфигурационные параметры должны быть в начале файла. Первое, что необходимо установить, после вводных комментариев, это строка:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># primary_hostname =</span>
</pre></div>
</div>
<p>Это - закомментированная установка параметра <strong>primary_hostname</strong>. Exim должен знать официальное, полное имя вашего хоста, и тут можно его задать. Однако, в большинстве случаев, вам не нужно устанавливать этот параметр. Когда он не задан, Exim использует системную функцию <em>uname()</em>, для получения имени хоста.</p>
<p>Первые три раскомментированные линии таковы:</p>
<div class="highlight-python"><pre>domainlist local_domains = @
domainlist relay_to_domains =
hostlist   relay_from_hosts = 127.0.0.1</pre>
</div>
<p>Фактически, они не параметры настройки. Это определения двух именованных списков доменов, и одного именованного списка хостов. Exim позволяет давать имена спискам доменов, хостов и e-mail адресов для облегчения управления конфигурационным файлом (смотрите секцию <a class="reference internal" href="ch10.html#ch10-05"><em>10.5</em></a>).</p>
<p>Первая строка задаёт список доменов, называемый <em>local_domains</em>; он используется позже, в конфигурации, для определения доменов которые нужно доставлять на локальный хост.</p>
<p>Tут, в этом списке, только одно значение, строка “&#64;”. Это специальная форма, вхождение которой означает имя локального хоста. Таким образом, если локалхост называется <em>a.host.example</em>, то почта к любому пользователю типа <em>any.user&#64;a.host.example</em> будет доставляться локально. Поскольку на имя локалхоста ссылаются косвенно, то можно использовать одинаковый конфиг на разных хостах.</p>
<p>Вторая строка задаёт список доменов, называемый <em>relay_to_domains</em>, но список пуст. Позже, в конфигурации, будет часть контролирующая релеинг почты через локальный хост; он позволяет релеить любые домены из этого списка. По умолчанию, здесь, не разрешён релей на основе имён почтовых доменов.</p>
<p>Третья строка задаёт список хостов, называемый <em>relay_from_hosts</em>. Этот список используется позже, в конфигурации, для разрешения релея от любых хостов или IP-адресов, которые совпадают со списком. По-умолчанию, в нём содержится только IP-адрес интерфейса обратной петли, что означает, что процессы на локальном хосте могут пересылать почту к другим хостам через Exim, соединяясь с ним по TCP/IP на интерфейсе обратной петли.</p>
<p>Для того, чтобы не было непонимания: в этом пункте конфигурации мы не устанавливаем никаких значений директив. Мы просто задаём некоторые домены и хосты, использующиеся в директивах заданных позже.</p>
<p>Следующие две строки - настоящие параметры настройки:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">acl_smtp_rcpt</span> <span class="o">=</span> <span class="n">acl_check_rcpt</span>
<span class="n">acl_smtp_data</span> <span class="o">=</span> <span class="n">acl_check_data</span>
</pre></div>
</div>
<p>Эти параметры задают <em>Access Control Lists</em> (списки контроля доступа - ACLs), которые используются в течение входящего SMTP-подключения для каждого получателя сообщения (на каждую команду RCPT), и после того, как сообщение было получено, соответственно. Названия списков - <em>acl_check_rcpt</em> и <em>acl_check_data</em>, и мы доберёмся до их определения ниже, в конфигурационной секции ACL. RCPT ACL контролирует, какие получатели разрешены для входящих сообщений - если конфигурация не содержит ACL для проверки получателей, то никакая почта по SMTP не принимается. DATA ACL разрешает проверку содержимого сообщения.</p>
<p>Следующие две закомментированные строки:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># av_scanner = clamd:/tmp/clamd</span>
<span class="c"># spamd_address = 127.0.0.1 783</span>
</pre></div>
</div>
<p>Они - пример настроек, которые могут использоваться когда Exim собран с расширением проверки контента(content-scanning extension). Первая задаёт интерфейс к сканеру вирусов, и вторая задаёт интерфейс к SpamAssassin. Дальнейшие детали даются в разделе <a class="reference internal" href="ch41.html#ch41-00"><em>41</em></a>.</p>
<p>После них идут ещё 3 закомментированные строки:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># tls_advertise_hosts = *</span>
<span class="c"># tls_certificate = /etc/ssl/exim.crt</span>
<span class="c"># tls_privatekey = /etc/ssl/exim.pem</span>
</pre></div>
</div>
<p>Они являются примером настроек, которые могут использоваться, если Exim скомпилирован с поддержкой TLS (SSL), смотрите секцию <a class="reference internal" href="ch04.html#ch04-07"><em>4.7</em></a>. Первый параметр задаёт список клиентов, которые при подключении к серверу могут использовать TLS, “*” в этом случае подразумевает любого клиента. Остальные параметры служат для указания того, где Exim должен искать свой TLS сертификат и приватный ключ (private key), которые вместе однозначно идентифицируют сервер для всех клиентов. Вы можете найти дополнительную информацию в главе <a class="reference internal" href="ch39.html#ch39-00"><em>39</em></a>.</p>
<p>Дальше следуют две закомментированые параметры:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># daemon_smtp_ports = 25 : 465 : 587</span>
<span class="c"># tls_on_connect_ports = 465</span>
</pre></div>
</div>
<p>Эти параметры предоставляют улучшенную поддержку удалённым пользователям, которые желают использовать этот сервер для отправки почты. Они редко используются, если Вы не используете TLS (как его включать было описано в предыдущем параграфе) и аутентификацию (о которой говорится в секции <a class="reference internal" href="#ch07-07"><em>7.7</em></a>). Очень часто стандартный SMTP порт (25-ый) заблокирован для пользователей из конечных сетей (end-user network), поэтому <span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc4409.html"><strong>RFC 4409</strong></a> позволяет использовать альтернативный, 587-ой порт для передачи почты. К сожалению некоторые приложения (особенно Microsoft Outlook) не могут быть настроены на использование 587-го порта, т.к. настройки выше также включают нестандартный 465 &#8220;smtps&#8221; (&#8220;ssmtp&#8221;) порт (см. секцию <a class="reference internal" href="ch13.html#ch13-04"><em>13.4</em></a>).</p>
<p>Далее ещё две закомментированных строки:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># qualify_domain =</span>
<span class="c"># qualify_recipient =</span>
</pre></div>
</div>
<p>Первая из них задаёт домен, который Exim использует, при создании полного адреса электронной почты, из имени логина локального пользователя. Часто это необходимо при получении Exim`ом почты от локального процесса. Если вы не задали <strong>qualify_domain</strong>, то используется значение <strong>primary_hostname</strong>. Если вы задали оба этих параметра, то можно иметь разные домены для адресов получателей и отправителей. Если же используете только первую, то её значение используется для обоих директив.</p>
<p>Следующая строка может быть раскомментирована, если вы хотите чтобы Exim понимал адреса формы <em>user&#64;[10.11.12.13]</em>, то есть с “буквальным доменом” (“domain literal” - IP-адрес в квадратных скобках) вместо именованного домена.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># allow_domain_literals</span>
</pre></div>
</div>
<p>RFC всё ещё требуют эту форму, но много людей считают что в современном интернете посылка почты определённым хостам, указывая их IP-адрес имеет мало смысла. Этот старый формат использовался людьми рассылающими спам. Однако, некоторые полагают, что есть обстоятельства (например письма постмастеру), когда этот формат полезен.</p>
<p>Следующая строка конфигурации, своего рода защита:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">never_users</span> <span class="o">=</span> <span class="n">root</span>
</pre></div>
</div>
<p>Это определяет, что никакая доставка не должна осуществляться от имени пользователя <em>root</em>. Нормальное соглашение заключалось в том, что <em>root</em> - псевдоним системного администратора. Этот параметр - охранный. Список пользователей, определённых как <strong>never_users</strong> - неполный, при компиляции в <em>Local/Makefile</em> есть параметр FIXED_NEVER_USERS, задающая список, который не может быть отменён. Содержимое <strong>never_users</strong> добавляется к списку. По-умолчанию, FIXED_NEVER_USERS содержит пользователя <em>root</em>.</p>
<p>Когда удалённый хост подключается к Exim`y, чтобы послать почту, единственная информация, которую имеет Exim, о идентификации хоста - это его IP-адрес. Следующая конфигурационная строка,</p>
<div class="highlight-python"><pre>host_lookup = *</pre>
</div>
<p>задаёт, что Exim должен проводить обратный поиск в DNS для всех входящих соединений, чтобы получить имя хоста. Это улучшает качество логов, но если вы чувствуете, что это обходиться слишком дорого, то вы можете удалить этот пункт вообще, или ограничить поиск хостами в соседних сетях. Отметьте, что не всегда можно найти имя хоста по его IP-адресу, поскольку не все обратные DNS-зоны обслуживаются, и некоторые DNS-сервера могут быть недоступны.</p>
<p>Следующие две строки занимаются вызовом <em>ident</em>, как определено в <span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc1413.html"><strong>RFC 1413</strong></a>, следовательно их имена:</p>
<div class="highlight-python"><pre>rfc1413_hosts = *
rfc1413_query_timeout = 5s</pre>
</div>
<p>Эти настройки заставляют Exim делать вызовы <em>ident</em> для всех входящих SMTP подключений. Вы можете ограничить список хостов, на которые делается этот вызов, или изменить таймаут, если он используется. Можно поставить таймаут в ноль, тогда все вызовы <em>ident</em> будут заблокированы. Хотя они обходятся дёшево, и могут дать полезную информацию для трассировки проблем сообщений, некоторые хосты и фаерволлы имеют проблемы с запросами <em>ident</em>. Это может привести к таймауту вместо немедленного сброса подключения, в случае отказа, приводя к задержке на старте входящего SMTP подключения.</p>
<p>Когда Exim получает сообщения по SMTP, то ожидается, что все хосты будут иметь полное доменное имя, как требуется по определению SNMP. Однако если на ваш сервер шлют сообщения простые пользователи, то они могут иметь неподходящие адреса. Две закомментированные параметры:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># sender_unqualified_hosts =</span>
<span class="c"># recipient_unqualified_hosts =</span>
</pre></div>
</div>
<p>указывают как вы можете задать хосты, которым разрешается посылать неполные адреса отправителей и получателей (имеются ввиду адреса без домена - тока имя пользователя).</p>
<p>Параметр <strong>percent_hack_domains</strong> также закомментирован:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># percent_hack_domains =</span>
</pre></div>
</div>
<p>Она обеспечивает список доменов, для которых должно работать “percent hack”. Это - почти устаревший параметр явной почтовой маршрутизации. Если вы ничего не знаете об этом - то также можете проигнорировать этот параметр. <a class="footnote-reference" href="#id10" id="id3">[1]</a></p>
<p>Два последних параметра настройки конфигурации по умолчанию касаются сообщений, “замороженных” в очереди Exim`a. Когда сообщение заморожено, Exim не продолжает попытки доставить его. Замораживание происходит когда сообщение об отлупе сталкивается с постоянным отказом, поскольку отправитель оригинального сообщения, вызвавшего рикошет, недопустим, и таким образом отлуп нельзя доставить. Это - наиболее частая причина, но есть и другие причины заморозки, и замороженные сообщения - не всегда рикошеты.:</p>
<div class="highlight-python"><pre>ignore_bounce_errors_after = 2d
timeout_frozen_after = 7d</pre>
</div>
<p>Первый из этих параметров определяет, что рикошеты будут выброшены из очереди через два дня. Второй задаёт что любое замороженное сообщение (рикошет или другое) будет выброшено из очереди через неделю. При таких настройках, гарантируется, что попытки доставки рикошета никогда не будут длиться неделю. <a class="footnote-reference" href="#id11" id="id4">[2]</a></p>
</div>
<div class="section" id="acl">
<span id="ch07-02"></span><h2>Конфигурация ACL<a class="headerlink" href="#acl" title="Ссылка на этот заголовок">¶</a></h2>
<p>В настройке по умолчанию, секция ACL следует за главной конфигурацией. Она начинается со строки:</p>
<div class="highlight-python"><pre>begin acl</pre>
</div>
<p>и она содержит определения двух ACL, называемых <em>acl_check_rcpt</em> и <em>acl_check_data</em> на которые выше ссылались параметры настройки <strong>acl_smtp_rcpt</strong> и <strong>acl_smtp_data</strong>.</p>
<p>Первая ACL, используется для всех команд RCPT для входящих SMTP сообщений. Каждая команда RCPT  определяет одного получателя сообщения. Утверждения ACL рассматриваются до тех пор, пока адрес либо принимается либо отклоняется. Тогда команда RCPT либо принята, либо отклонена, согласно результату обработки ACL.:</p>
<div class="highlight-python"><pre>acl_check_rcpt:</pre>
</div>
<p>Эта строка, состоящая из названия завершённого двоеточием, отмечает начало ACL и именует её.:</p>
<div class="highlight-python"><pre>accept  hosts = :</pre>
</div>
<p>Это утверждение ACL принимает получателя, если хост соответствует списку. Но что означает этот странный список? Он, фактически, не содержит никаких имён хостов, или адресов IP. Присутствие двоеточия, помещает в пустой элемент в список; Exim сопоставляет его только с входящими сообщениями, которые идут не с удалённого хоста (только с локалхоста), поскольку в этом случае, имя удалённого хоста пустой. Двоеточие важно. Без него список пуст, и никогда ничему не соответствует.</p>
<p>То, что делает это утверждение, - разрешает безоговорочный приём всех получателей в сообщениях переданных по SMTP от локальных процессов, с использованием стандартного ввода и вывода (т.е. без использования TCP/IP). Множество MUA работает в такой манере.</p>
<div class="highlight-python"><pre>deny    message       = Restricted characters in address
        domains       = +local_domains
        local_parts   = ^[.] : ^.*[@%!/|]

deny    message       = Restricted characters in address
        domains       = !+local_domains
        local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./</pre>
</div>
<p>Это утверждение занимается тем, чтобы локальная часть адреса не содержали некоторые символы - “&#64;”, “%”, “!”, “/”, “|”, или точки в необычных местах. Хотя эти символы могут абсолютно законно использоваться в локальной части адреса (в случае “&#64;” и начальной точки, только если корректно заэкранировано), обычно они не встречаются в почтовых адресах.</p>
<p>Первые три имеют прошлые ассоциации с явной маршрутизации  адресов (символ процента используется до сих пор - смотрите параметр <strong>percent_hack_domains</strong>). Адреса содержащие эти символы регулярно пробуют спамеры, в попытках обойти ограничения релея почты, и программами проверяющими хост на открытый релей. Если вы в них не нуждаетесь, то самое безопасное - отклонить их на ранней стадии. Эта конфигурация отклоняет эти символы для всех удалённых хостов. Это преднамеренная политика, для достижения, насколько возможно, максимальной безопасности.</p>
<p>Первое правило более строгое, и оно применяется к сообщениям, которые адресованы к одному из локальных доменов, которые крутятся на этом хосте. Это осуществляется первым условием, которое ограничивает его доменами перечисленными в списке <em>local_domains</em>.  Символ “+” используется для указания ссылки на именованный список. В данной конфигурации, тут только один домен в <em>local_domains</em>, но вообще, может быть несколько.</p>
<p>Второе условие в первом утверждение использует два регулярных выражения, для блокирования локальных частей начинающихся с точки, или содержащих “&#64;”, “%”, “!”, “/”, или “|”. Если у вас есть учётки использующие эти символы, то надо изменить это правило.</p>
<p>Пустые компоненты (две точки подряд) недопустимы по <span class="target" id="index-2"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2822.html"><strong>RFC 2822</strong></a>, но Exim разрешает их, поскольку с ними столкнулись практически. (Обычно локальная часть выглядит так: <em>first-initial.second-initial.family-name</em>, но иногда бывает, что второго инициала нет, как у автора Exim) Однако, локальная часть начинающаяся с точки, или содержащая “/../” может вызывать проблемы, если она используется как часть имени (например в списке рассылки). Также это истинно для локальных частей содержащих слэши. Символ трубы “|” также может принести неприятности, если локальная часть легкомысленно включена в командную строку шелла.</p>
<p>Второе правило, применяемое ко всем прочим доменам менее строго. Это позволяет локальным пользователям посылать сообщения к другим серверам, использующим слэши и трубы в локальной части адреса. Оно блокирует локальные части начинающиеся с точки, слэша, или трубы, но разрешает эти символы внутри локальной части. Однако, последовательность “/../” - запрещена. Использование “&#64;”, “%”, и “!” заблокировано. Мотивация - запретить пользователям (или пользовательским вирусам) от определённые виды атак на удалённые сервера.</p>
<div class="highlight-python"><pre>accept  local_parts   = postmaster
        domains       = +local_domains</pre>
</div>
<p>Это утверждение, имеющее два условия, разрешает входящий адрес если локальная часть <em>postmaster</em> и домен - один из перечисленных в списке <em>local_domains</em>. Символ “+” используется для указания ссылки на именованный список. В данной конфигурации, тут только один домен в <em>local_domains</em>, но вообще, может быть несколько.</p>
<p>Присутствие этого условия означает, что почта предназначенная постмастеру не блокируется последующими проверками. Это может быть полезным, при разборе проблем в последующих проверках, где неверно запрещается доступ.</p>
<div class="highlight-python"><pre>require verify        = sender</pre>
</div>
<p>Это утверждение требует, чтобы адрес отправителя был проверен до того, как будут последующие проверки ACL. Если проверка неудачна, то отказывается в доставке входящему адресу получателя.  Проверка состоит из попытки маршрутизировать адрес, с целью выяснить, можно ли по нему доставить сообщение о рикошете. В случае удалённых адресов, проверяется только домен, но для более точной проверки может использоваться <em>callouts</em>. Смотрите раздел 40.40 для получения дополнительной информации о проверке адреса.</p>
<div class="highlight-python"><pre>accept  hosts         = +relay_from_hosts
        control       = submission</pre>
</div>
<p>Это утверждение принимает адрес, если сообщение приходит с одного из хостов которым разрешён релей через этот хост. Проверка получателя тут опущена, поскольку во многих случаях клиенты - тупые MUA которые не в состоянии справиться ответами об ошибке SMTP. По этой же причине, вторая строка задаёт “режим подчинения” (“submission mode”) для принятых сообщений. Это детально описано в разделе <a class="reference internal" href="ch44.html#ch44-01"><em>44.1</em></a>; это заставляет Exim`a исправлять сообщения которые не доделаны (неполные или несовершенные), например, потому что у них отсутствует строка заголовка <em>Date:</em>. Если вы передаёте их наружу, с MTA, вы, вероятно, должны тут добавить проверку получателя, и отключить режим подчинения.</p>
<div class="highlight-python"><pre>accept  authenticated = *
        control       = submission</pre>
</div>
<p>Это утверждение принимает адрес, если клиентский хост подтвердил свою подлинность. Снова задан режим подчинения, поскольку сообщения, вероятнее всего, будут прибывать с MUA. В конфигурации по умолчанию не заданы аутентификаторы, хотя, он включает в себя закомемнтированные примеры описанные в <a class="reference internal" href="#ch07-07"><em>7.7</em></a>. Это означает, что, фактически, клиенты не могут аутентифицировать, пока вы не завершите определение айтентификаторов.</p>
<div class="highlight-python"><pre>require message = relay not permitted
        domains = +local_domains : +relay_domains</pre>
</div>
<p>Это утверждение отклоняет адреса, если их домен не является локальным или одним из доменов для которых этот хост является релеем.:</p>
<div class="highlight-python"><pre>require verify = recipient</pre>
</div>
<p>Это утверждение требует проверки адреса отправителя; если проверка неуспешна, адрес отклоняется.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># deny    message     = rejected because $sender_host_address \</span>
<span class="c">#                       is in a black list at $dnslist_domain\n\</span>
<span class="c">#                       $dnslist_text</span>
<span class="c">#         dnslists    = black.list.example</span>
<span class="c">#</span>
<span class="c"># warn    dnslists    = black.list.example</span>
<span class="c"># message     = X-Warning: $sender_host_address is in \</span>
<span class="c">#                 a black list at $dnslist_domain</span>
<span class="c">#         log_message = found in $dnslist_domain</span>
</pre></div>
</div>
<p>Эти закомментированные строки - пример того как вы можете сконфигурировать Exim для проверки отправляющего хоста в блэк-листах DNS. Первое утверждение отклоняет сообщения с хостов находящихся в чёрных списках, тогда как второе только добавляет строку заголовка с предупреждением.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># require verify = csa</span>
</pre></div>
</div>
<p>Эта закомментированная строка - пример того, как вы можете включить проверку клиентской SMTP авторизации (CSA).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">accept</span>
</pre></div>
</div>
<p>Финальное утверждение в первой ACL безоговорочно принимает любых отправителей, которые успешно прошли предыдущие тесты.</p>
<div class="highlight-python"><pre>acl_check_data:</pre>
</div>
<p>Эта строка отмечает начало второго ACL, и именует его. Большая часть содержимого этого ACL закомментирована:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># deny    malware   = *</span>
<span class="c">#         message   = This message contains a virus \</span>
<span class="c">#                     ($malware_name).</span>
</pre></div>
</div>
<p>Эти строки - пример того, как сделать чтобы сообщения были просканированы на вирусы, когда Exim скомпилен с поддержкой проверки контента, и установлен подходящий сканнер вирусов. Если в сообщении найден вирус, то оно отклоняется с заданным сообщением об ошибке.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># warn    spam      = nobody</span>
<span class="c">#         message   = X-Spam_score: $spam_score\n\</span>
<span class="c">#                     X-Spam_score_int: $spam_score_int\n\</span>
<span class="c">#                     X-Spam_bar: $spam_bar\n\</span>
<span class="c">#                     X-Spam_report: $spam_report</span>
</pre></div>
</div>
<p>Эти строки - пример того, как сделать, чтобы сообщения были просканированы SpamAssassin, когда Exim скомпилен с поддержкой проверки контента, и установлен SpamAssassin. Проверка SpamAssassin`ом выполняется от пользователя nobody, и результаты добавляются к сообщению как ряд дополнительных заголовков. В этом случае, сообщение не отклоняется, вне зависимости от того сколько очков ему поставлено.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">accept</span>
</pre></div>
</div>
<p>Это заключительная строка в DATA ACL, сообщение принимается безоговорочно.</p>
</div>
<div class="section" id="ch07-03">
<span id="id5"></span><h2>Конфигурация маршрутизатора<a class="headerlink" href="#ch07-03" title="Ссылка на этот заголовок">¶</a></h2>
<p>Конфигурация маршрутизаторов в конфигурации по умолчанию, начинается со следующей линии:</p>
<div class="highlight-python"><pre>begin routers</pre>
</div>
<p>Маршрутизаторы - это модули в Exim`e, принимающие решение о том, куда слать сообщение. Адрес передаётся каждому маршрутизатору, по очереди, и он его либо принимает, либо нет. Это значит, что порядок в котором заданы маршрутизаторы - важен. Каждый маршрутизатор, позднее, полностью описан в его разделе, в этом руководстве. Тут даны только краткие обзоры.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># domain_literal:</span>
<span class="c">#   driver = ipliteral</span>
<span class="c">#   domains = !+local_domains</span>
<span class="c">#   transport = remote_smtp</span>
</pre></div>
</div>
<p>Этот маршрутизатор закомментирован, поскольку большинство серверов не поддерживает буквальные адреса (вида <em>user&#64;[10.9.8.7]</em>). Если вы раскомментируете этот маршрутизатор, также необходимо будет раскомментить параметр <strong>allow_domain_literals</strong> в основной части конфигурации.</p>
<div class="highlight-python"><pre>dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = remote_smtp
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
  no_more</pre>
</div>
<p>Первый незакомментированный маршрутизатор обрабатывает адреса, не относящиеся к локальным доменом. Это задано строкой:</p>
<div class="highlight-python"><pre>domains = ! +local_domains</pre>
</div>
<p>Параметр <strong>domains</strong> - список доменов к которым применяется этот маршрутизатор, но восклицательный знак является признаком отрицания (несоответствия), таким образом маршрутизатор используется только для доменов, которые не находятся в списке <em>local_domains</em> (который был определён в начале конфигурации). Символ “+” используется для указания ссылки на именованный список. Адреса в других доменах передаются следующим маршрутизатором.</p>
<p>Имя драйвера маршрутизатора - <strong>dnslookup</strong>, оно задано в параметре <strong>driver</strong>. Вас не должно смущать то, что имя маршрутизатора такое же как и имя драйвера. Название примера может быть произвольным, но имя заданное в параметре <strong>driver</strong> - должен быть один из модулей драйверов из исполняемого файла Exim`a.</p>
<p>Маршрутизатор <strong>dnslookup</strong> маршрутизирует адреса, ища их домены в DNS, для получения списка хостов к которым к которым должен маршрутизироваться адрес. Если маршрутизатор успешен, адрес ставиться в очередь транспорта <strong>remote_smtp</strong>, как задано в параметре <strong>transport</strong>. Если маршрутизатор не находит домен в DNS, то никакие дальнейшие маршрутизаторы не рассматриваются из-за параметра <strong>no_more</strong>, таким образом адрес неудачен, и не доставляется (возвращается сообщение о ошибке).</p>
<p>Параметр <strong>ignore_target_hosts</strong> задаёт список IP-АДРЕСОВ, которые должны полностью игнорироваться. Этот параметр присутствует по причине, что было много случаев, когда MX-запись в DNS указывает на имя хоста с адресом 0.0.0.0 или из 127-й подсети (обычно, 127.0.0.1). Полное игнорирование этих адресов лишает возможности Exim маршрутизировать почту к ним, таким образом доставка срывается. Иначе, Exim писал бы в логи о проблеме маршрутизации, и продолжал пытаться доставить сообщение, с определённым таймаутом.</p>
<div class="highlight-python"><pre>system_aliases:
  driver = redirect
  allow_fail
  allow_defer
  data = ${lookup{$local_part}lsearch{/etc/aliases}}
  # user = exim
  file_transport = address_file
  pipe_transport = address_pipe</pre>
</div>
<p>Управление передаётся этому и последующим маршрутизаторам, только если адрес в локальном домене. Этот маршрутизатор проверяет, задана ли локальная часть как синоним в <em>/etc/aliases</em>, и если это так, переадресовывает адрес согласно данным найденным в этом файле. Если для локальной части не найдено никаких данных, то значение параметра <strong>data</strong> пустое, и адрес передаётся следующему маршрутизатору.</p>
<p><em>/etc/aliases</em> - обычно это файл системных синонимов. Именно по этому на него, по-умолчанию, ссылается конфигурационный файл. Однако, это можно поменять, изменив параметры SYSTEM_ALIASES_FILE в <em>Local/Makefile</em> до сборки Exim`a.</p>
<div class="highlight-python"><pre>userforward:
  driver = redirect
  check_local_user
  # local_part_suffix = +* : -*
  # local_part_suffix_optional
  file = $home/.forward
  # allow_filter
  no_verify
  no_expn
  check_ancestor
  file_transport = address_file
  pipe_transport = address_pipe
  reply_transport = address_reply</pre>
</div>
<p>Этот маршрутизатор - самый сложный в конфигурации по умолчанию. Это другой перенаправляющий маршрутизатор, но он ищет данные перенаправления установленные отдельными пользователями. Установка <strong>check_local_user</strong> задаёт проверку локальной части, что она логин локального пользователя. Если это не так - маршрутизатор пропускается. За параметром <strong>check_local_user</strong> следуют два закомментированных п, а именно:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># local_part_suffix = +* : -*</span>
<span class="c"># local_part_suffix_optional</span>
</pre></div>
</div>
<p>указывают, как можно задать распознание локальной части суффиксов. Если раскомментировать первое, то суффикс начинающийся с плюса или минуса, за которым идёт какая-то последовательность символов, удаляется из локальной части и помещается в переменную $local_part_suffix. Второй параметр суффикса определяет, что присутствие суффикса в локальной части является необязательным. Когда суффикс есть, проверка локального логина пользователя использует локальную часть без суффикса.</p>
<p>Когда найден локальный аккаунт пользователя, то просматривается файл <em>.forward</em> в домашней директории пользователя. Если он не существует, или пуст, то маршрутизатор пропускается. Иначе, содержимое <em>.forward</em> интерпретируется как данные перенаправления (для дополнительных деталей, обратитесь к главе <a class="reference internal" href="ch22.html#ch22-00"><em>22</em></a>).</p>
<p>Традиционный файл <em>.forward</em> содержит лишь список адресов, каналов (труб), или файлов. Exim поддерживает всё это по-умолчанию. Однако, если установлен параметр <strong>allow_filter</strong> (по умолчанию, она закомментирована), содержимое файла интерпретируется инструкции Exim`a или sieve, если файл начинается с “#Exim filter” или “#Sieve filter”, соответственно. Фильтры пользователей обсуждаются в отдельном даокументе “Exim’s interfaces to mail filtering”.</p>
<p>Параметры <strong>no_verify</strong> и <strong>no_expn</strong> означают что этот маршрутизатор пропущен, когда проверяется адрес, или когда он выполняется вследствие команды SMTP EXPN. Есть две причины, чтобы это сделать:</p>
<ol class="arabic simple">
<li>В действительности, не очень важно, есть у пользователя файл <em>.forward</em> или нет, при проверке адреса на существование; это делается сознательно, чтобы не тратить ресурсы на бесполезную работу.</li>
<li>Ещё более важно, когда Exim проверяет адрес или обрабатывает команду EXPN во время SMTP сессии он работает от имени своего пользователя, а не от root. Группа - тоже его группа, и никаких дополнительных групп не установлено. Поэтому, вполне возможно, что Exim не сможет прочитать пользовательский файл <em>.forward</em> в этот момент.</li>
</ol>
<p>Установка <strong>check_ancestor</strong> препятствует маршрутизатору создавать новый адрес, являющийся таким же как и предыдущий, который переадресуется. (Это связано с относительно плохим взаимодействием между перенаправлением и подстановкой синонима - смотрите раздел <a class="reference internal" href="ch22.html#ch22-05"><em>22.5</em></a>)</p>
<p>Три финальных параметра конфигурации задают транспорты, которые должны использоваться когда в результате переадресации происходит прямую доставку в файл, или в трубу, или делает авто-ответ, соответственно. Например, если файл <em>.forward</em> содержит:</p>
<div class="highlight-python"><pre>a.nother@elsewhere.example, /home/spqr/archive</pre>
</div>
<p>доставка в <em>/home/spqr/archive</em> будет осуществлена запуском транспорта <strong>address_file</strong>.</p>
<div class="highlight-python"><pre>localuser:
  driver = accept
  check_local_user
  # local_part_suffix = +* : -*
  # local_part_suffix_optional
  transport = local_delivery</pre>
</div>
<p>Последний маршрутизатор устанавливает доставку в локальные почтовые ящики, при условии, что локальная часть адреса является логином пользователя, принимая адрес и задавая его транспорту <strong>local_delivery</strong>. Иначе, т.к. достигнут конец маршрутизаторов, адрес возвращается отправителю. Закомментированные настройки суффиксов выполняют ту же самую роль, что и в маршрутизаторе <strong>userforward</strong>.</p>
</div>
<div class="section" id="ch07-04">
<span id="id6"></span><h2>Транспортная конфигурация<a class="headerlink" href="#ch07-04" title="Ссылка на этот заголовок">¶</a></h2>
<p>Транспорты задают механизмы для фактической доставки сообщений. Они работают только когда на них ссылаются маршрутизаторы, таким образом порядок в котором они заданы - неважен. Раздел транспортов начинается с</p>
<div class="highlight-python"><pre>begin transports</pre>
</div>
<p>Определены один удалённый и четыре локальных транспорта.</p>
<div class="highlight-python"><pre>remote_smtp:
  driver = smtp</pre>
</div>
<p>Этот транспорт используется для доставки сообщений через SMTP-соединение. Все его параметры - по умолчанию. Список удалённых хостов даётся маршрутизатором.</p>
<div class="highlight-python"><pre>local_delivery:
  driver = appendfile
  file = /var/mail/$local_part
  delivery_date_add
  envelope_to_add
  return_path_add
  # group = mail
  # mode = 0660</pre>
</div>
<p>Транспорт <strong>appendfile</strong> используется для локальной доставки в пользовательские почтовые ящики, в традиционном формате BSD mailbox. По умолчанию, он запускается под uid и gid локального пользователя, что требует установки <em>липкого</em> (<em>sticky</em>) бита на директории <em>/var/mail</em>. Некоторые системы используют иной подход к запуску доставки почты, под специфической группой, вместо использования “липкого” бита. Закомментированные параметры показывают, как это может быть сделано.</p>
<p>При доставке, Exim добавляет к сообщению три заголовка: <em>Delivery-date:</em>, <em>Envelope-to:</em> и <em>Return-path:</em>. Это регулируется тремя параметрами, с подобными названиями.</p>
<div class="highlight-python"><pre>address_pipe:
  driver = pipe
  return_output</pre>
</div>
<p>Этот транспорт используется для обработки доставки в каналы, созданных в результате переадресации (подстановка синонима или пользовательским файлом <em>.forward</em>). Параметр <strong>return_output</strong> определяет, что любой вывод созданный каналом, должен быть возвращён отправителю.</p>
<div class="highlight-python"><pre>address_file:
  driver = appendfile
  delivery_date_add
  envelope_to_add
  return_path_add</pre>
</div>
<p>Это транспорт используется для обработки доставки в файлы, произведённый в результате переадресации. Имя файла не задаётся в <strong>appendfile</strong>, поскольку оно приходит от маршрутизатора <strong>redirect</strong>.</p>
<div class="highlight-python"><pre>address_reply:
  driver = autoreply</pre>
</div>
<p>Этот транспорт используется для обработки автоматических ответов, созданных пользовательскими фильтрами.</p>
</div>
<div class="section" id="ch07-05">
<span id="id7"></span><h2>Правила повторов по умолчанию<a class="headerlink" href="#ch07-05" title="Ссылка на этот заголовок">¶</a></h2>
<p>Секция повторов конфигурационного файла, содержит правила затрагивающие поведение Exim`a при повторах доставки сообщений, которые не удалось доставить с первого раза. Она начинается со строки</p>
<div class="highlight-python"><pre>begin retry</pre>
</div>
<p>В конфигурации по умолчанию, есть только одно правило, применяемое ко всем ошибкам:</p>
<div class="highlight-python"><pre>*   *   F,2h,15m; G,16h,1h,1.5; F,4d,6h</pre>
</div>
<p>Это заставляет Exim пытаться доставить любой временно неудачный адрес в течение двух часов каждые 15 минут, затем интервал начинается с часа и увеличивается с фактором полтора пока не пройдёт 16 часов, затем каждые 6 часов, до срока в 4 дня. Если адрес не удаётся доставить после 4-х дней временного отказа, то происходит создание рикошета (письмо возвращается отправителю).</p>
<p>Если секция повторов удалена из конфигурации, или она пуста (т.е. - не задано никаких правил повторов), Exim не предпринимает попыток повторных доставок. Это превращает временные ошибки в постоянные.</p>
</div>
<div class="section" id="ch07-06">
<span id="id8"></span><h2>Конфигурация перезаписи<a class="headerlink" href="#ch07-06" title="Ссылка на этот заголовок">¶</a></h2>
<p>Раздел конфигурации перезаписи, начинаемый с</p>
<div class="highlight-python"><pre>begin rewrite</pre>
</div>
<p>содержит правила для перезаписи адресов в прибывших сообщениях. В конфигурации по умолчанию нет правил перезаписи.</p>
</div>
<div class="section" id="ch07-07">
<span id="id9"></span><h2>Конфигурация аутентификаторов<a class="headerlink" href="#ch07-07" title="Ссылка на этот заголовок">¶</a></h2>
<p>Секция аутентификаторов файла конфигурации, начинаемая с</p>
<div class="highlight-python"><pre>begin authenticators</pre>
</div>
<p>задаёт механизмы для использования в команде SMTP AUTH. В файле конфигурации по умолчанию содержаться два закомментированных примера аутентификаторов, которые поддерживают аутентификацию пользователь/пароль открытым текстом, используя стандартный механизм PLAIN, и традиционный, но нестандартный механизм LOGIN, в которых Exim выступает в роли сервера. PLAIN и LOGIN поддерживаются большинством MUA.</p>
<p>Пример аутентификатора PLAIN выглядит так:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#PLAIN:</span>
<span class="c">#  driver                  = plaintext</span>
<span class="c">#  server_set_id           = $auth2</span>
<span class="c">#  server_prompts          = :</span>
<span class="c">#  server_condition        = Authentication is not yet configured</span>
<span class="c">#  server_advertise_condition = ${if def:tls_cipher }</span>
</pre></div>
</div>
<p>И пример аутентификатора LOGIN:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#LOGIN:</span>
<span class="c">#  driver                  = plaintext</span>
<span class="c">#  server_set_id           = $auth1</span>
<span class="c">#  server_prompts          = &lt;| Username: | Password:</span>
<span class="c">#  server_condition        = Authentication is not yet configured</span>
<span class="c">#  server_advertise_condition = ${if def:tls_cipher }</span>
</pre></div>
</div>
<p>Параметр <strong>server_set_id</strong> заставляет Exim запомнить авторизованное имя пользователя в $authenticated_id, которая может быть использована позднее, в ACL или маршрутизаторах. Параметр <strong>server_prompts</strong> настраивает аутентификатор <strong>plaintext</strong> таким образом, что он реализует детали специфического аутентификационного механизма, т.е. - PLAIN или LOGIN. Установка <strong>server_advertise_condition</strong> контролирует, когда Exim посылает клиентам приглашение аутентифицироваться; в примере, это происходит лишь при запуске TLS или SSL, таким образом, для включения этих аутентификаторов вам также необходимо добавить поддержку TLS, как описано в разделе <a class="reference internal" href="#ch07-01"><em>7.1</em></a>.</p>
<p>Установка <strong>server_condition</strong> определяет как проверить корректность пользователя и пароля. В примерах, она просто выводит сообщение о ошибке. Чтобы аутентификаторы заработали, вы должны использовать выражение раскрытия стоки, похожее на примеры в главе <a class="reference internal" href="ch34.html#ch34-00"><em>34</em></a>.</p>
<p>Помните, что последовательность параметров для PLAIN и LOGIN различна; пользователь и пароль находятся в различных позициях. В главе <a class="reference internal" href="ch34.html#ch34-00"><em>34</em></a> описаны оба.</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>А вообще имеются ввиду адреса, типа <a class="reference external" href="mailto:user%domain1&#46;su&#37;&#52;&#48;domain2&#46;su">user%domain1<span>&#46;</span>su<span>&#64;</span>domain2<span>&#46;</span>su</a> - когда письмо приходит на сервер domain2.su, а тот уже пересылает его на domain1.su. Но лучше это не использовать - переводчик.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>(потому как через два дня их выкинут :)))) - кто-то.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Содержание</a></h3>
  <ul>
<li><a class="reference internal" href="#">Файл конфигурации по умолчанию</a><ul>
<li><a class="reference internal" href="#ch07-01">Главные конфигурационные настройки</a></li>
<li><a class="reference internal" href="#acl">Конфигурация ACL</a></li>
<li><a class="reference internal" href="#ch07-03">Конфигурация маршрутизатора</a></li>
<li><a class="reference internal" href="#ch07-04">Транспортная конфигурация</a></li>
<li><a class="reference internal" href="#ch07-05">Правила повторов по умолчанию</a></li>
<li><a class="reference internal" href="#ch07-06">Конфигурация перезаписи</a></li>
<li><a class="reference internal" href="#ch07-07">Конфигурация аутентификаторов</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ch06.html" title="предыдущая глава">Файл конфигурации Exim во время выполнения</a></li>
      <li>Next: <a href="ch08.html" title="следующая глава">Регулярные выражения</a></li>
  </ul></li>
</ul>
  <h3>На этой странице</h3>
  <ul class="this-page-menu">
    <li><a href="sources/ch07.txt"
           rel="nofollow">Показать исходный текст</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Быстрый поиск</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Искать" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Введите слова для поиска или имя модуля, класса или функции.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2011, Exim Maintainers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>