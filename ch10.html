
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Списки доменов, узлов, адресов и локальных частей [почтового] адреса &mdash; Specification of the Exim Mail Transfer Agent 4.70 documentation</title>
    
    <link rel="stylesheet" href="static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.70',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="static/translations.js"></script>
    <link rel="top" title="Specification of the Exim Mail Transfer Agent 4.70 documentation" href="index.html" />
    <link rel="next" title="Раскрываемые строки" href="ch11.html" />
    <link rel="prev" title="Поиски в файлах и базах данных" href="ch09.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch11.html" title="Раскрываемые строки"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch09.html" title="Поиски в файлах и базах данных"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Specification of the Exim Mail Transfer Agent 4.70 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ch10-00">
<span id="id1"></span><h1>Списки доменов, узлов, адресов и локальных частей [почтового] адреса<a class="headerlink" href="#ch10-00" title="Ссылка на этот заголовок">¶</a></h1>
<p>Многие конфигурационные параметры Exim содержат списки доменов, узлов, email адресов, или локальных частей [почтового] адреса. Например, параметр <strong>hold_domains</strong> содержит список доменов, для которых доставка на данный момент временно приостановлена. Эти списки также используются как данные в списках управления доступом (см. главу <a class="reference internal" href="ch40.html#ch40-00"><em>40</em></a>), и как параметры к условиям раскрытия, типа <strong>match_domain</strong>.</p>
<p>Каждый элемент в одном из этих списков - шаблон, проверяемый на соответствие домену, узлу, email адресу, или локальной части [почтового] адреса, соответственно. В секциях ниже описаны различные типы шаблонов для каждого случая, но сначала мы затронем некоторые общие средства, которые применяются для всех четырех типов списков.</p>
<div class="section" id="ch10-01">
<span id="id2"></span><h2>Раскрытие списков<a class="headerlink" href="#ch10-01" title="Ссылка на этот заголовок">¶</a></h2>
<p>Каждый список раскрывается как одиночная строка перед использованием. Результатом раскрытия должен быть список, возможно, содержащий пустые элементы, разделённый на отдельные элементы для совпадения. По-умолчанию, символ-разделитель - двоеточие, но в случае необходимости он может быть изменён. Смотрите разделы <a class="reference internal" href="ch06.html#ch06-19"><em>6.19</em></a> и <a class="reference internal" href="ch06.html#ch06-21"><em>6.21</em></a> для деталей о синтаксисе списка; по второму линку обсуждается способ определения пустых элементов списка.</p>
<p>При неудачном раскрытии строки, Exim ведет себя так будто бы тестируемый элемент (домен, узел, адрес, или локальная часть [почтового] адреса) не в списке. Другие отказы раскрытия приводят к временным ошибкам.</p>
<p>Если элемент списка - регулярное выражение, знак обратного слеша, знак доллара и возможно другой спецсимвол в выражении, он должен быть защищен от неправильной интерпретации функцией раскрытия. Самый простой способ это сделать - использовать особенность раскрытия <tt class="docutils literal"><span class="pre">\N</span></tt>, чтобы обозначить что содержимое регулярного выражения не должно раскрываться. Например, в списке управления доступом вы можете указать:</p>
<div class="highlight-python"><pre>deny senders = \N^\d{8}\w@.*\.baddomain\.example$\N : \
${lookup{$domain}lsearch{/badsenders/bydomain}}</pre>
</div>
<p>Первый элемент - это регулярное выражение защищенное от раскрытия указанием <tt class="docutils literal"><span class="pre">\N</span></tt>, а второй использует раскрытие для получения списка нежелательных отправителей на основе списка нежелательных доменов.</p>
</div>
<div class="section" id="ch10-02">
<span id="id3"></span><h2>Отрицаемые элементы в списках<a class="headerlink" href="#ch10-02" title="Ссылка на этот заголовок">¶</a></h2>
<p>Элемент в списке может положительным или отрицательным. Отрицательные элементы идентифицируются предшествующим знаком восклицания, за которым может следовать пробел. Список определяет набор элементов (доменов, etc). Когда Exim обрабатывает один из этих списков, он пытается найти домен, узел, адрес или локальную часть [почтового] адреса в наборе, определенном списком. Это работает так:</p>
<p>Список сканируется слева направо. Если совпадает положительный элемент, проверяемый элемент включается в результирующее множество, если совпадает отрицательный - элемент исключается из результирующего множества. Если был достигнут конец списка и не было совпадений проверяемых объектов с шаблоном, то проверяемый элемент включается в множество, если последний элемент был отрицательным; если последний элемент был положительным, элемент исключается из результирующего множества:</p>
<div class="highlight-python"><pre>domainlist relay_domains = !a.b.c : *.b.c</pre>
</div>
<p>соответствует любому домену оканчивающемуся <tt class="docutils literal"><span class="pre">.b.c</span></tt> за исключением <tt class="docutils literal"><span class="pre">a.b.c</span></tt>. Домены не соответствующие ни <tt class="docutils literal"><span class="pre">a.b.c</span></tt> ни <tt class="docutils literal"><span class="pre">*.b.c</span></tt> не соответствуют, т.к. последний элемент списка позитивный. Тем не менее если бы было установлено</p>
<div class="highlight-python"><pre>domainlist relay_domains = !a.b.c</pre>
</div>
<p>тогда бы совпадали все домены кроме <tt class="docutils literal"><span class="pre">a.b.c</span></tt> т.к. последний элемент списка позитивный. Другими словами список, оканчивающийся отрицательным элементом интерпретируется так, как если бы он имел дополнительный элемент <tt class="docutils literal"><span class="pre">:*</span></tt> в конце.</p>
<p>Другой способ подумать о положительных и отрицательных элементах списков - это читать соединитель как “или” после положительных элементов, и как “и” - после отрицательных.</p>
</div>
<div class="section" id="ch10-03">
<span id="id4"></span><h2>Имена файлов в списках<a class="headerlink" href="#ch10-03" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если элемент списка доменов, хостов, адресов или локальных частей [почтового] адреса является абсолютным именем файла (начинается со знака слеша), каждая строка файла читается и обрабатывается так, как если бы это был независимый элемент списка, за исключением того, что не допускаются дальнейшие имена файлов; раскрытие данных из файла не происходит. Пустые строки файла игнорируются, файл также может содержать строки комментариев:</p>
<ul>
<li><p class="first">Для списков доменов и хостов если где-либо в строке файла встречается символ <tt class="docutils literal"><span class="pre">#</span></tt> он и все следующие символы игнорируются.</p>
</li>
<li><p class="first">Т.к. локальные части [почтового] адреса могут содержать знаки <tt class="docutils literal"><span class="pre">#</span></tt>, комментарий в списке адресов или локальных частей [почтового] адреса распознается только если <tt class="docutils literal"><span class="pre">#</span></tt> стоит после пробела либо в начале строки. Например:</p>
<div class="highlight-python"><pre>not#comment@x.y.z   # but this is a comment</pre>
</div>
</li>
</ul>
<p>Указывая имя файла в списке имеет такой эффект как вставка каждой строки файла в качестве элемента в список (пустые строки и комментарии исключаются). Тем не менее есть одно важное отличие: файл читается при каждой обработке списка, таким образом если его содержимое периодически меняется, изменяется и поведение Exim.</p>
<p>Если имени файла предшествует восклицательный знак значение любых совпадений с файлом инвертируется. Например, если</p>
<div class="highlight-python"><pre>hold_domains = !/etc/nohold-domains</pre>
</div>
<p>и файл содержит строки</p>
<div class="highlight-python"><pre>!a.b.c
*.b.c</pre>
</div>
<p>тогда <tt class="docutils literal"><span class="pre">a.b.c</span></tt> будет находится в списке доменов определенных в <strong>hold_domains</strong>, в то время как любой домен совпадающий с <tt class="docutils literal"><span class="pre">*.b.c</span></tt> - нет.</p>
</div>
<div class="section" id="lsearch">
<span id="ch10-04"></span><h2>Файл “lsearch” не нелинейный список<a class="headerlink" href="#lsearch" title="Ссылка на этот заголовок">¶</a></h2>
<p>Как будет описано в следующих секциях, поиски могут использоваться в списках, для обеспечения индексированных методов проверки списка членов. Было некоторое количество путаницы о способе работы <strong>lsearch</strong> со списками. Поскольку файл <strong>lsearch</strong> содержит простой текст и сканируется последовательно, то некоторые думают, что в него можно ставить групповые символы и другие переменные шаблоны. Это не так. Ключи в файле <strong>lsearch</strong>, всегда фиксированные строки, также как и для любого другого одноключевого поиска.</p>
<p>Если вы хотите использовать файл содержащий подстановочные шаблоны являющиеся частью списка, просто дайте самостоятельное имя файла, без типа поиска, как описано в предыдущей секции. Также, вы можете использовать <strong>wildlsearch</strong> или <strong>nwildlsearch</strong>, но преимуществ не получите.</p>
</div>
<div class="section" id="ch10-05">
<span id="id5"></span><h2>Именованные списки<a class="headerlink" href="#ch10-05" title="Ссылка на этот заголовок">¶</a></h2>
<p>Списку доменов, хостов, e-mail адресов или локальных частей адреса можно дать название, которое используется для обращения к списку в другом месте конфигурации. Это особенно удобно, если один и тот же список нужно использовать в нескольких различных местах. Это также позволяет давать спискам осмысленные обозначения, что может улучшить понимание файла конфигурации. Например, часто задают список доменов называемый <em>local_domains</em> для всех локальных доменов, обрабатываемых на этой машине, с использованием конфигурационной строки типа:</p>
<div class="highlight-python"><pre>domainlist local_domains = localhost:my.dom.example</pre>
</div>
<p>На именованный список можно ссылаться, давая его имя с предшествующим ему знаком <tt class="docutils literal"><span class="pre">+</span></tt> например, маршрутизатор предназначенный для обработки локальных доменов, был бы сконфигурен со строкой:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">domains</span> <span class="o">=</span> <span class="o">+</span><span class="n">local_domains</span>
</pre></div>
</div>
<p>Первый маршрутизатор в конфигурации, обычно, тот, который обрабатывает все домены, кроме локальных, используя конфигурацию с инвертированным элементом, как этот:</p>
<div class="highlight-python"><pre>dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = remote_smtp
  no_more</pre>
</div>
<p>Четыре вида именованных списков создаются конфигурационными строками, начинающимися со слов <strong>domainlist</strong>, <strong>hostlist</strong>, <strong>addresslist</strong> или <strong>localpartlist</strong> соответственно. Задаваемые вами списки помещайте после них. Например:</p>
<div class="highlight-python"><pre>hostlist    relay_hosts = 192.168.23.0/24 : my.friend.example
addresslist bad_senders = cdb;/etc/badsenders</pre>
</div>
<p>Именованный список может обращаться к другим именованным спискам:</p>
<div class="highlight-python"><pre>domainlist  dom1 = first.example : second.example
domainlist  dom2 = +dom1 : third.example
domainlist  dom3 = fourth.example : +dom2 : fifth.example</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p>Если последний элемент, в списке на который ссылаются, отрицательный (инвертированный), то может быть вовсе не тот эффект, который вы ожидали, поскольку отрицание не передаётся на следующий (более высокий) уровень. Например, рассмотрите:</p>
<div class="highlight-python"><pre>domainlist  dom1 = !a.b
domainlist  dom2 = +dom1 : *.b</pre>
</div>
<p>Второй список задан: “или в списке <strong>dom1</strong> или <tt class="docutils literal"><span class="pre">*.b</span></tt>”. Первый список задаёт только <tt class="docutils literal"><span class="pre">не</span> <span class="pre">a.b</span></tt>, таким образом домен <tt class="docutils literal"><span class="pre">x.y</span></tt> совпадает с ним. Это означает, что он также соответствует и второму списку. Эффект не такой же как:</p>
<div class="highlight-python"><pre>domainlist  dom2 = !a.b : *.b</pre>
</div>
<p class="last">что не соответствует <tt class="docutils literal"><span class="pre">x.y</span></tt>. Вообще, по возможности, лучше избегать отрицания в списках.</p>
</div>
<p>Именованные списки могут быть выгодны в плане производительности. Когда Exim маршрутизирует адрес или проверяет входящее сообщение, он кэширует результаты теста именованного списка. Так, если у вас есть такой пункт:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">domains</span> <span class="o">=</span> <span class="o">+</span><span class="n">local_domains</span>
</pre></div>
</div>
<p>в нескольких маршрутизаторах или нескольких ACL, то фактически, тестируется только в первом. Однако, кэширование работает, лишь если в пределах списка, или любых подсписков, нет раскрытий. Другими словами, кэширование происходит только для списков, про которые известно, что они будут одинаковыми при каждом обращении.</p>
<p>По умолчанию, могут быть до 16 именованных списков каждого типа. Этот предел может быть увеличен изменением компиляционной переменной. Использование списков хостов и доменов рекомендуется для концепции типа локальных доменов, релейных доменов и релейных хостов. В конфигурации по умолчанию так и установлено.</p>
</div>
<div class="section" id="ch10-06">
<span id="id6"></span><h2>Сравнение именованных списков с макросами<a class="headerlink" href="#ch10-06" title="Ссылка на этот заголовок">¶</a></h2>
<p>На первый взгляд, как могло бы показаться, в файле конфигурации, именованные списки неотличимы от макросов. Однако, макрос - лишь текстовая замена. Если вы напишете</p>
<div class="highlight-python"><pre>ALIST = host1 : host2
auth_advertise_hosts = !ALIST</pre>
</div>
<p>то оно, вероятно, не будет делать то, что вы хотите, потому что это, то же самое что и</p>
<div class="highlight-python"><pre>auth_advertise_hosts = !host1 : host2</pre>
</div>
<p>Заметьте, что второе имя хоста не инвертировано. Однако, если вы используете список хостов, и напишете</p>
<div class="highlight-python"><pre>hostlist alist = host1 : host2
auth_advertise_hosts = ! +alist</pre>
</div>
<p>то отрицание применяется ко всему списку, и в итоге это эквивалентно</p>
<div class="highlight-python"><pre>auth_advertise_hosts = !host1 : !host2</pre>
</div>
</div>
<div class="section" id="ch10-07">
<span id="id7"></span><h2>Кэширование именованных списков<a class="headerlink" href="#ch10-07" title="Ссылка на этот заголовок">¶</a></h2>
<p>При обработке сообщения Exim кэширует результат проверки именованного списка, если есть уверенность, что список статический. Практически, это означает, что кэширование работает только если список не содержит символов <tt class="docutils literal"><span class="pre">$</span></tt>, что гарантирует, что список не будет изменяться при раскрытии. Однако, иногда, вы можете иметь раскрываемый список, про который вы знаете, что это в пределах одного сообщения это будет тот же самый список при каждой проверке. Например:</p>
<div class="highlight-python"><pre>domainlist special_domains = \
           ${lookup{$sender_host_address}cdb{/some/file}}</pre>
</div>
<p>Это обеспечивает список доменов, который зависит лишь от IP-адреса хоста отправителя. Если этот список доменов используется неоднократно (например в нескольких строках ACL, или в нескольких маршрутизаторах), по умолчанию, результат не кэшируется, поскольку Exim не знает, что каждую проверку это будет один и тот же список.</p>
<p>Добавив <tt class="docutils literal"><span class="pre">_cache</span></tt> к <strong>domainlist</strong> вы можете сказать Exim`y что результат можно кэшировать. Например:</p>
<div class="highlight-python"><pre>domainlist_cache special_domains = ${lookup{...</pre>
</div>
<p>Если вы сделаете это, то вы должны быть абсолютно уверенны, что кэшированный результат будет верен во всех случаях. Если вы сомневаетесь, не делайте этого.</p>
</div>
<div class="section" id="ch10-08">
<span id="id8"></span><h2>Списки доменов<a class="headerlink" href="#ch10-08" title="Ссылка на этот заголовок">¶</a></h2>
<p>Списки доменов содержат шаблоны, не совпадающие с почтовыми доменами. Следующие типы элементов могут использоваться в списках доменов:</p>
<ul>
<li><p class="first">Если шаблон состоит из единственного символа <tt class="docutils literal"><span class="pre">&#64;</span></tt>, он совпадает с именем локального хоста, установленному параметру <strong>primary_hostname</strong> (или по-умолчанию). Это позволяет использовать один и тот же конфигурационный файл на нескольких разных хостах, различающихся лишь названием.</p>
</li>
<li><p class="first">Если шаблон содержит строку <tt class="docutils literal"><span class="pre">&#64;[]</span></tt> - он совпадает с IP-адресом заключённым в квадратные скобки (как в почтовом адресе, который содержит доменный литерал), но лишь в случае, если этот IP адрес распознан как локальный для целей почтовой маршрутизации. Параметры <strong>local_interfaces</strong> и <strong>extra_local_interfaces</strong> могут использоваться для контроля, какой именно из нескольких IP адресов хоста обрабатывается как локальный. В сегодняшнем интернете, доменные литералы практически не используются.</p>
</li>
<li><p class="first">Если шаблон состоит из строки <tt class="docutils literal"><span class="pre">&#64;mx_any</span></tt>, то это совпадает с любым доменом, чья MX-запись указывает на локальных хост, или на любой хост который перечислен в <strong>hosts_treat_as_local</strong>. Элементы <tt class="docutils literal"><span class="pre">&#64;mx_primary</span></tt> и <tt class="docutils literal"><span class="pre">&#64;mx_secondary</span></tt> являются подобными, за тем исключением, что первый соответствует лишь в случае если первичных MX указывает на локальную машину, а второй, лишь когда нет первичной записи MX указывающей на локалхост, но на него указывает вторичная MX-запись. “Первичная” MX запись, означает, что у неё самое маленькое значение, и их может быть более одной.
Поиск MX, соответствующей образцу, выполняется с параметрами резольвера для отключения раскрытия имён. Таким образом, например, однокомпонентный домен не будет раскрыт резольвером, добавлением домена по умолчанию. Смотрите параметры <strong>qualify_single</strong> и <strong>search_parents</strong> маршрутизатора <strong>dnslookup</strong> для подробной информации о раскрытии домена.
Иногда можно игнорировать определённые IP-адреса, при использовании одного из этих шаблонов. Вы можете задать их сразу за образцом, при помощи <tt class="docutils literal"><span class="pre">/ignore=&lt;ip</span> <span class="pre">list&gt;</span></tt>, где <tt class="docutils literal"><span class="pre">&lt;ip</span> <span class="pre">list&gt;</span></tt> - список IP-адресов. При обработке шаблона, эти адреса игнорируются (сравните с параметром <strong>ignore_target_hosts</strong> в маршрутизаторе). Например:</p>
<div class="highlight-python"><pre>domains = @mx_any/ignore=127.0.0.1</pre>
</div>
<p>Этот пример совпадает с любым доменом имеющим MX-запись указывающую на один из IP-адресов локальной машины, за исключением 127.0.0.1.</p>
<p>Список IP-адресов обрабатывается тем же самым кодом, который обрабатывает список хостов, таким образом тут можно писать сети в виде CIDR, и также тут могут находится негативные элементы.</p>
<p>Поскольку список IP-адресов является подсписком внутри списка доменов, вы должны быть осторожны, при использовании разделителей если тут больше одного адреса. Как и в любом другом списке, разделитель по умолчанию может быть заменён. Таким образом, можно сделать так:</p>
<div class="highlight-python"><pre>domains = @mx_any/ignore=&lt;;127.0.0.1;0.0.0.0 : \
          an.other.domain : ...</pre>
</div>
<p>чтобы подсписок использовал в качестве разделителя точку с запятой (“;”). При использовании адресов IPv6, полезно поменять разделитель и для главного списка:</p>
<div class="highlight-python"><pre>domains = &lt;? @mx_any/ignore=&lt;;127.0.0.1;::1 ? \
          an.other.domain ? ...</pre>
</div>
</li>
<li><p class="first">Если шаблон начинается со звёздочки (“*”), оставшиеся символы шаблона сравниваются с последними символами домена. Использование звёздочки в списках доменов отличается от её использования в частично соответствующих поисках. В списке доменов, символ следующий за звёздочкой не должен быть точкой, тогда как частичное соответствие работает лишь в разделённых точкой компонентах. Например, элемент списка доменов типа <tt class="docutils literal"><span class="pre">*key.ex</span></tt> совпадает с <tt class="docutils literal"><span class="pre">donkey.ex</span></tt> также как и с <tt class="docutils literal"><span class="pre">cipher.key.ex</span></tt></p>
</li>
<li><p class="first">Если шаблон начинается с символа крышки (“^”), то он обрабатывается как регулярное выражение, и совпадает с доменом с использованием соответствующей функции регулярного выражения. Крышка обрабатывается как часть регулярного выражения. Почтовый домен регистронезависим, таким образом, это регулярное выражение по умолчанию регистронезаисимо, но, вы можете сделать его регистрозависимым, начав его с <tt class="docutils literal"><span class="pre">(?-i)</span></tt>. Справочная информация, описывающая синтаксис регулярных выражений, дается в главе <a class="reference internal" href="ch08.html#ch08-00"><em>8</em></a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Поскольку список доменов раскрывается до обработки, необходимо предварить обратным слешем символы обратного слэша и доллара “$”, или использовать специальную последовательность <tt class="docutils literal"><span class="pre">\N</span></tt> (смотрите главу <a class="reference internal" href="ch11.html#ch11-00"><em>11</em></a>) для определения того, что не надо раскрывать (если вы действительно не хотите строить регулярное выражение при помощи раскрытия, разумеется).</p>
</div>
</li>
<li><p class="first">Если шаблон начинается с имени одноключевого поиска, сопровождающегося точкой с запятой (например, “dbm;” или “lsearch;”), то остаток шаблона должен быть именем файла в подходящем для поиска формате. Например, для “cdb;” это должен быть абсолютный путь:</p>
<div class="highlight-python"><pre>domains = cdb;/etc/mail/local_domains.cdb</pre>
</div>
<p>Соответствующий тип поиска производится по файлу, с использованием доменного имени как ключа. В большинстве случаев, данные которые ищутся не нужны, Exim`а интересует лишь есть или нет ключ в файле. Однако, при использовании поиска для параметров <strong>domains</strong> в маршрутизаторе или <strong>domains</strong> условии ACL, данные сохраняются в переменной <tt class="docutils literal"><span class="pre">$domain_data</span></tt> и могут быть использованы в других параметрах маршрутизатора или в утверждениях, в той же самой ACL.</p>
</li>
<li><p class="first">Любое имя типа одноключевого поиска может претворяться частью <tt class="docutils literal"><span class="pre">&lt;n&gt;-</span></tt>, где <tt class="docutils literal"><span class="pre">&lt;n&gt;</span></tt> необязательно, например:</p>
<div class="highlight-python"><pre>domains = partial-dbm;/partial/domains</pre>
</div>
<p>Это вызывает частично-соответствующую логику; описание как это работает, дано в разделе <a class="reference internal" href="ch09.html#ch09-07"><em>9.7</em></a>.</p>
</li>
<li><p class="first">Любой из одноключевых поисков может сопровождаться звёздочкой. Это вызывает поиск значения по умолчанию для ключа содержащего единственную звёздочку, если первоначальный поиск неудачен. Это бесполезная особенность при использовании списка доменов для выбора специфического домена (поскольку совпадает любой домен), но это может иметь значение если результат поиска используется через переменную раскрытия <tt class="docutils literal"><span class="pre">$domain_data</span></tt>.</p>
</li>
<li><p class="first">Если шаблон начинается с имени поиска в стиле запросов, сопровождаемого точкой с запятой (например,  “nisplus;” или “ldap;”), оставшаяся часть шаблона должна быть соответствующим запросом для поиска, как описано в главе <a class="reference internal" href="ch09.html#ch09-00"><em>9</em></a>. Например:</p>
<div class="highlight-python"><pre>hold_domains = mysql;select domain from holdlist \
  where domain = '$domain';</pre>
</div>
<p>В большинстве случаев, данные поиска не используются (так, для SQL-запроса, к примеру, не имеет значения выбираемое поле). Exim интересуется лишь тем, успешен запрос или нет. Однако, при использовании поиска в параметрах <strong>domains</strong> в маршрутизаторе, данные сохраняются в переменной <tt class="docutils literal"><span class="pre">$domain_data</span></tt> и могут быть использованы в других параметрах.</p>
</li>
<li><p class="first">Если ни один из вышеупомянутых случаев не применяется, производится регистронезависимое текстовое сравнение между шаблонами и доменом.</p>
</li>
</ul>
<p>Вот пример, использующий несколько различных видов шаблонов:</p>
<div class="highlight-python"><pre>domainlist funny_domains = \
  @ : \
  lib.unseen.edu : \
  *.foundation.fict.example : \
  \N^[1-2]\d{3}\.fict\.example$\N : \
  partial-dbm;/opt/data/penguin/book : \
  nis;domains.byname : \
  nisplus;[name=$domain,status=local],domains.org_dir</pre>
</div>
<p>Тут очевидна обработка в различных режимах соответствия. Использование звёздочки быстрей чем регулярного выражения (имеется ввиду по трудоёмкости, т.е. процессорным ресурсам)и внесение в список нескольких имён, очевидно тоже. Использование поиска по БД или файлу - дорого (опять-таки - по процессорному времени), но это может оказаться единственным вариантом, если используются сотни имён. Поскольку шаблоны проверяются по порядку, имеет смысл поместить самые вероятные (совпадающие чаще всего) выше.</p>
</div>
<div class="section" id="ch10-09">
<span id="id9"></span><h2>Списки хостов<a class="headerlink" href="#ch10-09" title="Ссылка на этот заголовок">¶</a></h2>
<p>Списки хостов используются для контроля, что можно делать удалённым хостам. Например, некоторым хостам можно разрешить релей через локальную машину, и некоторым может быть разрешено использовать команду SMTP ETRN. Хосты могут быть идентифицированы двумя различными путями, по имени или по IP-адресу. В списке хостов некоторые типы шаблонов совпадают с именем хоста, и некоторые совпадают с IP-адресом. Вы должны быть особенно осторожны при использовании одноключевых поисков, и гарантировать что используется правильный ключ.</p>
</div>
<div class="section" id="ch10-10">
<span id="id10"></span><h2>Специальные шаблоны списка хостов<a class="headerlink" href="#ch10-10" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если элемент списка хостов - пустая строка, то она совпадает только когда не используется удалённый хост. Так происходит при получении сообщения от локального процесса используя SMTP на стандартном вводе, т.е. когда не используется соединение TCP/IP.</p>
<p>Специальный шаблоном “*” в списке хостов совпадает с любым хостом, или ни с каким хостом (наверное, имеется ввиду то самое подключение без TCP/IP, от локальных процессов). Фактически, ни имя ни Ip-адрес не просматриваются.</p>
</div>
<div class="section" id="ip">
<span id="ch10-11"></span><h2>Шаблоны списка хостов, совпадающие с IP-адресом<a class="headerlink" href="#ip" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если хост IPv4 соединяется с хостом IPv6 и запрос принимается на сокет IPv6, входящий адрес на хосте IPv6 фигурирует как <tt class="docutils literal"><span class="pre">::ffff:&lt;v4address&gt;</span></tt>. Когда такой адрес проверяется в списке хостов, он сначала преобразуется в традиционный адрес IPv4. (Не все операционные системы принимают вызовы IPv4 на сокеты IPv6, поскольку были проблемы с безопасностью.)</p>
<p>Следующие типы шаблонов в списках хостов проверяют удалённый хост, просматривая его IP-адрес:</p>
<ul>
<li><p class="first">Если шаблон - просто имя домена (не регулярное выражение, не начинается с <tt class="docutils literal"><span class="pre">*</span></tt>, не является разновидностью поиска), Exim вызывает функцию операционной системы для нахождения ассоциации с IP-адресом (или адресами). По возможности, он использует функцию <tt class="docutils literal"><span class="pre">getipnodebyname()</span></tt>, если же она недоступна, то <tt class="docutils literal"><span class="pre">gethostbyname()</span></tt>. Обычно, она вызывает поиск в DNS. Результат сравнивается с IP-адресом хоста.</p>
<p>Если происходит временная проблема (типа таймаута DNS) при поиске имени хоста, происходит временная ошибка. Например, если список начинается с использования условия ACL, то ACL даёт “задерживающий” (“defer”) ответ, обычно приводящий к временной ошибке SMTP. Что происходит при невозможности найти адрес для имени хоста, описано ниже, в разделе <a class="reference internal" href="#ch10-14"><em>10.14</em></a>.</p>
</li>
<li><p class="first">Если шаблон - “&#64;”, он заменяется первичным именем хоста, и используется как имя домена, как описано.</p>
</li>
<li><p class="first">Если шаблон - IP-адрес, он сравнивается с IP-адресом хоста. Адреса IPv4 даются в нормальной нотации “пунктирной четвёрки”. Адреса IPv6 можно использовать в формате с двоеточием в качестве разделителя, но двоеточия должны быть удвоены, чтобы они не были приняты за разделитель, при использовании разделителя по умолчанию. Адреса IPv6 распознаются даже когда Exim собран без поддержки IPv6. Это означает, что если они фигурируют в списке хостов только для IPv4, Exim не станет из обрабатывать как имена хостов. Они - лишь адреса, которые никогда не совпадают с хостом клиента.</p>
</li>
<li><p class="first">Если шаблон - “&#64;[]”, он совпадает с IP-адресом любого интерфейса локального хоста. Например, если локалхост - хост IPv4 с одним адресом интерфейса 10.45.23.56, эти две ACL будут иметь одинаковый эффект:</p>
<div class="highlight-python"><pre>accept hosts = 127.0.0.1 : 10.45.23.56
accept hosts = @[]</pre>
</div>
</li>
<li><p class="first">Если шаблон - IP-адрес со слешем и маской сети (например 10.11.42.0/24), он совпадает с IP-адресом хоста при такой маске. Это позволяет включать целую сеть хостов одним пунктом. Маска используется в CIDR-нотации; это задаёт число битов адреса, которые должны совпадать, начиная с конца адреса.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p>Маска - это не число адресов, при этом это не самое большое число диапазона адресов. Это число битов в сетевой части адреса. Вышеупомянутый пример определяет 24-х битовую сетевую маску, таким образом она совпадает с 256 адресами в сети 10.11.42.0. Элемент типа:</p>
<div class="highlight-python"><pre>192.168.23.236/31</pre>
</div>
<p class="last">совпадает лишь с двумя адресами, 192.168.23.236 и 192.168.23.237. Маска со значением 32 для адреса IPv6 - тоже самое что её отсутствие; такому элементу соответствует единственный адрес.</p>
</div>
<p>Вот другой пример, показывающий сети IPv4 и IPv6:</p>
<div class="highlight-python"><pre>recipient_unqualified_hosts = 192.168.0.0/16: \
                              3ffe::ffff::836f::::/48</pre>
</div>
<p>Удвоение разделителей списка применяется лишь в случае когда эти элементы используется внутри строки списка хостов. Это не требуется при задании их внутри файла. Например:</p>
<div class="highlight-python"><pre>recipient_unqualified_hosts = /opt/exim/unqualnets</pre>
</div>
<p>может использовать файл содержащий</p>
<div class="highlight-python"><pre>172.16.0.0/12
3ffe:ffff:836f::/48</pre>
</div>
<p>и будет иметь точно такой же эффект как и предыдущий пример. При использовании адресов IPv6 внутри строки, обычно более удобно использовать изменение символа разделителя. Такой список содержит теже самые две сети:</p>
<div class="highlight-python"><pre>recipient_unqualified_hosts = &lt;; 172.16.0.0/12; \
                                 3ffe:ffff:836f::/48</pre>
</div>
<p>Разделитель изменён на точку запятой использованием “&lt;;” в начале списка.</p>
</li>
</ul>
</div>
<div class="section" id="ch10-12">
<span id="id11"></span><h2>Шаблоны списка хостов для одноключевого поиска по имени хоста<a class="headerlink" href="#ch10-12" title="Ссылка на этот заголовок">¶</a></h2>
<p>Когда хост идентифицируется по одноключевому поиску его полного IP-адреса, Шаблон принимает такой вид:</p>
<div class="highlight-python"><pre>net-&lt;single-key-search-type&gt;;&lt;search-data&gt;</pre>
</div>
<p>Например:</p>
<div class="highlight-python"><pre>hosts_lookup = net-cdb;/hosts-by-ip.db</pre>
</div>
<p>Текстовая форма Ip-адреса хоста используется как ключ поиска. Адреса IPv6 конвертируются к несокращённой форме, с использованием строчных букв, с точками в качестве разделителей, поскольку двоеточие - ограничитель ключа в файлах <strong>lsearch</strong>. [Двоеточия могут использоваться в внутри ключа в файлах <strong>lsearch</strong>, если пометить ключ в кавычки, но это было добавлено позже.] Данные возвращённые поиском не используются.</p>
<p>Одноключевые поиски также могут выполняться с использованием IP-адресов с маской, используя шаблон такой формы:</p>
<div class="highlight-python"><pre>net&lt;number&gt;-&lt;single-key-search-type&gt;;&lt;search-data&gt;</pre>
</div>
<p>Например:</p>
<div class="highlight-python"><pre>net24-dbm;/networks.db</pre>
</div>
<p>Ip-адрес хоста замаскирован используя <tt class="docutils literal"><span class="pre">&lt;number&gt;</span></tt> в качестве длинны маски. Текстовая строка создаётся из скрытого маской значения, сопровождаемого маской, и это иcпользуется как ключ поиска. Например, если у хоста IP-адрес 192.168.34.6, то ключ для вышеупомянутого примера - “192.168.34.0/24”.</p>
<p>Когда адреса IPv6 конвертируются в строку, обычно, вместо двоеточия используются точки, таким образом, ключи в файлах <strong>lsearch</strong> не должны не должны содержать двоеточий (которые используются для завершения ключей <strong>lsearch</strong>). Это было реализовано за некоторое время, до того как в файлах <strong>lsearch</strong> появилась возможность использовать кавычки. Тем не менее, последние реализации файлов <strong>lsearch</strong> требуют двоеточий в IPv6 ключах (обозначенных кавычками), для того чтобы отличичать их от ключей IPv4. По этой причине, когда тип поиска - <strong>iplsearch</strong>, адреса IPv6 конвертируются, используя двоеточия, а не точки. Во всех случаях, всегда используются полные адреса IPv6, а не аббревиатуры.</p>
<p>В идеале, неплохо было бы убрать все эти аномальные ситуации, путём изменения двоеточий во всех случаях, поскольку теперь квотирование (помещение в кавычки) доступно для <strong>lsearch</strong>. Однако, это было бы несовместимым изменением, сломавшим бы некоторые работающие конфигурации.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Специфические <tt class="docutils literal"><span class="pre">net32-</span></tt> (для адреса IPv4) или <tt class="docutils literal"><span class="pre">net128-</span></tt> (для адреса IPv6), не тоже самое что и специфическое <tt class="docutils literal"><span class="pre">net-</span></tt> без номера. В предыдущем случае ключевые строки включают значение маски, тогда как в последнем IP-адрес используется самостоятельно.</p>
</div>
</div>
<div class="section" id="ch10-13">
<span id="id12"></span><h2>Шаблоны списка хостов совпадающие по имени хоста<a class="headerlink" href="#ch10-13" title="Ссылка на этот заголовок">¶</a></h2>
<p>Существует несколько типов шаблонов, требующих, чтобы Exim знал имя удалённого хоста. Они являются подстановочными шаблонами или поиском по имени. (Если полное имя хоста даётся без какого-либо подстановочного знака, оно используется для поиска соответствующего IP-адреса, как описано выше, в разделе <a class="reference internal" href="#ch10-11"><em>Шаблоны списка хостов, совпадающие с IP-адресом</em></a>.)</p>
<p>Если при столкновении Exim`a с одним из этих шаблонов, удалённое имя хоста неизвестно, оно будет найдено по IP-адресу. Хотя многие сервера интернета являются вполне добросовестными, и имеют обратные DNS-записи, есть много хостов у которых её нет <a class="footnote-reference" href="#id26" id="id13">[1]</a>. Следовательно, имя не всегда может быть найдено, и это может привести к нежелательным эффектам. Позаботьтесь об этом при конфигурировании списков хостов с подстановочными шаблонами. Рассмотрите вариант, если имя не может быть найдено.</p>
<p>Из-за проблем с разрешением имён хостов по IP-адресам, соответствие имён хостов не такое же как совпадение IP-адресов.</p>
<p>По-умолчанию, для нахождения имени хоста, Exim делает обратный DNS-поиск; если в DNS имя не найдено, пробуются системные функции <tt class="docutils literal"><span class="pre">gethostbyaddr()</span></tt> или <tt class="docutils literal"><span class="pre">getipnodebyaddr()</span></tt> - какая доступна. Порядок, в котором производится поиск, может быть изменён установками параметров <strong>host_lookup_order</strong>. Для безопасности, как только Exim находит одно или несколько имён, он ищет адрес IP адреса для этих имён и сравнивает их с IP адресами с которых начал. Принимаются лишь те адреса, чьи IP адреса совпадют. Любые другие имена отбрасываются. Если имена отстутсвуют, Exim ведёт себя так, как будто имя хоста не может быть найдено. В большинстве случаев, бывает лишь одно имя и один IP адрес.</p>
<p>Есть несколько параметров управляющих поведением в случае, если имя хоста не найдено. Они описаны ниже, в разделе <a class="reference internal" href="#ch10-14"><em>10.14</em></a>.</p>
<p>В результате подстановки синонима, хосты могут иметь более одного имени. При обработке любого из следующих типов шаблонов, все имена хостов проверяются:</p>
<ul>
<li><p class="first">Если шаблон начинается с “*”, остаток элемента должен соответствовать концу имени хоста. Например, <tt class="docutils literal"><span class="pre">*.b.c</span></tt> совпадает со всеми хостами, имена которых заканчивается на <tt class="docutils literal"><span class="pre">.b.c</span></tt>. Эта специальная простая форма используется, поскольку она очень часто необходима. Другие виды подстановок требуют использования регулярных выражений.</p>
</li>
<li><p class="first">Если элемент начинается с “^”, то это берётся как регулярное выражение которое сравнивается с именем хоста. Имя хоста регистронезависимо, таким образом, это регулярное выражение, по уполчанию, регистронезависимо, но вы можете сделать его регистрозависимым, начав его с <tt class="docutils literal"><span class="pre">(?-i)</span></tt>. Ссылки на описание синтаксиса регулярных выражений даны в главе <cite>8 &lt;ch08_00&gt;</cite>. Например:</p>
<div class="highlight-python"><pre>^(a|b)\.c\.d$</pre>
</div>
<p>является регулярным выражением, совпадающим с двумя хостами <tt class="docutils literal"><span class="pre">a.c.d</span></tt> или <tt class="docutils literal"><span class="pre">b.c.d</span></tt>. Когда регулярное выражение используется в списке хостов, вы должны позаботится о том, чтобы обратный слэш (“”) и символ доллара (“$”) не были неверно восприняты как часть раскрытия строки. Самый простой способ избежать этого - использовать <tt class="docutils literal"><span class="pre">\N</span></tt> для того чтобы отметить нужную часть строки как не раскрываемую:</p>
<div class="highlight-python"><pre>sender_unqualified_hosts = \N^(a|b)\.c\.d$\N : ....</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Если вы хотите соответствия полному имени хоста, то вы должны включить символ “$” - закрывающий метасимвол в регулярном выражении, как в вышеупомянутом примере. Без этого, будет подходить всё, с совпадаюшим именем хоста.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="ch10-14">
<span id="id14"></span><h2>Поведение, когда IP-адрес не может быть найден<a class="headerlink" href="#ch10-14" title="Ссылка на этот заголовок">¶</a></h2>
<p>Когда обрабатывается список хостов, Exim`y может понадобиться найти IP-адрес по имени (смотрите раздел <a class="reference internal" href="#ch10-11"><em>10.11</em></a>), или имя хоста по IP-адресу (смотрите раздел <a class="reference internal" href="#ch10-13"><em>10.13</em></a>). В любом случае, при невозможности найти информацию поведение одинаковое.</p>
<p>..note:: Эта секция применяется к постоянным ошибкам поиска. Она не применяется к временным ошибкам DNS, обработка которых описана в следующей секции.</p>
<p>По-умолчанию, Exim ведёт себя так, будто хост не совпадает со списком. Это не всегда совпадает с тем, что вам нужно. Для изменения поведения Exim`a есть специальные элементы - <tt class="docutils literal"><span class="pre">+include_unknown</span></tt> или <tt class="docutils literal"><span class="pre">+ignore_unknown</span></tt> которые могут появляться в списке (на верхнем уровне, они не признаются в списках файлов).</p>
<ul>
<li><p class="first">Если любой элемент, который следует <tt class="docutils literal"><span class="pre">+include_unknown</span></tt> требует информации, которая не может быть найдена, Exim ведет себя так, будто хост соответствует списку. Например,</p>
<div class="highlight-python"><pre>host_reject_connection = +include_unknown:*.enemy.ex</pre>
</div>
<p>отклоняет подключения от любых хостов, чьи имена совпадают с <tt class="docutils literal"><span class="pre">*.enemy.ex</span></tt>, и от тех хостов, чьи имена не могут быть найдены.</p>
</li>
<li><p class="first">Если любой элемент, который следует <tt class="docutils literal"><span class="pre">+ignore_unknown</span></tt> требует информации, которая не может быть найдена, Exim игнорирует этот пункт и переходит к оставшейся части списка. Например:</p>
<div class="highlight-python"><pre>accept hosts = +ignore_unknown : friend.example : \
               192.168.4.5</pre>
</div>
<p>принимает <a class="footnote-reference" href="#id27" id="id15">[2]</a> от любого хоста, имя которого <em>friend.example</em>, и от 192.168.4.5, независимо найдено или нет его имя. Без <tt class="docutils literal"><span class="pre">+ignore_unknown</span></tt>, если имя для 192.168.4.5 не найдено, почта отклоняется.</p>
</li>
</ul>
<p>Оба элемента, <tt class="docutils literal"><span class="pre">+include_unknown</span></tt> и <tt class="docutils literal"><span class="pre">+ignore_unknown</span></tt> могут появляться в одном списке. Эффект от каждого длиться до следующего или до конца списка.</p>
</div>
<div class="section" id="dns">
<span id="ch10-15"></span><h2>Временные ошибки DNS при поиске информации о хосте<a class="headerlink" href="#dns" title="Ссылка на этот заголовок">¶</a></h2>
<p>Обычно, временные ошибки DNS приводят к задержке (за исключением, когда параметр <strong>dns_again_means_nonexist</strong> превращает их в постоянные ошибки). Однако, список хостов может включать <tt class="docutils literal"><span class="pre">+ignore_defer</span></tt> и <tt class="docutils literal"><span class="pre">+include_defer</span></tt>, аналогично <tt class="docutils literal"><span class="pre">+ignore_unknown</span></tt> и <tt class="docutils literal"><span class="pre">+include_unknown</span></tt>, как описано в предыдущей секции. Эти параметры должны использоваться с осторожностью, предположительно в некритичных списка хостов, типа &#8220;белых списков&#8221;.</p>
</div>
<div class="section" id="ch10-16">
<span id="id16"></span><h2>Список шаблонов хостов для одноключевого поиска по имени хоста<a class="headerlink" href="#ch10-16" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если шаблон имеет форму</p>
<div class="highlight-python"><pre>&lt;single-key-search-type&gt;;&lt;search-data&gt;</pre>
</div>
<p>например</p>
<div class="highlight-python"><pre>dbm;/host/accept/list</pre>
</div>
<p>то выполняется одноключевой поиск, с использованием имени хоста в качестве ключа. Если поиск успешен, хост совпадает с элементом. Данные, возвращённые поиском, не используются.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">С этим видом шаблона вы должны иметь имена хостов как ключи в файле, а не IP-адреса. Если вам нужно сделать поиск основанный на Ip-адресах, то необходимо предварить тип поиска префиксом <tt class="docutils literal"><span class="pre">net-</span></tt> (смотрите раздел <a class="reference internal" href="#ch10-12"><em>10.12</em></a>). Однако, ничто не препятствует вам использовать два элемента в одном списке, один для поиска адреса, другой для поиска имени, с использованием обоими одного и того же файла.</p>
</div>
</div>
<div class="section" id="ch10-17">
<span id="id17"></span><h2>Список шаблонов хостов для поиска в стиле запросов<a class="headerlink" href="#ch10-17" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если шаблон имеет форму</p>
<div class="highlight-python"><pre>&lt;query-style-search-type&gt;;&lt;query&gt;</pre>
</div>
<p>то выполняются запросы, если они успешны, имя хоста совпадает с элементом. Данные, которые искались, не используются. Переменные <tt class="docutils literal"><span class="pre">$sender_host_address</span></tt> и <tt class="docutils literal"><span class="pre">$sender_host_name</span></tt> могут использоваться в запросе. Например:</p>
<div class="highlight-python"><pre>hosts_lookup = pgsql;\
  select ip from hostlist where ip='$sender_host_address'</pre>
</div>
<p>Значение переменной <tt class="docutils literal"><span class="pre">$sender_host_address</span></tt> для адреса IPv6 содержит двоеточия. Если вам необходимо, вы можете использовать элемент раскрытия <strong>sg</strong> для изменения этого. Если хотите использовать адреса с маской, то можете использовать оператор раскрытия <strong>mask</strong>.</p>
<p>Если запрос содержит ссылку на <tt class="docutils literal"><span class="pre">$sender_host_name</span></tt>, Exim автоматически ищет имя хоста, если это не было сделано раньше. (Смотрите раздел <a class="reference internal" href="#ch10-13"><em>10.13</em></a>, для подробностей о поиске имён хостов.)</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">До релиза 4.30, Exim всегда пытался найти имя хоста перед выполнением запроса, если типу поиска не предшествовало <tt class="docutils literal"><span class="pre">net-</span></tt>. Сейчас это не так. Для обратной совместимости, <tt class="docutils literal"><span class="pre">net-</span></tt> распознаётся при поиске в стиле запроса, но его присутствие или отсутствие не имеет никакого эффекта. (Разумеется, для одноключевых поисков, <tt class="docutils literal"><span class="pre">net-</span></tt> является важным. Смотрите раздел <a class="reference internal" href="#ch10-12"><em>10.12</em></a>).</p>
</div>
</div>
<div class="section" id="ch10-18">
<span id="id18"></span><h2>Смешивание подстановочных имён хостов и адресов в списках хостов<a class="headerlink" href="#ch10-18" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вы используете поиск имени или подстановочного имени хоста и IP-адреса в одном списке хостов, то вы должны размещать IP-адреса вначале. Например, в ACL вы могли бы иметь:</p>
<div class="highlight-python"><pre>accept hosts = 10.9.8.7 : *.friend.example</pre>
</div>
<p>Причина этого, в том, что Exim обрабатывает списки слева направо. Это позволяет проверить IP-адрес без запроса DNS, а при достижении элемента требующего разрешения имени в адрес происходит ошибка, если невозможно найти имя хоста для сравнения с шаблоном. Если вышеупомянутый список был бы в обратном порядке, утверждение <strong>accept</strong> было бы неудачно для хоста имя которого найти невозможно, даже если его IP адрес 10.9.8.7.</p>
<p>Если же вам действительно необходимо проверять первыми имена, и продолжить проверять IP-адреса, то вы можете переписать эту ACL таким образом:</p>
<div class="highlight-python"><pre>accept hosts = *.friend.example
accept hosts = 10.9.8.7</pre>
</div>
<p>Если первый <strong>accept</strong> неудачен, Exim продолжает проверять второе утверждение. Смотрите часть <a class="reference internal" href="ch40.html#ch40-00"><em>40</em></a>, для получения подробной информации о ACL.</p>
</div>
<div class="section" id="ch10-19">
<span id="id19"></span><h2>Списки адресов<a class="headerlink" href="#ch10-19" title="Ссылка на этот заголовок">¶</a></h2>
<p>Списки адресов содержат шаблоны совпадающие с почтовыми адресами. Есть лишь один специальный случай: адрес отправителя для рикошета всегда пустой. Вы можете проверить это, задав пустой элемент в списке адресов. Например, вы могли бы установить параметры маршрутизатора, для обработки рикошетов:</p>
<div class="highlight-python"><pre>senders = :</pre>
</div>
<p>Присутствие двоеточия означает пустой элемент. Если никаких данных нет <a class="footnote-reference" href="#id28" id="id20">[3]</a>, то список пуст и не соответствует вообще ничему. Пустой отправитель также может быть обнаружен регулярным выражением, соответствующим пустой строке, и поиском в стиле запросов, успешному в случае если переменная <tt class="docutils literal"><span class="pre">$sender_address</span></tt> пуста.</p>
<p>Непустые элементы списка адресов могут быть прямыми адресами электронной почты. Например:</p>
<div class="highlight-python"><pre>senders = jbc@askone.example : hs@anacreon.example</pre>
</div>
<p>Разрешается некоторое число групповых символов (т.е. шаблонов). Если шаблон содержит символ <tt class="docutils literal"><span class="pre">&#64;</span></tt>, но он не регулярное выражение, и не начинается с типа поиска заканчивающегося точкой с запятой (описано ниже), локальная часть адреса сравнивается с локальной частью шаблона, которая может начинаться со звёздочки. Если локальная часть совпадает, проверяется точно таким же образом для шаблона списка доменов. Например, домен может быть безразличным, обращаясь к именованному списку, или быть поиском:</p>
<div class="highlight-python"><pre>deny senders = *@*.spamming.site:\
               *@+hostile_domains:\
               bozo@partial-lsearch;/list/of/dodgy/sites:\
               *@dbm;/bad/domains.db</pre>
</div>
<p>Если локальная часть начинается с восклицательного знака, требуется чтобы это было определено как регулярное выражение, поскольку в противном случае восклицательный знак, как обычно в списках, будет воспринят как символ отрицания.</p>
<p>Если непустой шаблон не регулярное выражение, или поиск не содержит символ <tt class="docutils literal"><span class="pre">&#64;</span></tt>, это сравнивается с доменной частью адреса. Так понимаются только два формата - литеральный домен (домен в виде IP-адреса) или шаблон домена начинающийся со звёздочки. В обоих случаях, эффект точно такой же, как будто <tt class="docutils literal"><span class="pre">*&#64;</span></tt> предшествовала шаблону. Например:</p>
<div class="highlight-python"><pre>deny senders = enemy.domain : *.enemy.domain</pre>
</div>
<p>Следующие виды более сложных видов шаблонов списков адресов могут совпадать с любым адресом, включая пустой адрес, являющийся характеристикой <a class="footnote-reference" href="#id29" id="id21">[4]</a> отправителей рикошета:</p>
<ul>
<li><p class="first">Если (после раскрытия) шаблон начинается с “^”, регулярное выражение сравнивается с полным адресом, с шаблоном в качестве регулярного выражения. Вы должны позаботится о том, чтобы символы обратного слэша (“”) и доллара (“$”) не были неправильно восприняты как часть раскрытия строки.Самый простой способ избежать этого - использовать <tt class="docutils literal"><span class="pre">\N</span></tt> чтобы отметить эту часть строки как не раскрываемую. Например:</p>
<div class="highlight-python"><pre>deny senders = \N^.*this.*@example\.com$\N : \
               \N^\d{8}.+@spamhaus.example$\N : ...</pre>
</div>
<p>Последовательность <tt class="docutils literal"><span class="pre">\N</span></tt> удаляется при раскрытии, таким образом элементы действительно начинаются с крышки (“^”), к тому времени как они интерпретируются как шаблон адреса.</p>
</li>
<li><p class="first">Полные адреса могут искаться с использованием шаблона который с типа поиска завершаемого точкой с запятой, и сопровождаемого данными для поиска. Например:</p>
<div class="highlight-python"><pre>deny senders = cdb;/etc/blocked.senders : \
  mysql;select address from blocked where \
  address='${quote_mysql:$sender_address}'</pre>
</div>
<p>Могут использоваться и одноключевой стиль, и стиль запросов. Для одноключевого типа, Exim использует полный адрес как ключ. Однако, пустые ключи не поддерживаются одноключевым поиском, таким образом, сравнение с пустым адресом всегда будет неудачно. Это ограничение не применяется к поиску в стиле запросов.</p>
<p>Частичное соответствие для одноключевых поисков (раздел <a class="reference internal" href="ch09.html#ch09-07"><em>9.7</em></a>) не может использоваться, и игнорируется, если задано, с записью в журнал событий (paniclog). Однако, вы можете сконфигурить параметры поиска по умолчанию, как описано в разделе <a class="reference internal" href="ch09.html#ch09-06"><em>9.6</em></a>, но это полезно лишь для значений по-умолчанию типа <tt class="docutils literal"><span class="pre">*&#64;</span></tt>. Например, с этим поиском:</p>
<div class="highlight-python"><pre>accept senders = lsearch*@;/some/file</pre>
</div>
<p>файл может содержать строки типа таких:</p>
<div class="highlight-python"><pre>user1@domain1.example
*@domain2.example</pre>
</div>
<p>и для адреса отправителя <em>nimrod&#64;jaeger.example</em> последовательность пробуемых ключей будет:</p>
<div class="highlight-python"><pre>nimrod@jaeger.example
*@jaeger.example
*</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Не включайте строку “*” в ключевой файл, поскольку это означало бы что соответствие любому адресу, делая эту проверку бесполезной.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p>Не путайте эти два вида элементов:</p>
<div class="highlight-python"><pre>deny recipients = dbm*@;/some/file
deny recipients = *@dbm;/some/file</pre>
</div>
<p class="last">Первый, по умолчанию, производит полный поиск адреса, как описано, поскольку он начинается с типа поиска. Второй сравнивается с локальной и доменной частью независимо, как описано ниже.</p>
</div>
</li>
</ul>
<p>Следующие виды шаблонов списков адресов могут совпадать лишь с непустыми адресами. Если адрес пуст, сравнение с любым из этих типов шаблонов неудачно.</p>
<ul>
<li><p class="first">Если шаблон начинается с <tt class="docutils literal"><span class="pre">&#64;&#64;</span></tt> сопровождаемых элементом одноключевого поиска (например <tt class="docutils literal"><span class="pre">&#64;&#64;lsearch;/some/file</span></tt>), проверяемый адрес разбивается на локальную и доменную части. Домен ищется в файле. Если он там не найден, в этом пункте нет соответствий. Если он найден, найденные в файле данные обрабатываются как список шаблонов локальных частей, разделённых двоеточиями, каждый из которых, по очереди, сравнивается с локальной частью.</p>
<p>Поиск может быть частичным, и/или одним относящимся к поиску с ключом по умолчанию “*” (смотрите раздел <a class="reference internal" href="ch09.html#ch09-06"><em>9.6</em></a>). Искомая локальная часть шаблона, может быть регулярным выражением, или начинаться с “*”, или даже к будущему поиску. Также, они могут быть независимо инвертированы. Например:</p>
<div class="highlight-python"><pre>deny senders = @@dbm;/etc/reject-by-domain</pre>
</div>
<p>данные из DBM файла, могли бы содержать строки:</p>
<div class="highlight-python"><pre>baddomain.com:  !postmaster : *</pre>
</div>
<p>для отклонения всех отправителей, кроме “postmaster” из этого домена.</p>
<p>Если требуется, чтобы локальная часть, начиналась с восклицательного знака, это должно быть определено с использованием регулярного выражения. В файлах <strong>lsearch</strong>, отдельные записи могут быть разбиты на несколько строк, для выравнивания, но разделяющие двоеточия всё ещё могут включаться в перевод строки. Пустое место вокруг двоеточий игнорируется. Например:</p>
<div class="highlight-python"><pre>aol.com:  spammer1 : spammer2 : ^[0-9]+$ :
spammer3 : spammer4</pre>
</div>
<p>Как и во всех списках Exim`a, разделённых двоеточиями, двоеточие может быть включено в элемент, путём его (двоеточия) удвоения.</p>
<p>Если последний элемент списка начинается с правой угловой скобки (“&gt;”), остаток элемента берётся как новый ключ поиска для получения списка продолжения локальных частей. Новый ключ может быть последовательностью символов. Таким образом можно иметь такие вхождения в файле:</p>
<div class="highlight-python"><pre>aol.com: spammer1 : spammer 2 : &gt;*
xyz.com: spammer3 : &gt;*
*:       ^\d{8}$</pre>
</div>
<p>в файле который ищется с <tt class="docutils literal"><span class="pre">&#64;&#64;dbm*</span></tt>, для задания совпадения с 8-цифровой локальной частью для всех доменов, в дополнение к специфическим локальным частям перечисленным для каждого домена. Конечно, использование этой особенности стоит другого поиска каждый раз когда цепочка сопровождается <a class="footnote-reference" href="#id30" id="id22">[5]</a>, но целью было уменьшить нагрузку.</p>
<p>При использовании этого средства, возможно создание петель, и для того чтобы их выявить, цепочки не могут содержать более пятидесяти элементов.</p>
</li>
<li><p class="first">Стиль <tt class="docutils literal"><span class="pre">&#64;&#64;&lt;lookup&gt;</span></tt> элемента может использоваться для поиска в стиле запросов, но в этом случае, средство цепочек недоступно. Поиск может вернуть только один список локальных частей.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p>есть важное различие между элементами списка адресов в этих двух примерах:</p>
<div class="highlight-python"><pre>senders = +my_list
senders = *@+my_list</pre>
</div>
<p class="last">В первом, <tt class="docutils literal"><span class="pre">my_list</span></tt> является именованным списком адресов, тогда как во втором примере - именованный список доменов.</p>
</div>
</li>
</ul>
</div>
<div class="section" id="ch10-20">
<span id="id23"></span><h2>Регистр букв в списках адресов<a class="headerlink" href="#ch10-20" title="Ссылка на этот заголовок">¶</a></h2>
<p>Домены в e-mail адресах всегда обрабатываются регистронезависимо, но для локальных частей, на некоторых системах, это может быть существенно (смотрите <strong>caseful_local_part</strong> для разъяснения того, как Exim работает с этими адресами при маршрутизации). Однако, <span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2505.html"><strong>RFC 2505</strong></a> (“Anti-Spam Recommendations for SMTP MTAs” - антиспамовые рекомендации для SMTP MTA) предлагает чтобы соответствие адресов спискам заблокированных было сделано в регистронезависимой маненре. Так как большинство списков адресов в Exim`e используется для этого вида управления, Exim пытается сделать это <a class="footnote-reference" href="#id31" id="id24">[6]</a> по-умолчанию.</p>
<p>Доменная часть адреса всегда переводится в нижний регистр до сравнения её со списком адресов. Локальная часть, по умолчанию, переводится в нижний регистр, и любые производимые сравнения строки делаются регистронезависимо. Это значит, что данные могут быть непосредственно в списках адресов, в файлах включаемых простые имена файлов, и в любых файлах в которых производится поиск с использованием механизма <tt class="docutils literal"><span class="pre">&#64;&#64;</span></tt>, могут быть в любом регистре. Однако, ключи в файлах, поиск в которых производится по типу отличному от <strong>lsearch</strong> (который выполняется регистронезависимо), должны быть в строчных буквах, поскольку в них поиск регистрозависим.</p>
<p>Для разрешения регистрозависимого совпадения в списках адресов, если элемент списка адресов является строкой <tt class="docutils literal"><span class="pre">+caseful</span></tt>, оригинальный регистр локальной части восстанавливается для любого проводимого сравнения, и сравнения строк становятся регистрозависимы. Это не затрагивает домен, остающийся в нижнем регистре. Однако, хотя независимые сравнения доменов остаются регистронезависимы, регулярные выражения производящие сравнение со всем адресом, становятся  регистрозависимыми после того, как был обнаружен пункт <tt class="docutils literal"><span class="pre">+caseful</span></tt>.</p>
</div>
<div class="section" id="ch10-21">
<span id="id25"></span><h2>Списки локальных частей<a class="headerlink" href="#ch10-21" title="Ссылка на этот заголовок">¶</a></h2>
<p>Чувствительность к регистру в списках локальных частей обрабатывается таким же образом для списков адресов, как только что описано. Элемент <tt class="docutils literal"><span class="pre">+caseful</span></tt> может использоваться, по необходимости. В установке параметра <strong>local_parts</strong> в маршрутизаторе с установленным в <tt class="docutils literal"><span class="pre">false</span></tt> пунктом <strong>caseful_local_part</strong> адрес в строчных буквах и изначально сравнивается регистронезависмо. В этом случае, <tt class="docutils literal"><span class="pre">+caseful</span></tt> восстановит регистрозависимое сравнение в списках локальных частей, но не в других местах маршрутизатора. Если в маршрутизаторе параметр <strong>caseful_local_part</strong> установлена в <tt class="docutils literal"><span class="pre">true</span></tt>, сравнение в параметре <strong>local_parts</strong> регистрозависимо с начала маршрутизатора.</p>
<p>Если список локальных частей расположен в файле (смотрите раздел <a class="reference internal" href="#ch10-03"><em>10.3</em></a>), комментарии обрабатываются также как и списки адресов - они распознаются лишь в случае, если символу “#” предшествует пустой символ, или символ начала новой строки. Иначе, списки локальных частей сравниваются точно также как и списки доменов, за исключением специальных элементов относящихся к локальному хосту (<tt class="docutils literal"><span class="pre">&#64;</span></tt>, <tt class="docutils literal"><span class="pre">&#64;[]</span></tt>, <tt class="docutils literal"><span class="pre">&#64;mx_any</span></tt>, <tt class="docutils literal"><span class="pre">&#64;mx_primary</span></tt> и <tt class="docutils literal"><span class="pre">&#64;mx_secondary</span></tt>) которые не распознаются. Обратитесь к разделу <a class="reference internal" href="#ch10-08"><em>10.8</em></a> для получения дополнительных деталей о других доступных типах элементов.</p>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[1]</a></td><td>прим. lissyara: иногда очень проблематично добиться от провайдера обратной записи, обусловлено это, по моему, тем что там работают люди понятия не имеющие как её прописать</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[2]</a></td><td>почту, видимо :))</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[3]</a></td><td>в смысле, не было бы даже двоеточия - прим. lissyara</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[4]</a></td><td>видимо, признаком - прим. lissyara</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[5]</a></td><td>видимо, символом “&gt;” - прим. lissyara</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id24">[6]</a></td><td>регистронезависимый поиск, видимо - прим. lissyara</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Содержание</a></h3>
  <ul>
<li><a class="reference internal" href="#">Списки доменов, узлов, адресов и локальных частей [почтового] адреса</a><ul>
<li><a class="reference internal" href="#ch10-01">Раскрытие списков</a></li>
<li><a class="reference internal" href="#ch10-02">Отрицаемые элементы в списках</a></li>
<li><a class="reference internal" href="#ch10-03">Имена файлов в списках</a></li>
<li><a class="reference internal" href="#lsearch">Файл “lsearch” не нелинейный список</a></li>
<li><a class="reference internal" href="#ch10-05">Именованные списки</a></li>
<li><a class="reference internal" href="#ch10-06">Сравнение именованных списков с макросами</a></li>
<li><a class="reference internal" href="#ch10-07">Кэширование именованных списков</a></li>
<li><a class="reference internal" href="#ch10-08">Списки доменов</a></li>
<li><a class="reference internal" href="#ch10-09">Списки хостов</a></li>
<li><a class="reference internal" href="#ch10-10">Специальные шаблоны списка хостов</a></li>
<li><a class="reference internal" href="#ip">Шаблоны списка хостов, совпадающие с IP-адресом</a></li>
<li><a class="reference internal" href="#ch10-12">Шаблоны списка хостов для одноключевого поиска по имени хоста</a></li>
<li><a class="reference internal" href="#ch10-13">Шаблоны списка хостов совпадающие по имени хоста</a></li>
<li><a class="reference internal" href="#ch10-14">Поведение, когда IP-адрес не может быть найден</a></li>
<li><a class="reference internal" href="#dns">Временные ошибки DNS при поиске информации о хосте</a></li>
<li><a class="reference internal" href="#ch10-16">Список шаблонов хостов для одноключевого поиска по имени хоста</a></li>
<li><a class="reference internal" href="#ch10-17">Список шаблонов хостов для поиска в стиле запросов</a></li>
<li><a class="reference internal" href="#ch10-18">Смешивание подстановочных имён хостов и адресов в списках хостов</a></li>
<li><a class="reference internal" href="#ch10-19">Списки адресов</a></li>
<li><a class="reference internal" href="#ch10-20">Регистр букв в списках адресов</a></li>
<li><a class="reference internal" href="#ch10-21">Списки локальных частей</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ch09.html" title="предыдущая глава">Поиски в файлах и базах данных</a></li>
      <li>Next: <a href="ch11.html" title="следующая глава">Раскрываемые строки</a></li>
  </ul></li>
</ul>
  <h3>На этой странице</h3>
  <ul class="this-page-menu">
    <li><a href="sources/ch10.txt"
           rel="nofollow">Показать исходный текст</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Быстрый поиск</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Искать" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Введите слова для поиска или имя модуля, класса или функции.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2011, Exim Maintainers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>