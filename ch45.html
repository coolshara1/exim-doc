
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Обработка SMTP &mdash; Specification of the Exim Mail Transfer Agent 4.70 documentation</title>
    
    <link rel="stylesheet" href="_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.70',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Specification of the Exim Mail Transfer Agent 4.70 documentation" href="index.html" />
    <link rel="next" title="Настройка рикошетов и предупреждающих сообщений" href="ch46.html" />
    <link rel="prev" title="Обработка сообщения" href="ch44.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="_static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch46.html" title="Настройка рикошетов и предупреждающих сообщений"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch44.html" title="Обработка сообщения"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Specification of the Exim Mail Transfer Agent 4.70 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="smtp">
<span id="ch45-00"></span><h1>Обработка SMTP<a class="headerlink" href="#smtp" title="Ссылка на этот заголовок">¶</a></h1>
<p>Exim поддерживает множество различных способов использования протокола SMTP, и его вариант LMTP, являющийся интерактивным протоколом для передачи сообщений в закрытое хранилище почты приложением. Эта глава содержит детали о обработке SMTP. Для входящей почты, доступно следующее:</p>
<ul class="simple">
<li>SMTP через TCP/IP (даемон Exim`a, или <em>inetd</em>)</li>
<li>SMTP через стандартный ввод и вывод (параметр <strong>-bs</strong>)</li>
<li>Пакетный SMTP на стандартном вводе (параметр <strong>-bS</strong>)</li>
</ul>
<p>Для доставки почты, доступно следующее:</p>
<ul class="simple">
<li>SMTP через TCP/IP (транспорт <strong>smtp</strong>)</li>
<li>LMTP через TCP/IP (транспорт <strong>smtp</strong> с параметром <strong>protocol</strong> установленным в <strong>lmtp</strong>)</li>
<li>LMTP через трубу к процессу, работающему на локальном хосте (транспорт <strong>lmtp</strong>)</li>
</ul>
<p>Пакетный SMTP в файл или трубу (транспорты <strong>appendfile</strong> и <strong>pipe</strong> с установленным параметром <strong>use_bsmtp</strong>)</p>
<p>“Пакетный SMTP” - имя для процесса, в котором пакеты сообщений сохраняются или читаются из файлов (или труб), в формате в котором команды SMTP используются для хранения информации конверта.</p>
<div class="section" id="smtp-lmtp-tcp-ip">
<span id="ch45-01"></span><h2>Исходящий SMTP и LMTP через TCP/IP<a class="headerlink" href="#smtp-lmtp-tcp-ip" title="Ссылка на этот заголовок">¶</a></h2>
<p>Исходящий SMTP и LMTP через TCP/IP, выполняется транспортом <strong>smtp</strong>. Параметр <strong>protocol</strong> - выбирает какой протокол будет использоваться, но, фактическая обработка, одна и та же в обоих случаях.</p>
<p>Если, в ответе на его команду EHLO, Exim`y сообщают, что поддерживается параметр SIZE, он добавляет SIZE=&lt;n&gt; к каждой последующей команде MAIL. Значение &lt;n&gt; - размер сообщения, плюс значение параметра <strong>size_addition</strong> (по умолчанию - 1024) для учёта дополнений к сообщению, типа транспортных заголовков, или производимых в транспортном фильтре изменений. Если <strong>size_addition</strong> - отрицательна, использование SIZE - подавляется.</p>
<p>Если удалённый сервер оповещает о поддержке PIPELINING, Exim использует конвейерное расширение для SMTP (<span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2197.html"><strong>RFC 2197</strong></a>), для уменьшения числа TCP/IP пакетов требуемых для транзакции.</p>
<p>Если удалённый сервер оповещает о поддержке команды STARTTLS, и Exim собран с поддержкой шифрования TLS, он пробует начать TLS сессию, если хост не совпадает с <strong>hosts_avoid_tls</strong>. Для дополнительных деталей, смотрите раздел <a class="reference internal" href="ch39.html#ch39-00"><em>39</em></a>.</p>
<p>Если удалённый сервер оповещает о поддержке команды AUTH, Exim сканирует конфигурацию аутентификаторов на любые подходящие клиенту установки, как описано в главе <a class="reference internal" href="ch33.html#ch33-00"><em>33</em></a>.</p>
<p>Предполагается, что ответы от удалённых хостов завершаются путём CR, сопровождаемого LF. Однако, известны хосты, которые не посылают символ CR, таким образом, для возможности взаимодействовать с такими хостами, Exim обрабатывает LF как самостоятельный признак конца строки.</p>
<p>Если сообщение содержит несколько различных адресов, все с теми же самыми характеристиками (например, тот же отправитель конверта), резольвящимися к тем же самым наборам хостов, в том же самом порядке, посылаются в одной SMTP транзакции, даже если они для различных доменов, не более чем позволяет установка параметра <strong>max_rcpts</strong> в транспорте <strong>smtp</strong>, в случае чего они разделяются на группы содержащие не более чем <strong>max_rcpts</strong> адресов в каждой. Если <strong>remote_max_parallel</strong> - больше одного, каждая группа может быть послана в параллельных сессиях. Порядок хостов с идентичными значениями MX - не существенен при проверке, могут ли адреса быть пакетными в этом способе.</p>
<p>Когда транспорт <strong>smtp</strong> переносит временную ошибку не связанную с сообщением, Exim обновляет специфическую для транспорта БД, которая содержит записи, индексированные по имени хоста, которые помнят, какие сообщения ждут каждого специфического хоста. Также он обновляет БД повторов, с новыми временами повторов.</p>
<p>Подсказки повторов Exim`a основаны на имени хоста, плюс IP-адрес, таким образом если, один адрес многоадресного хоста будет нерабочим, он будет пропущен в большинстве случаев. Смотрите следующую секцию, для дополнительных деталей о обработке ошибок.</p>
<p>Когда сообщение успешно доставлено через TCP/IP SMTP-соединение, Exim просматривает БД подсказок для транспорта, чтобы увидеть, есть ли любые сообщения в очереди, ожидающие связанного с ними хоста. Если он находит один, он создаёт новый процесс Exim`a, используя параметр <strong>-MC</strong> (которая может быть использована процессом запущенным как root или пользователь Exim`a) и передаёт ему сокет TCP/IP, чтобы он мог доставить другое сообщение используя тот же самый сокет. Новый процесс производит лишь те доставки, которые смаршрутизированы к подключенному хосту, и он может передать сокет третьему процессу, и так далее.</p>
<p>Параметр <strong>connection_max_messages</strong>, транспорта <strong>smtp</strong>, может быть использован для ограничения числа сообщений отсылаемых через одно TCP/IP соединение.</p>
<p>Второе и последующие сообщения, отсылаемые в существующем подключении, идентифицируются в главном логе по дополнительной звёздочке после закрывающей квадратной скобки IP-адреса.</p>
</div>
<div class="section" id="ch45-02">
<span id="id1"></span><h2>Ошибки в исходящем SMTP<a class="headerlink" href="#ch45-02" title="Ссылка на этот заголовок">¶</a></h2>
<p>Три различные вида ошибок распознаются для исходящего SMTP: ошибки хоста, ошибки сообщения, и ошибки получателя.</p>
<blockquote>
<div><dl class="docutils">
<dt><strong>Ошибки хоста</strong></dt>
<dd><p class="first">Ошибка хоста не ассоциирована со специфическим сообщением, или со специфическим получателем сообщения. Ошибки хоста:</p>
<ul class="simple">
<li>Соединение отклонено, или таймаут.</li>
<li>Любой ошибочный код в соединении.</li>
<li>Любой ошибочный код в EHLO или HELO.</li>
<li>Потеря подключения в любое время, кроме как после “.”.</li>
<li>Ошибки ввода-вывода (I/O) в любое время.</li>
<li>Таймауты в течение сессии, кроме как в ответ на MAIL, RCPT, или “.” в конце данных.</li>
</ul>
<p class="last">Для ошибки хоста, постоянного ошибочного ответа при соединении, или в ответе на EHLO, вызывает ошибку всех маршрутизирующихся к хосту адресов. Любые другие ошибки хоста вызывают задержку всех адресов, и создание данных повторов для хоста. Он не пробуется снова, для любого сообщения, пока не наступит его время повтора. Если текущий набор адресов не весь доставляется за этот запуск (к некоторому альтернативному хосту), сообщение добавляется к списку сообщений, ожидающих этот хост, таким образом, если они всё ещё не доставлены когда произойдут последующие успешные доставки к хосту, оно тоже будет отослано в том же SMTP соединении.</p>
</dd>
<dt><strong>Ошибки сообщения</strong></dt>
<dd><p class="first">Ошибка сообщения ассоциирована со специфическим сообщением при посылке к специфическому хосту, но не со специфическим получателем сообщения. Ошибки сообщений таковы:</p>
<ul class="simple">
<li>Любые коды ошибки на MAIL, DATA, или “.” в конце данных.</li>
<li>Таймаут после MAIL.</li>
<li>Таймаут или потеря соединения после “.”, завершающей данные. Таймаут после команды DATA обрабатывается как ошибка хоста, как потеря соединения в любое другое время.</li>
</ul>
<p>Для ошибки сообщения, постоянный ошибочный ответ (5xx) вызывает ошибку всех адресов, и возвращение отчёта о ошибке доставки отправителю. Временный ошибочный ответ (4xx), или один из таймаутов, вызывает задержку всех адресов. Для хоста не создаются данные повторов, но, вместо этого, создаются записи повторов для хоста плюс идентификатор сообщения. Сообщение не добавляется к списку ожидающих этого хоста. Это обеспечивает что неудачное сообщение не будет послано к этому хосту до истечения времни повтора. Однако, другие сообщения смаршрутизированные к хосту не затрагиваются, таким образом, если ошибку вызывает какое-то свойство сообщения, она не остановит доставку другой почты.</p>
<p class="last">Если удалённый хост указывает поддержку параметра SIZE в своём ответе на EHLO, Exim добавляет к команде MAIL SIZE=nnn, таким образом, огромное сообщение вызовет ошибку, поскольку ошибка придёт в ответ на MAIL.</p>
</dd>
<dt><strong>Ошибки получателя</strong></dt>
<dd><p class="first">Ошибка получателя ассоциирована со специфическим получателем сообщения. Ошибки получателя таковы:</p>
<ul class="simple">
<li>Любой ошибочный ответ на RCPT.</li>
<li>Таймаут после RCPT.</li>
</ul>
<p>Для ошибки получателя, постоянный ответ ошибки (5xx) вызывает ошибку адресов получателей, и возврат рикошета отправителю. Ответ временной ошибки (4xx) или таймаут, вызывают задержку ошибочного адреса, и создание данных повтора для маршрутизации. Это используется для задержки обработки адресов в последующих запусках очереди, пока не истечёт время повтора маршрутизации. Это применяется ко всем сообщениям, но, поскольку, управляются лишь в запуски очереди, будет сделана одна попытка доставки нового сообщения на неудачный адрес до начала работы задержки. Это гарантирует, что если ошибка реально относится к сообщению, а не с получателем (“message too big for this recipient” - возможный пример), другие сообщения имеют шанс быть доставленными. Если доставка на адрес действительно успешна, информация повтора очищается, таким образом, все придержанные сообщения снова пробуются, и часы повтора сбрасываются.</p>
<p class="last">Сообщение не добавляется к списку ожидающих этого хоста. Использование хоста для других сообщений - не затрагивается, и исключая случай таймаута, другие получатели обрабатываются независимо, и могут быть успешно доставлены в текущей SMTP-сессии. После таймаута, разумеется, невозможно продолжить сессию, следовательно, все адреса задерживаются. Однако, остальные, кроме неудачного, не претерпевают последующих задержек. Поэтому, если один получатель вызывает проблемы, остальные имеют шанс на прохождение, когда последующие попытки доставки случаются до времени повтора неудачного получателя.</p>
</dd>
</dl>
</div></blockquote>
<p>Во всех случаях, если есть другие хосты (или IP-адреса) доступные для текущего набора адресов (например, из нескольких MX-записей), они пробуются в этот запуск для любых недоставленых адресов, разумеется, подвергаясь собственным данным повторов. Другими словами, данные ошибок получателя не вступают в силу до следующей попытки доставки.</p>
<p>Некоторые хосты, как наблюдалось, давали ответ с временной ошибкой на каждую команду MAIL, в некоторые моменты времени (было замечено “insufficient space” (недостаточно места)). Было бы хорошо, если бы такие ситуации были распознаны, и данные для хоста задерживались, но это невозможно в текущем дизайне Exim`a. Что происходит фактически - что создаются данные для каждой (хоста, сообщения) комбинации.</p>
<p>Причина, что таймаут после MAIL и RCPT обрабатывается специальным образом - что иногда он может происходить как результат процедуры проверки удалённым хостом. Exim делает это предположение, и обрабатывает их так, будто получен ответ с временной ошибкой. Таймаут после “.” обрабатывается специальным образом, поскольку известно, что некоторые кривые реализации не могут распознать конец сообщения, если последний символ в последней строке - бинарный ноль. Таким образом, полезно обработать этот случай как ошибку сообщения.</p>
<p>Таймауты в другие времена, обрабатываются как ошибки хоста, предполагая проблему с хостом, или соединением с ним. Если таймаут после MAIL, RCPT, или “.” - реальная проблема соединения, предполагается, что в следующую попытку таймаут, вероятно, произойдёт в той же точке диалога, вызывая последующую обработку как ошибки хоста.</p>
<p>Есть экспериментальные свидетельства, что некоторые MTA разрывают соединение после завершающей точки - “.”, если им не нравиться содержимое сообщения по каким-то причинам, в нарушение RFC, который указывает, что надо дать ответ 5xx. Именно поэтому, Exim обрабатывает этот случай как ошибку сообщения, а не хоста, чтобы не задерживать другие сообщения к тому же хосту.</p>
</div>
<div class="section" id="smtp-tcp-ip">
<span id="ch45-03"></span><h2>Входящие SMTP сообщения через TCP/IP<a class="headerlink" href="#smtp-tcp-ip" title="Ссылка на этот заголовок">¶</a></h2>
<p>Входящие SMTP сообщения могут быть приняты одним из двух способов: путём слушающего даемона, или путём использования <em>inetd</em>. В последнем случае, в <em>/etc/inetd.conf</em> должно быть что-то вроде этого:</p>
<div class="highlight-python"><pre>smtp stream tcp nowait exim /opt/exim/bin/exim in.exim -bs</pre>
</div>
<p>Exim различает этот случай, и случай локально выполняющегося пользовательского агента, использующего параметр <strong>-bs</strong>, путём проверки, является ли стандартный ввод - сокетом. Когда это так, тот или другой порт должен быть привилегированным (меньше 1024), или вызывающий должен быть root или пользователь Exim`a. Если любой другой пользователь передаёт сокет с непривилегированным номером порта, Exim выводит сообщение в стандартный поток ошибок, и выходит с кодом ошибки.</p>
<p>По умолчанию, Exim не создаёт вхождения логов для соединения и отключений удалённых хостов (или через даемона, или через <em>inetd</em>), если разъединение было ожидаемым. Можно записывать такие вхождения, путём установки селектора логов <strong>smtp_connection</strong>.</p>
<p>Команды от удалённого хоста, как предполагается, должны быть завершены CR и LF. Однако, известны хосты не посылающие символ CR. Чтобы быть в состоянии работать с такими хостами, Exim обходится с LF как с символом конца строки. Кроме того, поскольку для получения сообщений из всех источников используется общий код, самостоятельный CR интерпретируется как признак конца строки. Однако, последовательность “CR, точка, CR” не завершает входящие по SMTP данные.</p>
<p>Одна область, иногда дающая начало проблемам, касается команд EHLO или HELO. Некоторые клиенты посылают синтаксически недопустимые версии этих команд, которые, по умолчанию, отклоняются Exim`ом. (Это - не имеет отношения к проверке посылаемых данных, таким образом, <strong>helo_verify_hosts</strong> - неуместна.) Вы можете сказать Exim`y не применять проверку синтаксиса, путём установки <strong>helo_accept_junk_hosts</strong> в соответствие кривым хостам, посылающим недопустимые команды.</p>
<p>Количество доступного дискового пространства проверяется каждый раз при получении команды MAIL, независимо от того, сконфигурирована ли <strong>message_size_limit</strong> или <strong>check_spool_space</strong>, если <strong>smtp_check_spool_space</strong> не установлена в ложь. Если места недостаточно, даётся временная ошибка. Если установлена <strong>check_spool_space</strong>, проверка - на необходимое количество свободного места, плюс значение данное с SIZE, т.е. Эта проверка будет проверять, что добавление входящего сообщения не уменьшит место ниже порога.</p>
<p>Когда сообщение успешно принято, Exim включает локальный идентификатор сообщения в его ответ на финальную “.”, которая завершает данные. Если удалённый хост записывает в лог этот текст, он может помочь в трассировке - что случилось с сообщением.</p>
<p>Даемон Exim`a может ограничить число одновременных входящих соединений, которые он готов обработать (смотрите параметр <strong>smtp_accept_max</strong>). Также, он может ограничить число одновременных входящих соединений от одного удалённого хоста (смотрите параметр <strong>smtp_accept_max_per_host</strong>). Дополнительные попытки соединения отклоняются, используя 421 код временной ошибки SMTP.</p>
<p>Даемон Exim`a не полагается на сигнал SIGCHLD, для детектирования, когда завершён подпроцесс, поскольку он может потеряться в загруженные моменты. Вместо этого, он при каждом пробуждении ищет завершённые подпроцессы. При условии, что происходят другие события (новые входящие вызовы, запуск обработчика очереди), завершившиеся процессы уведомляются, и аккуратно убираются. В очень спокойных системах, иногда, вы можете увидеть слоняющиеся “умершие” процессы Exim`a. Это не проблема; он будет замечен когда даемон проснётся в следующий раз.</p>
<p>Когда Exim работает как даемон, он может резервировать некоторые слоты SMTP для специфических хостов, и, также, может быть установлен на отклонение SMTP вызовов от нерезервированных хостов во время высокой загрузки системы - для деталей, смотрите параметры <strong>smtp_accept_reserve</strong>, <strong>smtp_load_reserve</strong> и <strong>smtp_reserve_hosts</strong>. Проверка загрузки происходит в обоих случаях - даемоне и <em>inetd</em>.</p>
<p>Обычно, Exim запускает процесс доставки для каждого полученного сообщения, хотя, это может быть изменено параметром командной строки <strong>-odq</strong>, и параметрами <strong>queue_only</strong>, <strong>queue_only_file</strong>, и <strong>queue_only_load</strong>. Число одновременно работающих процессов доставки, начатых таким образом из ввода SMTP, может быть ограничено путём параметров <strong>smtp_accept_queue</strong> и <strong>smtp_accept_queue_per_connection</strong>. Когда тот или другой лимит исчерпан, последующие принятые сообщения просто кладутся во входную очередь, без запуска процесса доставки.</p>
<p>Средства управления, которые связаны с подсчётом входящих вызовов SMTP ((<strong>smtp_accept_max</strong>, <strong>smtp_accept_queue</strong>, <strong>smtp_accept_reserve</strong>) недоступны, когда Exim запущен из даемона <em>inetd</em>, поскольку, в этом случае каждое соединение обрабатывается полностью независимым процессом Exim`a. Однако, управление путём средней загрузки, доступно с <em>inetd</em>.</p>
<p>Exim может быть сконфигурирован на проверку адресов во входящих SMTP командах, как они получены. Смотрите главу <a class="reference internal" href="ch39.html#ch39-00"><em>39</em></a>, для деталей. Он, также, может быть сконфигурирован на перезапись адресов в это время - до какой-либо проверки синтаксиса. Смотрите раздел <a class="reference internal" href="ch39.html#ch39-09"><em>39.9</em></a>.</p>
<p>Также, Exim может быть сконфигурирован на ограничение частоты, с которой клиентский хост посылает команды MAIL и RCPT в одной SMTP-сессии. Смотрите параметр <strong>smtp_ratelimit_hosts</strong>.</p>
</div>
<div class="section" id="ch45-04">
<span id="id2"></span><h2>Нераспознанные SMTP-команды<a class="headerlink" href="#ch45-04" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если Exim получает более чем <strong>smtp_max_unknown_commands</strong> нераспознаных SMTP команд в одном SMTP соединении, он разрывает соединение после ответа о ошибке на последнюю команду. Значение по умолчанию для <strong>smtp_max_unknown_commands</strong> - 3. Это - оборона против некоторых видов злоупотреблений, которые ломают WEB-сервера для создания соединения к SMTP-портам; в этих обстоятельствах, вначале посылаются несколько не-SMTP строк.</p>
</div>
<div class="section" id="ch45-05">
<span id="id3"></span><h2>Синтаксис и ошибки протокола в командах SMTP<a class="headerlink" href="#ch45-05" title="Ссылка на этот заголовок">¶</a></h2>
<p>Синтаксическая ошибка детектируется, если команда SMTP распознана, но есть синтаксически неверные данные, например, неверно сформированный адрес электронной почты в команде RCPT. Ошибки протокола включают недопустимую последовательность команд, типа RCPT до MAIL. Если Exim принимает более чем <strong>smtp_max_synprot_errors</strong> таких команд, в одном SMTP cоединении, он разрывает соединение после посылки сообщения о ошибке на последнюю команду. Значение по умолчанию для <strong>smtp_max_synprot_errors</strong> - 3. Это - защита против кривых клиентов, которые циклически посылают неверные команды (да, было такое замечено).</p>
</div>
<div class="section" id="ch45-06">
<span id="id4"></span><h2>Использование непочтовых SMTP команд<a class="headerlink" href="#ch45-06" title="Ссылка на этот заголовок">¶</a></h2>
<p>“non-mail” команды SMTP - прочие кроме MAIL, RCPT, и DATA. Exim считает такие команды, и разрывает соединение если их слишком много в одной сессии SMTP. Это действие ловит некоторые попытки DoS, и вещи типа повторяющихся неудачных AUTH, или безумных клиентов, циклически посылающих HELO. Глобальный параметр <strong>smtp_accept_max_nonmail</strong> задаёт, “как много” - это много. Её значение по умолчанию - 10.</p>
<p>Когда ожидается новое сообщение, один случай RSET - не подсчитывается. Этим позволяется клиенту послать один RSET до сообщения (это не необходимо, но обычно клиенты так делают). Также, Exim позволяет одно неподсчитываемое HELO или EHLO, и один STARTTLS до сообщения. После начала сессии TLS, ожидается иной EHLO, и, он также не подсчитывается.</p>
<p>Первое возникновение AUTH в соединении, или немедленно после STARTTLS - также не подсчитывается. Иначе, подсчитываются все иные команды, кроме MAIL, RCPT, DATA, и QUIT.</p>
<p>Вы можете управлять, какие хосты подчиняются ограничению, устанавливаемому путём <strong>smtp_accept_max_nonmail</strong> путём установки <strong>smtp_accept_max_nonmail_hosts</strong>. Значение по умолчанию - “*”, которое применяет ограничения ко всем хостам. Этот параметр средство для того, чтобы вы могли исключить некоторые специфические хосты с плохим поведением, с которыми вы должны жить.</p>
</div>
<div class="section" id="vrfy-expn">
<span id="ch45-07"></span><h2>Команды VRFY и EXPN<a class="headerlink" href="#vrfy-expn" title="Ссылка на этот заголовок">¶</a></h2>
<p>Когда Exim получает команду VRFY или EXPN по TCP/IP соединению, он запускает ACL заданную путём <strong>acl_smtp_vrfy</strong> или <strong>acl_smtp_expn</strong> (соответственно), чтобы решить, должны ли команда быть принята. Если нет заданных ACL, команда отклоняется.</p>
<p>Когда VRFY принимается, она запускает тот же самый код, как когда Exim вызывается с параметром <strong>-bv</strong>.</p>
<p>Когда принимается EXPN, производится одноуровневое раскрытие адреса. EXPN обрабатывается как “тестирование адреса” (подобно параметру <strong>-bt</strong>), а не проверка (параметр <strong>-bv</strong>). Если как аргумент EXPN даётся неквалифицированная локальная часть, она квалифицируется с <strong>qualify_domain</strong>. Отклонения команд VRFY и EXPN записывается в главном логе, и логе отклонённых, и ошибки проверки VRFY записываются в главном логе для последовательности с ошибками RCPT.</p>
</div>
<div class="section" id="etrn">
<span id="ch45-08"></span><h2>Команда ETRN<a class="headerlink" href="#etrn" title="Ссылка на этот заголовок">¶</a></h2>
<p><span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc1985.html"><strong>RFC 1985</strong></a> описывает команду SMTP называемую ETRN, которая спроектирована для борьбы с проблемами безопасности команды TURN (которая вышла из употребления). Когда Exim получает команду ETRN в TCP/IP соединении, он запускает ACL заданную путём <strong>acl_smtp_etrn</strong>, чтобы решить, должна ли быть принята команда. Если нет заданных ACL, команда отклоняется.</p>
<p>Команда ETRN имеет отношение к выпуску сообщений, ожидающих доставки на определённые хосты. Поскольку Exim не организовывает свою очередь сообщений по хостам, по умолчанию поддерживается лишь форма ETRN, где текст начинается с префикса “#”, когда остаток текста задаёт сервер SMTP. Допустимая команда ETRN вызывает запуск Exim с параметром <strong>-R</strong>, с остатком от текста ETRN как аргумента. Например:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ETRN</span> <span class="c">#brigadoon</span>
</pre></div>
</div>
<p>запускает команду</p>
<blockquote>
<div>exim -R brigadoon</div></blockquote>
<p>которая вызывает попытку доставки всех сообщений, чей недоставленный адрес содержит текст “brigadoon”. Когда установлена <strong>smtp_etrn_serialize</strong> (по умолчанию), Exim предотвращает одновременное выполнение более чем одного запуска очереди с той же самой строкой аргументов, как результат команды ETRN. Это останавливает клиентов с плохим поведением от запуска более чем одного обработчика очереди за раз.</p>
<p>Exim осуществляет преобразование в последовательную форму при помощи БД подсказок, в которую делается запись при каждом запуске процесса путём ETRN, и удаления, когда процесс завершён. Однако, Exim не оставляет сессию SMTP ждать завершения процесса ETRN. Как только ETRN принята, клиенту посылается успешный код возврата. Очевидно, есть границы действия для записей подсказок, т.к. могла быть системная или программная ошибка (crash). Для принятия мер против этого, Exim игнорирует любые записи, которые старше шести часов.</p>
<p>Для большего управления, чем даёт ETRN, может использоваться параметр <strong>smtp_etrn_command</strong>. Он задаёт команду, которая запускается при каждом получении ETRN, вне зависимости от аргументов. Например:</p>
<div class="highlight-python"><pre>smtp_etrn_command = /etc/etrn_command $domain \
                    $sender_host_address</pre>
</div>
<p>Строка разделяется на аргументы, которые независимо раскрываются. Переменная раскрытия $domain устанавливается в аргумент команды ETRN, и проверки синтаксиса не производится в содержимом аргументов. Exim не ждёт завершения команды, таким образом, код статуса не проверяется. Exim работает под его uid и gid при получении входящего SMTP, таким образом, их невозможно изменить перед запуском команды.</p>
</div>
<div class="section" id="ch45-09">
<span id="id5"></span><h2>Входящий локальный SMTP<a class="headerlink" href="#ch45-09" title="Ссылка на этот заголовок">¶</a></h2>
<p>Некоторые пользовательские агенты используют SMTP для передачи сообщений к своим локальным МТА, используя стандартный ввод и вывод, в противоположность передаче конверта в командной строке, и записи сообщения в стандартный ввод. Это поддерживается путём параметра <strong>-bs</strong>. Эта форма SMTP обрабатывается точно таким же способом, как и входящие во TCP/IP сообщения (включая использование ACL), исключая что, отправитель конверта данный в команде MAIL, - игнорируется, если отправитель не доверенный. В ACL вы можете детектировать эту форму SMTP ввода путём проверки на пустой идентификатор хоста. Обычно, это первая строка в ACL, которая запускается для команд RCPT:</p>
<div class="highlight-python"><pre>accept hosts = :</pre>
</div>
<p>Этим принимаются SMTP сообщения от локальных процессов, без проверки любыми другими тестами.</p>
</div>
<div class="section" id="ch45-10">
<span id="id6"></span><h2>Исходящий пакетный SMTP<a class="headerlink" href="#ch45-10" title="Ссылка на этот заголовок">¶</a></h2>
<p>Оба транспорта - <strong>appendfile</strong> и <strong>pipe</strong> могут быть использованы для обработки пакетного SMTP. Каждый обладает параметром, с именем <strong>use_bsmtp</strong>, которая вызывает вывод сообщений в формате BSMTP. Для этой формы доставки невозможны SMTP ответы. Всё что она делает - использует команды SMTP как способ передать конверт вместе с сообщением.</p>
<p>Сообщение записывается в файл или трубу, с предшествующей командой MAIL и RCPT, и сопровождаемое строкой, содержащей единственную точку. Строки в сообщении, которые начинаются с точки, имеют дополнительную добавленную точку. Команда SMTP HELO, обычно, не используется. Если это требуется, для её задания может использоваться параметр <strong>message_prefix</strong>.</p>
<p>Поскольку оба параметра - <strong>appendfile</strong> и <strong>pipe</strong> - локальные транспорты, они принмают, по умолчанию, лишь один адрес получателя одновременно. Однако, вы можете принять меры для обработки ими нескольких адресов за раз, путём установки параметра <strong>batch_max</strong>. Когда это сделано для BSMTP, сообщения могут содержать несколько команд RCPT. Для дополнительных деталей, смотрите главу <a class="reference internal" href="ch25.html#ch25-00"><em>25</em></a>.</p>
<p>Когда один или более адресов направляются в транспорт BSMTP из маршрутизатора, который установлен списком хостов, имя первого хоста в списке доступно в транспорте, в переменной $host. Вот - пример такого транспорта и маршрутизатора:</p>
<div class="highlight-python"><pre>begin routers

route_append:
  driver = manualroute
  transport = smtp_appendfile
  route_list = domain.example  batch.host.example


begin transports

smtp_appendfile:
  driver = appendfile
  directory = /var/bsmtp/$host
  batch_max = 1000
  use_bsmtp
  user = exim</pre>
</div>
<p>Он вызывает запись сообщений адресованных <em>domain.example</em>, в формате BSMTP, в <em>/var/bsmtp/batch.host.example</em>, с одной копией каждого сообщения (если не более 1000 получателей).</p>
</div>
<div class="section" id="ch45-11">
<span id="id7"></span><h2>Входящий пакетный SMTP<a class="headerlink" href="#ch45-11" title="Ссылка на этот заголовок">¶</a></h2>
<p>Параметр командной строки <strong>-bS</strong> заставляет Exim принимать одно или более сообщений путём чтения со стандартного ввода, но не производя никаких ответов. Если вызывающий - доверенный, оставляется отправитель из команды MAIL; иначе, отправитель - всегда будет вызвавший Exim. Неквалифицированные отправители и получатели не отклоняются (это кажется маленькой точкой), но, вместо этого, просто квалифицируются. HELO и EHLO действуют как RSET; VRFY, EXPN, ETRN и HELP, действуют как NOOP; QUIT - выход.</p>
<p>Для BSMTP ввода, проверки политик не производится. Таким образом, в это время ACL не запускаются. В этом отношении, он - такой же как и локальный не-SMTP ввод.</p>
<p>Если при чтении сообщения обнаружена ошибка, включая отсутствие “.” в конце, Exim немедленно его бросает. Он пишет детали о ошибке на стандартный вывод стилизованным способом, который вызывающая программа могла бы использовать автоматически, например:</p>
<div class="highlight-python"><pre>554 Unexpected end of file
    Transaction started in line 10
    Error detected in line 14</pre>
</div>
<p>Также он пишет более подробную версию, для использования людьми, в стандартный файл ошибок, например:</p>
<div class="highlight-python"><pre>An error was detected while processing a file of BSMTP input.
The error message was:

501 '&gt;' missing at end of address
    The SMTP transaction started in line 10.
    The error was detected in line 12.
    The SMTP command at fault was:

    rcpt to:&lt;malformed@in.com.plete
    1 previous message was successfully processed.
    The rest of the batch was abandoned.</pre>
</div>
<p>Если нет ошибок - Exim возвращает 0 и 1. 1 если какие-то сообщения были приняты до определения ошибки, и 2 - если не было принятых сообщений.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Содержание</a></h3>
  <ul>
<li><a class="reference internal" href="#">Обработка SMTP</a><ul>
<li><a class="reference internal" href="#smtp-lmtp-tcp-ip">Исходящий SMTP и LMTP через TCP/IP</a></li>
<li><a class="reference internal" href="#ch45-02">Ошибки в исходящем SMTP</a></li>
<li><a class="reference internal" href="#smtp-tcp-ip">Входящие SMTP сообщения через TCP/IP</a></li>
<li><a class="reference internal" href="#ch45-04">Нераспознанные SMTP-команды</a></li>
<li><a class="reference internal" href="#ch45-05">Синтаксис и ошибки протокола в командах SMTP</a></li>
<li><a class="reference internal" href="#ch45-06">Использование непочтовых SMTP команд</a></li>
<li><a class="reference internal" href="#vrfy-expn">Команды VRFY и EXPN</a></li>
<li><a class="reference internal" href="#etrn">Команда ETRN</a></li>
<li><a class="reference internal" href="#ch45-09">Входящий локальный SMTP</a></li>
<li><a class="reference internal" href="#ch45-10">Исходящий пакетный SMTP</a></li>
<li><a class="reference internal" href="#ch45-11">Входящий пакетный SMTP</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ch44.html" title="предыдущая глава">Обработка сообщения</a></li>
      <li>Next: <a href="ch46.html" title="следующая глава">Настройка рикошетов и предупреждающих сообщений</a></li>
  </ul></li>
</ul>
  <h3>На этой странице</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ch45.txt"
           rel="nofollow">Показать исходный текст</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Быстрый поиск</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Искать" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Введите слова для поиска или имя модуля, класса или функции.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2011, Exim Maintainers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>