
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Поиски в файлах и базах данных &mdash; Specification of the Exim Mail Transfer Agent 4.70 documentation</title>
    
    <link rel="stylesheet" href="_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.70',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Specification of the Exim Mail Transfer Agent 4.70 documentation" href="index.html" />
    <link rel="next" title="Списки доменов, узлов, адресов и локальных частей [почтового] адреса" href="ch10.html" />
    <link rel="prev" title="Регулярные выражения" href="ch08.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="_static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch10.html" title="Списки доменов, узлов, адресов и локальных частей [почтового] адреса"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch08.html" title="Регулярные выражения"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Specification of the Exim Mail Transfer Agent 4.70 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ch09-00">
<span id="id1"></span><h1>Поиски в файлах и базах данных<a class="headerlink" href="#ch09-00" title="Ссылка на этот заголовок">¶</a></h1>
<p>Exim может быть сконфигурирован для поиска данных в файлах или базах данных, когда он обрабатывает сообщение. Могут использоваться два различных синтаксиса:</p>
<ol class="arabic simple">
<li>Строка, которая будет раскрыта, может содержать явный запрос поиска. По этой причине, часть строки будет заменена данными, найденными поиском. Поиски этого типа - условия в элементах раскрытия. Различные результаты могут быть заданы для случаев успешного и неудачного поисков. Смотрите главу <a class="reference internal" href="ch11.html#ch11-00"><em>11</em></a>, где в деталях описано раскрытие строк.</li>
<li>Списки доменов, хостов, и адресов e-mail могут содержать запрос поиска, как способ избежать слишком длинного линейного списка. В этом случае, данные возвращённые запросом, обычно (но не всегда) отбрасываются <a class="footnote-reference" href="#id21" id="id2">[1]</a>; реально засчитывается - успешен ли поиск, или нет. Эта разновидность списков описана в главе <a class="reference internal" href="ch10.html#ch10-00"><em>10</em></a>.</li>
</ol>
<p>Раскрытие строк, списков, и поисков взаимодействуют друг с другом, в каждом случае, нет порядка, в котором описан любой из них и нет ссылок к другим. Каждая из этих трёх частей даст намного больше, если вы прочтёте вначале две другие. Если вы читаете это первым, то знайте, что поймёте больше, после прочтения глав <a class="reference internal" href="ch10.html#ch10-00"><em>10</em></a> и <a class="reference internal" href="ch11.html#ch11-00"><em>11</em></a>.</p>
<div class="section" id="ch09-01">
<span id="id3"></span><h2>Примеры различных синтаксисов поиска<a class="headerlink" href="#ch09-01" title="Ссылка на этот заголовок">¶</a></h2>
<p>Очень легко перепутать два разных способа поиска, тем более, что списки, которые могут содержать вторую разновидность, всегда раскрываются, прежде чем быть обработанными как списки. Поэтому, они также могут содержать поиски первого вида. Будте точны в различии между следующими двумя примерами:</p>
<div class="highlight-python"><pre>domains = ${lookup{$sender_host_address}lsearch{/some/file}}
domains = lsearch;/some/file</pre>
</div>
<p>Первый использует раскрытие строки, результат которого должен быть списком доменов. Строки, для успешного или безуспешного поиска не заданы; значение по-умолчанию, в этом случае, найденные данные и пустая строка, соответственно. Раскрытие помещается прежде чем строка обрабатывается как список, и файл, по которому ведётся поиск, может содержать строки как эти:</p>
<div class="highlight-python"><pre>192.168.3.4: domain1:domain2:...
192.168.1.9: domain3:domain4:...</pre>
</div>
<p>Когда поиск успешен, результат раскрытия - список доменов (и, возможно, другие типы элементов, разрешённые в списке доменов).</p>
<p>Во втором примере, ищется один элемент в списке доменов. Это вынуждает Exim к использованию поиска, для того чтобы узнать, может ли обрабатываемый домен быть найден в файле. Файл может содержать строки как эти:</p>
<div class="highlight-python"><pre>domain1:
domain2:</pre>
</div>
<p>Любые данные, сопровождаемые ключами, не уместны при проверке что домен совпадает с элементом списка.</p>
<p>Их можно спутать, при использовании обоих видов поиска сразу. Рассмотрите файл, содержащий, например, такие строки:</p>
<div class="highlight-python"><pre>192.168.5.6: lsearch;/another/file</pre>
</div>
<p>Если значение $sender_host_address - 192.168.5.6, раскрытие первой установки <strong>domains</strong> создает вторую установку, которая вызывает второй поиск.</p>
<p>Оставшаяся часть этой главы описывает различные доступные типы поиска. Любой из них может использоваться в любой части конфигурации, где разрешены поиски.</p>
</div>
<div class="section" id="ch09-02">
<span id="id4"></span><h2>Типы поиска<a class="headerlink" href="#ch09-02" title="Ссылка на этот заголовок">¶</a></h2>
<p>Реализованы два различных типа поиска:</p>
<ul class="simple">
<li><em>Одноключевой</em> (<em>single-key</em>) тип поиска, требует задания файла, в котором будет происходить поиск, и одного ключа для поиска. Ключ должен быть непустой строкой, чтобы поиск был успешен. Тип поиска определяет, как найден файл.</li>
<li>Поиск в <em>стиле запроса</em> (<em>query-style</em>) - принимает обобщённый запрос базы данных. Exim не предполагает никакого специфического ключевого значения для поисков в стиле запроса. Вы можете использовать любые переменные Exim`a для необходимого вам запроса к БД.</li>
</ul>
<p>Код для каждого типа поиска находится в отдельном файле исходных текстов, и включается в исполняемый файл Exim`a лишь если при компиляции установлен соответствующий параметр. Настройки по умолчанию в <em>src/EDITME</em> таковы:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">LOOKUP_DBM</span><span class="o">=</span><span class="n">yes</span>
<span class="n">LOOKUP_LSEARCH</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>и означают, что лишь линейный поиск и поиск в DBM включены по умолчанию. Для некоторых типов поисков (например, БД SQL), вам необходимо инсталлировать библиотеки и файлы заголовков, до сборки Exim`a.</p>
</div>
<div class="section" id="ch09-03">
<span id="id5"></span><h2>Одноключевые типы поиска<a class="headerlink" href="#ch09-03" title="Ссылка на этот заголовок">¶</a></h2>
<p>Реализованы следующие одноключевые типы поиска:</p>
<ul>
<li><p class="first"><strong>cdb</strong>: По данному файлу производится поиск как по файлу Статической БД (Constant DataBase), используя ключевую строку без завершающего двоичного нуля. Формат cdb спроектирован для индексных файлов, которые часто читаются, и никогда не обновляются, исключая полное пересоздание. Также он является наиболее подходящим для больших файлов, содержащих синонимы, или другие индексированные данные, на которые ссылается MTA. Информация о cdb может быть найдена в нескольких местах:</p>
<div class="highlight-python"><pre>http://www.pobox.com/~djb/cdb.html
ftp://ftp.corpit.ru/pub/tinycdb/
http://packages.debian.org/stable/utils/freecdb.html</pre>
</div>
<p>Дистрибутив cdb не нужен для сборки Exim`a с поддержкой cdb, поскольку код для чтения cdb-файлов непосредственно включён в Exim. Однако, с Exim`ом не предоставляется никаких средств для сборки или тестирования cdb-файлов, таким образом вам необходимо получить дистрибутив cdb для этого.</p>
</li>
<li><p class="first"><strong>dbm</strong>: Вызовы к библиотечным функциям dbm используются для извлечения данных из файлов DBM, путём поиска записей с данным ключом. Завершающий бинарный ноль включён в ключ, который передаётся библиотеке DBM. Смотрите раздел <a class="reference internal" href="ch04.html#ch04-04"><em>4.4</em></a>, для обсуждения библиотек DBM.</p>
<p>Для всех версий Berkeley DB, Exim использует стиль DB_HASH базы данных, когда собирает DBM-файлы используя утилиту <strong>exim_dbmbuild</strong>. Однако, когда используется Berkeley DB версий 3 и 4, он открывает для чтения, существующие базы данных, с параметром DB_UNKNOWN. Это позволяет ему обработать любой из типов БД поддерживаемых библиотекой, и может быть полезным для доступа к DBM-файлам созданным другими приложениями. (Для более ранних версий DB, всегда используется DB_HASH.)</p>
</li>
<li><p class="first"><strong>dbmnz</strong>: Это тоже самое, что и <strong>dbm</strong>, за исключением, что, завершающий бинарный ноль не включен в ключ передаваемый библиотеке DBM. Вам может понадобиться использовать это, если вы хотите искать данные в файлах, которые созданы или расшарены с каким-либо иным приложением, которое не использует завершающий ноль. Например, вы должны использовать <strong>dbmnz</strong> а не <strong>dbm</strong>, если вам необходимо аутентифицировать входящие SMTP-подключения, используя пароли из файла <em>/etc/userdbshadow.dat</em> Сourier`a. Утилита Exim`a для создания файлов DBM (<em>exim_dbmbuild</em>) по умолчанию включает нули, но у неё есть параметр для их исключения (смотрите раздел <a class="reference internal" href="ch50.html#ch50-09"><em>50.9</em></a>).</p>
</li>
<li><p class="first"><strong>dsearch</strong>: Данный файл должен быть директорией; вызовом функции <em>lstat()</em> ищется файл, имя которого равно ключу. Ключ не должен содержать символов прямого слэша. Если <em>lstat()</em> успешен, то результат поиска - имя объекта, ккоторый может быть файлом, директорией, символической ссылкой, или чем угодно что может содержать директория. Пример, как этот поиск может использоваться для поддержки виртуальных доменов, дан в разделе <a class="reference internal" href="ch47.html#ch47-07"><em>47.7</em></a>.</p>
</li>
<li><p class="first"><strong>iplsearch</strong>: Данный файл - текстовый файл, содержащий ключи и данные. Ключ завершается двоеточием, или пробелом, или концом строки. Ключи, в файле, должны быть IP-адресами, или IP-адресами с CIDR масками. Ключи включающие в себя адреса IPv6, должны быть заключены в кавычки, для предотвращения интерпретации первого внутреннего двоеточия как завершение ключа. Например:</p>
<div class="highlight-python"><pre>1.2.3.4:           data for 1.2.3.4
192.168.0.0/16:    data for 192.168.0.0/16
"abcd::cdab":      data for abcd::cdab
"abcd:abcd::/32"   data for abcd:abcd::/32</pre>
</div>
<p>Ключ для <strong>iplsearch</strong> поиска  должен быть IP-адресом (без маски). Поиск по файлу линейный, с использованием масок CIDR, где они заданы, до нахождения соответствия ключу. Используется первый совпадающий ключ; дальнейших попыток найти “лучшее” совпадение, не предпринимается. Кроме совпадения ключей, обработка <strong>iplsearch</strong> - такая же как у <strong>lsearch</strong>.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">В отличие от большинства других одноключевых поисков, файл данных для <strong>iplsearch</strong> не может быть превращён в DBM или cdb-файл, поскольку эти типы поиска поддерживают только буквальные ключи.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">В списке хостов,вы всегда должны использовать <strong>net-iplsearch</strong>, таким образом, чтобы неявный ключ был IP-адресом, а не именем (смотрите раздел <a class="reference internal" href="ch10.html#ch10-12"><em>10.12</em></a>).</p>
</div>
</li>
<li><p class="first"><strong>lsearch</strong>: Данный файл - текстовый файл, по которому линейно ищется строка, начинающаяся с искомого ключа, законченную двоеточием, или пробелом, или концом строки. Поиск регистронезависимый; таким образом, символы верхнего и нижнего регистра обрабатываются как одинаковые. Используется первое найденное совпадение.</p>
<p>Разрешено пустое место между ключом и двоеточием. Остаток строки, после удаления начального и конечного пустого пространства является данными. Они могут быть продолжены на последующие строки путём начала их с любого количества пустого пространства, но только один символ пробела включается в данные при таком соединении. Если данные начинаются с двоеточия, ключ должен быть завершён двоеточием, например:</p>
<div class="highlight-python"><pre>baduser:  :fail:</pre>
</div>
<p>Пустые строки, и строки начинающиеся с # игнорируются, даже если они встречаются в середине строки. Это - традиционный текстовый формат файла синонимов. Обратите внимание, что ключи в файле <strong>lsearch</strong> - симводьные строки. Тут нету подстановки (“wildcarding”) какого бы то ни было вида.</p>
<p>В большинстве <strong>lsearch</strong> файлов, ключи не могут содержать двоеточия, или символы #, или пустые пробелы. Однако, если вам необходима эта возможность, она доступна. Если ключ начинается с символа двойной кавычки, она завершается только соответствующей кавычкой (или концом строки), и, к её содержимому, применяются обычные правила экранирования (смотрите раздел <a class="reference internal" href="ch06.html#ch06-16"><em>6.16</em></a>). Необязательное двоеточие разрешено после ключа в кавычках (также как и для ключей без кавычек). Специальная обработка кавычек для части данных строки <strong>lsearch</strong> отсуствует.</p>
</li>
<li><p class="first"><strong>nis</strong>: Данный файл - имя карты NIS, и поиск NIS производится с данным ключом, без завершающего двоичного нуля. Есть вариант, называемый <strong>nis0</strong>, который включает двоичный нуль в ключ. По сведениям, это необходимо для файла синонимов в стиле SUN. Exim не понимает NIS синонимы; должны использоваться полные имена карт.</p>
</li>
<li><p class="first"><strong>wildlsearch</strong> или <strong>nwildlsearch</strong>: Поиск по файлу линейный, как <strong>lsearch</strong>, но вместо того, чтобы интепретировать как литеральную строку, каждый ключ в файле может быть подстановочным. Различие между этими двумя типами поиска в том, что для <strong>wildlsearch</strong> каждый ключ в файле раскрывается до начала использования, тогда как для <strong>nwildlsearch</strong> нет раскрытия на месте.</p>
<p>Как и <strong>lsearch</strong>, тестирование производится без учёта регистра. Однако, ключи в файле, являющиеся регулярными выражениями, могут быть регистрозависмыми, если перед шаблоном используется ключ (-i). Признаются следующие формы подстановочных знаков:</p>
<ol class="arabic">
<li><p class="first">Строка может начинаться со звёздочки, для обозначения “кончается на”. Например:</p>
<div class="highlight-python"><pre>*.a.b.c       data for anything.a.b.c
*fish         data for anythingfish</pre>
</div>
</li>
<li><p class="first">Строка может начинаться с крышки (“^”), для обозначения регулярного выражения. Например, для <strong>wildlsearch</strong>:</p>
<div class="highlight-python"><pre>^\N\d+\.a\.b\N    data for &lt;digits&gt;.a.</pre>
</div>
</li>
</ol>
<blockquote>
<div><p>Использование “\N” отключает раскрытие содержимого регулярного выражения. Если вы используете <strong>nwildlsearch</strong> там, где ключи не раскрываются, это эквиалентно:</p>
<div class="highlight-python"><pre>^\d+\.a\.b        data for &lt;digits&gt;.a.b</pre>
</div>
<p>Регистронезависимый флаг устанавливает начало компиляции регулярного выражения, но это может быть отключено использованием (-i) в соответствующем месте. Например, чтобы весь шаблон был регистрозависим:</p>
<div class="highlight-python"><pre>^(?-i)\d+\.a\.b        data for &lt;digits&gt;.a.b</pre>
</div>
<p>Если регулярное выражение содержит пустое место, или символы двоеточия, вы должны поместить его в кавычки (смотрите <strong>lsearch</strong>, выше), или представить эти символы другим образом. Например, \s может быть использовано для обозначения пробела и \x3A - для двоеточия. Это может оказаться легче, чем использовать кавычки, поскольку при использовании кавычек, вы должны экранировать все обратные слэши внутри кавычек.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">Невозможно зафиксировать подстроки в совпадении регулярного выражения, для дальнейшего использования, поскольку результаты всех поисков кэшируются. Если поиск повторяется, результат берётся из кэша, и нет фактического сопоставления с образцом. Значения всех цифровых переменных сбрасываются после совпадения <strong>(n)wildlsearch</strong>.</p>
</div>
</div></blockquote>
<ol class="arabic" start="3">
<li><p class="first">Хотя я не вижу много применений, общая функция соответствия, используемая для реализации <strong>(n)wildlsearch</strong>, означает, что строка может начинаться с имени поиска, завершаемого двоеточием, и сопровождаться данными поиска. Например:</p>
<div class="highlight-python"><pre>cdb;/some/file  data for keys that match the file</pre>
</div>
</li>
</ol>
<blockquote>
<div><p>Данные, полученные из вложенного поиска, отвергаются.</p>
<p>Ключи, которые не соответствуют ни одному из этих шаблонов, интепретируются буквально. Правила продолжения для данных - точно ткие же как для <strong>lsearch</strong>, и ключи могут сопровождаться необязательными двоеточиями.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">В отличие от большинства других одноключевых поисков, файл данных для <strong>(n)wildlsearch</strong> не может быть превращён в DBM или cdb-файл, поскольку эти типы поиска поддреживают только буквальной соответствие.</p>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="ch09-04">
<span id="id6"></span><h2>Типы поиска в стиле запроса<a class="headerlink" href="#ch09-04" title="Ссылка на этот заголовок">¶</a></h2>
<p>Поддерживаемые типы поиска в стиле запроса перечислены ниже. Дальнейшие детали, о многих из них, даны в дальнейших разделах.</p>
<ul>
<li><p class="first"><strong>dnsdb</strong>: Этот производит поиск одной или более записей, чьи доменные имена даны в предоставленном запросе. Результирующие данные - содержимое записей. Смотрите раздел <a class="reference internal" href="#ch09-10"><em>9.10</em></a>.</p>
</li>
<li><p class="first"><strong>ibase</strong>: Этот производит поиск по БД InterBase.</p>
</li>
<li><p class="first"><strong>ldap</strong>: Этот производит поиск по LDAP, используя запрос в форме URL, и возвращает атрибуты единственного элемента. Есть вариант, вызывающий <strong>ldapm</strong>, который разрешает возврат значений от нескольких элементов. Третиф вариант, называемый <strong>ldapdn</strong>, возвращает Distinguished Name (отличительное имя) одного элемента, вместо любых значений атрибутов. Смотрите раздел <a class="reference internal" href="#ch09-13"><em>9.13</em></a>.</p>
</li>
<li><p class="first"><strong>mysql</strong>: Формат запроса - SQL-выражение, передаваемое БД MySQL. Смотрите раздел <a class="reference internal" href="#ch09-20"><em>9.20</em></a>.</p>
</li>
<li><p class="first"><strong>nisplus</strong>: Этот производит поиск в NIS+, используя запрос, который может задать имя поля для возврата. Смотрите раздел <a class="reference internal" href="#ch09-19"><em>9.19</em></a>.</p>
</li>
<li><p class="first"><strong>oracle</strong>: Формат запроса - SQL-выражение, передаваемое БД Oracle. Смотрите раздел <a class="reference internal" href="#ch09-20"><em>9.20</em></a>.</p>
</li>
<li><p class="first"><strong>passwd</strong>: Поиск в стеле запросов, с запросами, которые содержат лишь имя пользователя. Поиск вызывает <em>getpwnam()</em>, для запроса данных системного пароля, и при успехе, строка результата - то же самое, что вы бы получили из поиска <strong>lsearch</strong> в традиционном файле паролей <em>/etc/passwd file</em>, со значением * в качестве заначения пароля. Например:</p>
<div class="highlight-python"><pre>*:42:42:King Rat:/home/kr:/bin/bash</pre>
</div>
</li>
<li><p class="first"><strong>pgsql</strong>: Формат запроса - SQL-выражение, передаваемое БД PostgreSQL. Смотрите раздел <a class="reference internal" href="#ch09-20"><em>9.20</em></a>.</p>
</li>
<li><p class="first"><strong>sqlite</strong>: Формат запроса - имя файла, сопровождаемое SQL-выражением, передаваемым БД SQLite. Смотрите раздел <a class="reference internal" href="#ch09-25"><em>9.25</em></a>.</p>
</li>
<li><p class="first"><strong>testdb</strong>: Это тип поиска, используемый для тестирования Exim. Он врятли будет полезен в обчной ситуации.</p>
</li>
<li><p class="first"><strong>whoson</strong>: <em>Whoson</em> (<a class="reference external" href="http://whoson.sourceforge.net">http://whoson.sourceforge.net</a>) - Internet-протокол, позволяющий программам интернет-серверов проверять то, что конкретный (динамически выделенный) IP адрес в данное время назначен известному (доверенному) пользователю, и необязательно, для получения идентификационных данных этого пользователя. В Exim, он может быть использован для реализации проверки условия ACL “POP перед SMTP”, например:</p>
<div class="highlight-python"><pre>require condition = \
  ${lookup whoson {$sender_host_address}{yes}{no}}</pre>
</div>
<p>Запрос состоит из единственного IP-адреса. Возвращённое значение - имя аутентифицированного пользователя, который сохранён в переменной $value. Однако, в этом примере, данные $value не используются; результат поиска - одна из фиксированных строк - “yes” or “no”.</p>
</li>
</ul>
</div>
<div class="section" id="ch09-05">
<span id="id7"></span><h2>Временные ошибки в поисках<a class="headerlink" href="#ch09-05" title="Ссылка на этот заголовок">¶</a></h2>
<p>Функции поиска мошут вернуть коды временных ошибок, если поиск не может быть завершён. Например, БД SQL или LDAP могут быть недоступны. Поэтому не желательно использовать поиск, которыё мог бы сделать такое для критичных параметров, например, списка локальных доменов.</p>
<p>Когда поиск не может быть завершён в маршрутизаторе или транспорте, доставка сообщения (к релевантному адресу) задерживается, как и для других временных ошибок. При других обстоятельствах, Exim может предположить, что поиск был неудачен, или может вообще всё бросить.</p>
</div>
<div class="section" id="ch09-06">
<span id="id8"></span><h2>Значения по умолчанию в одноключевых поисках<a class="headerlink" href="#ch09-06" title="Ссылка на этот заголовок">¶</a></h2>
<p>В этом контексте, “значения по умолчанию” - это значения заданные администратором, которое должно использоваться, если поиск неудачен.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">Эта секция относится только к одноключевым поискам. Для поисков в стиле запроса, должны использоваться средства языка запроса. Попытка определить значение по-умолчанию для поиска в стиле запроса провоцирует ошибку.</p>
</div>
<p>Если “*” добавляется к одноключевому типу поиска (например <strong>lsearch*</strong>) и начальный поиск неудачен, ключ “*” ищется в файле, для нахождения значения по-умолчанию. Также, смотрите раздел о частичном соответствии, ниже.</p>
<p>Альтернативно, если “*&#64;” добавляется к одноключевому типу поиска (например <strong>dbm*&#64;</strong>), тогда, если начальный поиск неудачен и ключ содержит символ &#64; второй поиск производится заменив все на *, до последней &#64;. Это позволяет предоставить значения по умолчанию на домен, в файлах синонимов, включающих домены в ключи. Если воторой поиск неудачен (или его нет, потому что в ключе нет &#64;), ищется “*”. Например, маршрутизатор <strong>redirect</strong> мог бы содержать:</p>
<div class="highlight-python"><pre>data = ${lookup{$local_part@$domain}lsearch*@{/etc/mix-aliases}}</pre>
</div>
<p>Предположим, обрабатываемый адрес - <em>jane&#64;eyre.example</em>. Exim ищет эти ключи в таком порядке:</p>
<div class="highlight-python"><pre>jane@eyre.example
*@eyre.example
*</pre>
</div>
<p>Данные берутся из любого ключа найденного первым.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">В файле <strong>lsearch</strong>, это не означает первый из этих ключей в файле. Полное сканирование производится для каждого ключа, и лишь если он не найден, Exim пробует следующий ключ.</p>
</div>
</div>
<div class="section" id="ch09-07">
<span id="id9"></span><h2>Частичное совпадение в одноключевых поисках<a class="headerlink" href="#ch09-07" title="Ссылка на этот заголовок">¶</a></h2>
<p>Нормальная операция одноключевого поиска - поиск в файле, точного соответствия заданному ключу. Однако, во множестве ситуаций в которых ищутся домены, было бы полезным частичное соответствие. В этом случае, информация в файле, которая начинается с “*.”, совпадает с любым доменом заканчивающимся компоненами, следующими за точкой. Например, если ключ в DBM-файле такой</p>
<div class="highlight-python"><pre>*.dates.fict.example</pre>
</div>
<p>тогда, когда частичное соответсвие включено, это совпадает (в том числе) <em>2001.dates.fict.example</em> и <em>1984.dates.fict.example</em>.  Также совпадает с <em>dates.fict.example</em>, если эта строка не появляется как отдельный ключ в файле.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">Частичное соответствие не доступно для поисков в стиле запроса. Также оно недоступно для поиска любых элементов в списках адресов (смотрите раздел <a class="reference internal" href="ch10.html#ch10-19"><em>10.19</em></a>).</p>
</div>
<p>Частичное соответствие реализовано путём отдельных поисков с использованием ключей сконструированных путём модификации оригинального ключа. Это означает, что он может использоваться с любым типом одноключевого поиска, при условии, что частично совпадающие ключи, начинающиеся со специального преффикса (по умолчанию - “*.”), включены в файл данных. Ключи в файле, которые не начинаются с преффикса, совпадают только с немодифицированными ключами, когда используется частичное соответствие.</p>
<p>Частичное соответствие вызывают путём добавления строки “partial-” к началу имени одноключевого типа поиска, например, <strong>partial-dbm</strong>. Когда это происходит, вначале ищется немодифицированный объект ключа; если поиск неудачен, “*.” добавляется вначале ключа, и снова производится поиск. Если он неудачен, будущие поиски пробуют удалять разделённые точками компоненты, он начала ключа, один за одним, и добавляя “*.” к началу того, что осталось.</p>
<p>Требуемое минимальное число не-* компонентов - два. Это может быть скорректировано включением числа до дефиса, в типе поиска. Например, <strong>partial3-lsearch</strong> задаёт минимум три не-* компонента в измененённых ключах. Отстутствие числа эквивалентно “partial2-”. Если ключ <em>2250.dates.fict.example</em>, тогда следующие ключи ищутся, когда минимальное число не-* компонентов - два:</p>
<div class="highlight-python"><pre>2250.dates.fict.example
*.2250.dates.fict.example
*.dates.fict.example
*.fict.example</pre>
</div>
<p>Как только один ключ, в последовательности, успешно найден, поиск завершён.</p>
<p>Использование “*.”, как преффикса по умолчанию, может быть изменено. Мотивацией для этой возможности является разрешение Exim`y работать с форматами файлов используемыми другими MTA. Иной префикс может быть предоставлен в круглых скобках, вместо дефиса, после “partial”. Например:</p>
<div class="highlight-python"><pre>domains = partial(.)lsearch;/some/file</pre>
</div>
<p>В этом примере, если домен - <em>a.b.c</em>, последовательность поисков - <em>a.b.c</em>, <em>.a.b.c</em> и <em>.b.c</em> (при неизменённом минимуме по умолчанию в 2 компонента). Префикс может состоять из любых символов пунктуации, кроме закрывающей круглой скобки. Он может быть пустым, например:</p>
<div class="highlight-python"><pre>domains = partial1()cdb;/some/file</pre>
</div>
<p>Для этого примера, если домен <em>a.b.c</em>, последовательность поиска будет <em>a.b.c</em>, <em>b.c</em> и <em>c</em>.</p>
<p>Если задан “partial0”, что случается в конце (когда поиск, с лишь одним неподстановочным компонентом, неудачен и оригинальный ключ укорачиватся вправо на нулевую строку) зависимостей от префикса:</p>
<ul class="simple">
<li>Если префикс имеет нулевую длинну, весь поиск неудачен.</li>
<li>Если длинна префикса равна 1, поиск производится лишь для префикса. Например, заключительный поиск для “partial0(.)” является единственным для “.”.</li>
<li>Иначе, если префикс заканчиватся точкой, точка удаляется, и ищется оставшаяся часть. Поэтому, с префиксом по умолчанию, финальный поиск для “*” самостоятелен.</li>
<li>Иначе, ищется полный префикс.</li>
</ul>
<p>Если тип поиска заканчивается на “*” или “*&#64;” (смотрите выше, раздел <a class="reference internal" href="#ch09-06"><em>9.6</em></a>), поиск окончательного значения по умолчанию, подразумевающего эти последовательности, происходит после неудачи всех поисков. Однако, тут можно использовать поиск типа “partial0(.)lsearch*”.</p>
<p>Использование “*”, в  частично соответствующем поиске, отличается от её использовния как подстановочного символа в списках доменов и тому подобном. Частичное соответствие работает только в виде компонентов разделённых точкой; ключ, например <em>*fict.example</em> бесполезен в БД, поскольку звёздочка в частично совпадающем ключе всегда сопровождается точкой.</p>
</div>
<div class="section" id="ch09-08">
<span id="id10"></span><h2>Кэширование поиска<a class="headerlink" href="#ch09-08" title="Ссылка на этот заголовок">¶</a></h2>
<p>Exim кэширует все результаты поисков, для избежания бесполезных повторений поисков. Однако, поскольку (кроме даемона) Exim работает как коллекция независимых, короткоживущих процессов, это кэширование применяется только в пределах одного процесса Exim`a. Средства для межпроцессного кэширования отсутсвуют.</p>
<p>Для одноключевого поиска, Exim оставляет релевантные файлы открытыми в случае, если есть другой поиск, нуждающийся в них. В некоторых типах конфигураций, это может привести к большому числу открытых файлов, сохраняемых открытыми, оставляемых открытыми для сообщений со многими получателями. Для избежания попадений под системные ограничения на число открытых файлов, Exim закрывает последний использованный файл, когда необходимо открыть больше файлов чем позволяют его внутренние ограничения, которое можно изменить через параметр <strong>lookup_open_max</strong>.</p>
<p>Файлы одноключевого поиска закрываются и сбрасывается кэш поиска в стратегических точках доставки - например, после завершения всех маршрутизаторов.</p>
</div>
<div class="section" id="ch09-09">
<span id="id11"></span><h2>Экранирование данных поиска<a class="headerlink" href="#ch09-09" title="Ссылка на этот заголовок">¶</a></h2>
<p>Когда данные из входящего сообщения включаются в поиск типа запросов, возможно появление специальных символов в данных, нарушающих синтаксис запроса. Например, запрос NIS+ содержащий</p>
<div class="highlight-python"><pre>[name=$local_part]</pre>
</div>
<p>будет прерван, если локальная часть будет содержать правую квадратную скобку. Для данных NIS+, данные должны быть помещены в двойные кавычки, как в примере:</p>
<div class="highlight-python"><pre>[name="$local_part"]</pre>
</div>
<p>но это оставляет проблемы с кавычками в данных. Правила для NIS+ состоит в том, что двойные кавычки должны быть удвоены. Другие типы поиска имеют иные правила, и для решения этих требований существет оператор раскрытия такой формы:</p>
<div class="highlight-python"><pre>${quote_&lt;lookup-type&gt;:&lt;string&gt;}</pre>
</div>
<p>Например, самый безопасный способ написания NIS+ запроса:</p>
<div class="highlight-python"><pre>[name="${quote_nisplus:$local_part}"]</pre>
</div>
<p>Смотрите главу <a class="reference internal" href="ch11.html#ch11-00"><em>11</em></a> для полного обзора раскрытия строк. Оператор кавычек может использоваться для всех типов поисков, но он не имеет эффекта в одноключевых поисках, т.к. кавычки в них никогда не бывают необходимы.</p>
</div>
<div class="section" id="dnsdb">
<span id="ch09-10"></span><h2>Дополнительные сведения о dnsdb<a class="headerlink" href="#dnsdb" title="Ссылка на этот заголовок">¶</a></h2>
<p>Тип поиска <strong>dnsdb</strong> использует DNS как базу данных. Простой запрос содержит тип записи и имя домен, разделённые знаком равно (“=”). Например, строка раскрытия может содержать:</p>
<div class="highlight-python"><pre>${lookup dnsdb{mx=a.b.example}{$value}fail}</pre>
</div>
<p>Если поиск успешен, результат помещается в $value, которая, в этом случае, используется как результат. Если поиск не успешен, ключевое слово <tt class="docutils literal"><span class="pre">fail</span></tt> вызывает принудительную ошибку раскрытия (“<em>forced expansion failure</em>”) - смотрите раздел <a class="reference internal" href="ch11.html#ch11-04"><em>11.4</em></a> для понимания, что это означает.</p>
<p>Поддерживаемые типы DNS-записей - A, CNAME, MX, NS, PTR, SRV, and TXT, и когда Exim скомпилен с поддержкой IPv6 - AAAA (и A6, если это тоже сконфигурено). Если тип не задан, предполагается TXT. Когда тип PTR, данные могут быть нормально записанным IP-адресом; инверсия и добавление <strong>in-addr.arpa</strong> или <strong>ip6.arpa</strong> происходят автоматически. Например:</p>
<div class="highlight-python"><pre>${lookup dnsdb{ptr=192.168.4.5}{$value}fail}</pre>
</div>
<p>Если данные для PTR-записи не являются синтаксически допустимым IP-адресом, он не изменяется и ничего не добавляется.</p>
<p>Для поиска MX, для каждой записи возвращаются оба привелигированных значения, и имя хоста, разделённые пробелом. Для поиска SRV, приоритет, вес, порт и имя хоста возвращаются для каждой записи, разделённые пробелами.</p>
<p>Для любых типов записей, если найдено много записей (или, для поиска A6, если одна запись ведёт ко многим адресам), данные возвращаются как объединение, с символом новой строки, как разделителем по умолчанию. Порядок, разумеется, определяется DNS-резольвером. Вы можете задать иной разделитель символов, между несколькими записями, путём помещения в начале запроса правой угловой скобки, сопровождаемой (без пробелов) новым раделителем. Например:</p>
<div class="highlight-python"><pre>${lookup dnsdb{&gt;: a=host1.example}}</pre>
</div>
<p>Разрешается задать пробел, как символ разделителя. дальнейшее пустое пространство игнорируется.</p>
</div>
<div class="section" id="ch09-11">
<span id="id12"></span><h2>Псевдо-“dnsdb” типы записей<a class="headerlink" href="#ch09-11" title="Ссылка на этот заголовок">¶</a></h2>
<p>По-умолчанию, и предпочтительное значение, и имя хоста, возвращаются для каждой MX-записи, разделённые пробелами. Если вам нужны только имена хостов, вы можете использовать псевдо-тип MXH:</p>
<div class="highlight-python"><pre>${lookup dnsdb{mxh=a.b.example}}</pre>
</div>
<p>В этом случае, предпочтительное значение опущено, и возвращаются только имена хостов.</p>
<p>Другой псевдотип - ZNS (расшифровывается “zone NS”). Он выполянет поиск NS-записи для данного домена, но если она не наёдена, он удаляет первый компонент имени домена, и пробует снова. Этот процесс продолжанется пока не найдена NS-запись, или не останется компонентов имени (или произойдёт ошибка DNS). Другими словами, он может вернуть сервер имён домена верхнего уровня, но никогда не вернёт корневой сервер имён. Если нет NS-записей домена верхнего уровня, поиск неудачен. Рассмотрите эти примеры:</p>
<div class="highlight-python"><pre>${lookup dnsdb{zns=xxx.quercite.com}}
${lookup dnsdb{zns=xxx.edu}}</pre>
</div>
<p>Предполагается, что в каждом случае тут нет NS-записей для полного доменного имени, в первом случае сервером имён возвращается значение для <em>quercite.com</em>, и во втором случае сервером имён возвращается значение для <em>edu</em>.</p>
<p>Вы должны быть внимательны при использовании этого типа поиска, поскольку, если домен верхнего уровня не существует, поиск всегда вернёт какое-то имя домена. Это могло бы использоваться для того, чтобы видеть, находится ли сервер имён данного домена в чёрном списке. Вероятно, вы можете предполагать, что сервреа имён для доменов верхнего уровня, таких как <em>su</em> или <em>co.uk</em> не собиираются находиться в таких списках.</p>
<p>Третий псевдо-тип - CSA (Client SMTP Authorization). Он ищет SRV-записи для правил CSA, которые описаны в разделе <a class="reference internal" href="ch40.html#ch40-46"><em>40.46</em></a>. Хотя <strong>dnsdb</strong> непосредственно поддерживает поиски SRV, этого недостаточно, из-за дополнительного режима поиска родительских доменов CSA. Результат успешного поиска, например:</p>
<div class="highlight-python"><pre>${lookup dnsdb {csa=$sender_helo_name}}</pre>
</div>
<p>имеет два разделённых пробелами поля: код авторизации и имя целевого хоста. Авторизационный код может быть “Y” для yes, “N” для no, “X” для явно требуемой, но отсутствующей авторизации, или “?” для неизвестного.</p>
</div>
<div class="section" id="ch09-12">
<span id="id13"></span><h2>Множественные поиски dnsdb<a class="headerlink" href="#ch09-12" title="Ссылка на этот заголовок">¶</a></h2>
<p>В предыдущих разделах описаны поиски для одиночного домена. Однако, вы можете задать список доменов или адресов в отдельном <strong>dnsdb</strong> поиске. Список задаётся в нормальном виде Exim`a, с двоеточием в качестве разделителя по умолчанию, но с возможностью изменить его. Например:</p>
<div class="highlight-python"><pre>${lookup dnsdb{one.domain.com:two.domain.com}}
${lookup dnsdb{a=one.host.com:two.host.com}}
${lookup dnsdb{ptr = &lt;; 1.2.3.4 ; 4.5.6.8}}</pre>
</div>
<p>Для сохранения обратной совместимости, есть один специальный случай: если тип поиска PTR и не указано изменение разделителя, Exim смотрит, не является ли остаток строки одним IPv6 адресом. В этом случае, он не обрабатывает её как список.</p>
<p>Данные каждого поиска объединены, с символом новой строки в качестве разделителя по умолчанию, таким образом обрабатываются множественные DNS-записи для одного элемента. Может быть задан иной разделитель, как указано выше.</p>
<p>Поиск <strong>dnsdb</strong> неудачен, лишь если неудачны все все DNS-поиски. Если для любого из них происходит временная ошибка DNS, то поведением управляет необязательное ключевой слово, с последующей запятой, могущей появиться перед типом записи. Возможные ключевые слова - “defer_strict”, “defer_never”, и “defer_lax”. С “strict” поведением, любая временная ошибка DNS вызывает задержку всего поиска. С “never” поведением, временные ошибки DNS игнорируются, и поведение такое, будто поиск в DNS не привёл ни к чему. С “lax” поведением, предпринимаются все запросы, но временые ошибки DNS вызывают задержку лишь в случае, если если остальные поиски были безуспешны. Дафолт - “lax”, таким образом, следующие поиски эквивалентны:</p>
<div class="highlight-python"><pre>${lookup dnsdb{defer_lax,a=one.host.com:two.host.com}}
${lookup dnsdb{a=one.host.com:two.host.com}}</pre>
</div>
<p>Следовательно, в случае по умолчанию, поиск успешен до тех пор, пока хоть один поиск в DNS привёл к каким-то данным.</p>
<div class="section" id="ldap">
<span id="ch09-13"></span><h3>Дополнительные сведения о LDAP<a class="headerlink" href="#ldap" title="Ссылка на этот заголовок">¶</a></h3>
<p>Оригинальная реализация LDAP была сделана в University of Michigan; она стала “Open LDAP”, и сейчас существует два различных релиза. Другая реализация происходит из Netscape, Solaris 7 и последующие релизы содержат встроенную поддержку LDAP. К сожалению, хотя все они совместимы на уровне функционирования запросов, обработка их ошибок различна. По этой причине необходимо установить переменную, во время компиляции Exim`a с LDAP, для указания, какая библиотека LDAP используется. Одна из следующих строк должна быть в вашем <em>Local/Makefile</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">LDAP_LIB_TYPE</span><span class="o">=</span><span class="n">UMICHIGAN</span>
<span class="n">LDAP_LIB_TYPE</span><span class="o">=</span><span class="n">OPENLDAP1</span>
<span class="n">LDAP_LIB_TYPE</span><span class="o">=</span><span class="n">OPENLDAP2</span>
<span class="n">LDAP_LIB_TYPE</span><span class="o">=</span><span class="n">NETSCAPE</span>
<span class="n">LDAP_LIB_TYPE</span><span class="o">=</span><span class="n">SOLARIS</span>
</pre></div>
</div>
<p>Если <tt class="docutils literal"><span class="pre">LDAP_LIB_TYPE</span></tt> не задана, Exim предполагает <tt class="docutils literal"><span class="pre">OPENLDAP1</span></tt>, имеющий такой же интерфейс, как и версия University of Michigan.</p>
<p>Есть три типа поиска LDAP в Exim. Они ведут себя по-разному, когда обрабатывают результаты запроса:</p>
<ul class="simple">
<li><strong>ldap</strong> - требует, чтобы результат содержал только один элемент; если их больше - он выдаёт ошибку.</li>
<li><strong>ldapdn</strong> - также требует, чтобы результат содержал только один элемент, но запросом должно быть возвращено Distinguished Name, а не любые аттрибуты со значением.</li>
<li><strong>ldapm</strong> - разрешает результату содержать более одного элемента; все их аттрибуты возвращаются запросом.</li>
</ul>
<p>Для <strong>ldap</strong> и <strong>ldapm</strong>, если запрос находит лишь входы без аттрибутов, Exim ведёт себя, как будто вхождения не найдены, и поиск неудачен. Формат данных, возвращаемых успешным поиском описаны в следующей секции. Сначала мы объясняем, как кодируются LDAP-запросы.</p>
</div>
</div>
<div class="section" id="ch09-14">
<span id="id14"></span><h2>Формат запросов LDAP<a class="headerlink" href="#ch09-14" title="Ссылка на этот заголовок">¶</a></h2>
<p>Запрос к LDAP имеет форму URL, как определено в :rfc:2255. Например, в конфигурации маршрутизатора <strong>redirect</strong>, могла бы быть такая установка:</p>
<div class="highlight-python"><pre>data = ${lookup ldap \
  {ldap:///cn=$local_part,o=University%20of%20Cambridge,\
  c=UK?mailbox?base?}}</pre>
</div>
<p>URL может начинаться с <strong>ldap</strong> или <strong>ldaps</strong>, если ваша библиотека LDAP поддерживает безопасные (шифрованные) LDAP-соединения. Второй из них гарантирует, что используются шифрованные подключения TLS.</p>
</div>
<div class="section" id="ch09-15">
<span id="id15"></span><h2>Квотирование (использование двойных кавычек и спецсимволов) в LDAP<a class="headerlink" href="#ch09-15" title="Ссылка на этот заголовок">¶</a></h2>
<p>В запросах LDAP требуются два уровня квотирования, первый - непосредвственно для LDAP, и второй, поскольку запрос LDAP представлен как URL. Кроме того, внутри LDAP-запроса, требуются два различных вида квотирования. Поэтому есть два различных, LDAP-специфичных, оператора квотирования.</p>
<p>Оператор <strong>quote_ldap</strong> спроектирован для использования на строках, являющихся частью спецификации фильтра. Концептуально, он, вначале, производит следующие преобразования строки:</p>
<div class="highlight-python"><pre>*   =&gt;   \2A
(   =&gt;   \28
)   =&gt;   \29
\   =&gt;   \5C</pre>
</div>
<p>в соответствии с <span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2254.html"><strong>RFC 2254</strong></a>. Результирующая строка квотируется согласно правилам для URL, т.е. все не алфавитно-цифровые символы, кроме:</p>
<div class="highlight-python"><pre>! $ ' - . _ ( ) * +</pre>
</div>
<p>конвертируются в их шастнадцатеричные значения, с предшествующим им символом процента. Например:</p>
<div class="highlight-python"><pre>${quote_ldap: a(bc)*, a&lt;yz&gt;; }</pre>
</div>
<p>превращается в</p>
<div class="highlight-python"><pre>%20a%5C28bc%5C29%5C2A%2C%20a%3Cyz%3E%3B%20</pre>
</div>
<p>Удалив квотирование URL, это (с начальным и конечным пустым пространством):</p>
<div class="highlight-python"><pre>a\28bc\29\2A, a&lt;yz&gt;;</pre>
</div>
<p>Оператор <strong>quote_ldap_dn</strong> спроектирован для использования на строках, являющихся частью базовых спецификаций DN, в запросех. Концептуально, вначале он конвертирует строку, вставляя обратный слэш перед любым из следующих символов:</p>
<div class="highlight-python"><pre>, + " \ &lt; &gt; ;</pre>
</div>
<p>Он также вставляет обратный слэш перед любыми пробелами или символом “#”, и перед конечными пробелами. (Правила находятся в <span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2253.html"><strong>RFC 2253</strong></a>.) Тогда результирующая строка квотирована согласно правилам для URL. Например:</p>
<div class="highlight-python"><pre>${quote_ldap_dn: a(bc)*, a&lt;yz&gt;; }</pre>
</div>
<p>будет</p>
<div class="highlight-python"><pre>%5C%20a(bc)*%5C%2C%20a%5C%3Cyz%5C%3E%5C%3B%5C%20</pre>
</div>
<p>Удалив квотирование URL, получится (с конечными пробелами)</p>
<div class="highlight-python"><pre>\ a(bc)*\, a\&lt;yz\&gt;\;\</pre>
</div>
<p>Есть некоторые дальнейшие комментарии о квотировании в разделе о аутентификации LDAP, ниже.</p>
</div>
<div class="section" id="ch09-16">
<span id="id16"></span><h2>Соединения LDAP<a class="headerlink" href="#ch09-16" title="Ссылка на этот заголовок">¶</a></h2>
<p>Подключение к серверу LDAP может быть через TCP/IP, или, когда используется OpenLDAP, через сокет UNIX. Пример, данный выше, не определяет сервер LDAP. Сервер, который доступен по TCP/IP, может быть задан в запросе, запуская его так:</p>
<div class="highlight-python"><pre>ldap://&lt;hostname&gt;:&lt;port&gt;/...</pre>
</div>
<p>Если порт (и предыдущее двоеточие) опущены, используется стандартный порт LDAP (389). Если в запросе не указан сервер, список серверов по умолчанию берётся из конфигурационного параметра <strong>ldap_default_servers</strong>.  Он предоставляет список серверов, разделённых двоеточиями, пробуемых по очереди, пока запрос не будет успешно обработан, или не произойдёт серьёзная ошибка. Успешная обработка или вернёт запрошенные данные, или укажет, что они не существуют. Серьёзные ошибки - синтаксические, или много значений, когда ожидается только одно. Ошибки, приводящие к пробе следующего сервера - сбои подключения, привязки, и таймауты.</p>
<p>Для каждого имени сервера, в списке, можно задать номер порта. Стандартный способ задания хоста и порта - использование двоеточия, как разделителя <span class="target" id="index-2"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc1738.html"><strong>RFC 1738</strong></a>). Поскольку <strong>ldap_default_servers</strong> - список значений разделённых двоеточиями, такие двоеточия должны быть удвоены. Например:</p>
<div class="highlight-python"><pre>ldap_default_servers = ldap1.example.com::145:ldap2.example.com</pre>
</div>
<p>Если <strong>ldap_default_servers</strong> незадана, библиотеке LDAP передаётся URL безбез имени сервера, и используется значение библиотеки по умолчанию(обычно - локальный компьютер).</p>
<p>Если вы используете библиотеку OpenLDAP, вы можете соединится с LDAP-сервером используя сокет UNIX, вместо подключения через TCP/IP. Это задаётся использованием <strong>ldapi</strong> вместо <strong>ldap</strong> в LDAP-запросах. Нижеследующее <a class="footnote-reference" href="#id22" id="id17">[2]</a>, применяется только в OpenLDAP. Если Exim скомпилен с поддержкой различных LDAP-библиотек, эта возможность недоступна.</p>
<p>Для этого типа соединения, вместо имени хоста, требуется имя-путь сокета, и номер порта неуместен. Имя-путь может быть указано как элемент в <strong>ldap_default_servers</strong>, или встроено в запрос. В первом случае, вы будете иметь настройки типа таких:</p>
<div class="highlight-python"><pre>ldap_default_servers = /tmp/ldap.sock : backup.ldap.your.domain</pre>
</div>
<p>Когда путь с именем указываются в запросе, вы должны заменить прямые слэши последовательностью <tt class="docutils literal"><span class="pre">%2F</span></tt> для соблюдения синтаксиса LDAP URL. Например:</p>
<div class="highlight-python"><pre>${lookup ldap {ldapi://%2Ftmp%2Fldap.sock/o=...</pre>
</div>
<p>Когда Exim производит поиск LDAP, и находит, что “имя хоста” (“hostname”) - реальный путь к сокету, он использует код сокета UNIX, даже если запрос задаёт использование <tt class="docutils literal"><span class="pre">ldap</span></tt> или <tt class="docutils literal"><span class="pre">ldaps</span></tt>. В частности, для соединения с сокетом не используется шифрование. Это поведение означает, что вы можете использовать настройки, например, <strong>ldap_default_servers</strong>, в примере выше, с традиционными  <tt class="docutils literal"><span class="pre">ldap</span></tt> или <tt class="docutils literal"><span class="pre">ldaps</span></tt>, и эо будет работать. Вначале, Exim пробует соединиться через через сокет UNIX; если это не удаётся, он пробует подключиться по TCP/IP к резервному хосту.</p>
<p>Если в запросе задаётся явный тип <tt class="docutils literal"><span class="pre">ldapi</span></tt>, при указанном имени хоста, диагностируется ошибка. Однако, если есть другие элементы в <strong>ldap_default_servers</strong>, пробуются они. Другими словами:</p>
<blockquote>
<div><ul class="simple">
<li>Использование пути к сокету с <tt class="docutils literal"><span class="pre">ldap</span></tt> или <tt class="docutils literal"><span class="pre">ldaps</span></tt> вызывает использование интерфейса сокета UNIX.</li>
<li>Использование <tt class="docutils literal"><span class="pre">ldapi</span></tt> с именем хоста вызывает ошибку.</li>
</ul>
</div></blockquote>
<p>Использование <tt class="docutils literal"><span class="pre">ldapi</span></tt> без хоста или пути в запросе, и без установки <strong>ldap_default_servers</strong>, делает то, что библиотека делает по умолчанию.</p>
</div>
<div class="section" id="ch09-17">
<span id="id18"></span><h2>Аутентификация LDAP и управляющая информация<a class="headerlink" href="#ch09-17" title="Ссылка на этот заголовок">¶</a></h2>
<p>Синтаксис LDAP URL не предоставляет пути передачи аутентификационной и иной управляющей информации на сервер. Чтобы сделать это возможным, URL в запросе LDAP может предшествоваться любым числом установок “&lt;name&gt;=&lt;value&gt;”, разделённых пробелами. Если значение содержит пробелы, они должны быть помещены в двойные кавычки, и, когда используются двойные кавычки, надо использовать обратный слэш, как обычно. Распознаются следующие имена:</p>
<div class="highlight-python"><pre>DEREFERENCE     установить параметр разименования
NETTIME         установить таймаут сетевой операции
USER            установить DN для аутентификации связи LDAP
PASS            установить пароль для аутентификации связи LDAP
REFERRALS       установить ссылочный параметр
SIZE            установить ограничение числа возвращаемых входов
TIME            установить таймаут запроса</pre>
</div>
<p>Значение параметра <tt class="docutils literal"><span class="pre">DEREFERENCE</span></tt> должно быть одним из слов “never”, “searching”, “finding”, или “always”. Значение параметра <tt class="docutils literal"><span class="pre">REFERRALS</span></tt> может быть “follow” (по-умолчанию) или “nofollow”. Последний вариант останавливает LDAP библиотеку от попыток следования ссылкам, отданным LDAP-сервером.</p>
<p>Имя <tt class="docutils literal"><span class="pre">CONNECT</span></tt> - устаревшее имя <tt class="docutils literal"><span class="pre">NETTIME</span></tt>, сохраненноё для обратной совместимости. Этот таймаут (заданный как число секунд) устанавливатся с клиентской стороны, для операций, который могут быть выполнены по сети. Специально, это применяется к сетевым соединениям и вызовам функции <em>ldap_result()</em>. Если значение больше чем ноль, используется <tt class="docutils literal"><span class="pre">LDAP_OPT_NETWORK_TIMEOUT</span></tt>, если задано в заголовках LDAP (OpenLDAP), или, если в заголовках LDAP (Netscape SDK 4.1) задано <tt class="docutils literal"><span class="pre">LDAP_X_OPT_CONNECT_TIMEOUT</span></tt>. Нулевое значение вызывает явную установку “no timeout” для Netscape SDK; для OpenLDAP никакого действия не происходит.</p>
<p>Параметр <tt class="docutils literal"><span class="pre">TIME</span></tt> (также число секунд) передаётся на сервер для установки серверных ограничений на время потраченное на поиск.</p>
<p>Вот пример запроса LDAP в поиске Exim`a, использующем некотрые из этих значений. Это - одна строка, перенесённая, чтобы поместиться на странице:</p>
<div class="highlight-python"><pre>${lookup ldap
  {user="cn=manager,o=University of Cambridge,c=UK" pass=secret
  ldap:///o=University%20of%20Cambridge,c=UK?sn?sub?(cn=foo)}
  {$value}fail}</pre>
</div>
<p>Кодирование пробелов, как <tt class="docutils literal"><span class="pre">%20</span></tt> - из URL, его нелььзя делать для каких-либо вспомогательных данных. Конфигурационные настройки Exim`a, включающие поиски содержащие информацию о пароле, необходимо предварять “hide”, чтобы предотвратить возможность увидеть эти значения не-административными пользователями, при использовании параметра командной строки <strong>-bP</strong>.</p>
<p>Вспомогательные данные могут быть даны в любом порядке. По умолчанию - таймаут отсутсвует (используется системный таймаут), нет пользователя или пароля, нет ограничений на число возвращённых значений, и нет ограничений по времени запроса.</p>
<p>Когда DN квотирован в <tt class="docutils literal"><span class="pre">USER=</span></tt> setting для LDAP аутентификации, Exim удаляет любое URL-квотирование, которое может быть до LDAP. Очевидно, некоторые библиотеки делают это для себя, но некоторые нет. Удаление URL-квотирование даёт два преимущества:</p>
<ul class="simple">
<li>Это позволяет использовать тоже самое раскрытие <strong>quote_ldap_dn</strong> для <tt class="docutils literal"><span class="pre">USER=</span></tt> DNs, что и для DNs внутри фактических запросов.</li>
<li>Это разрешает пробелы внутри <tt class="docutils literal"><span class="pre">USER=</span></tt> DNs.</li>
</ul>
<p>Например, настройка типа</p>
<div class="highlight-python"><pre>USER=cn=${quote_ldap_dn:$1}</pre>
</div>
<p>должна работать, даже если <tt class="docutils literal"><span class="pre">$1</span></tt> содержит пробелы.</p>
<p>Раскрытые данные для <tt class="docutils literal"><span class="pre">PASS=</span></tt> value должны быть квотированы с использованием оператора раскрытия <strong>quote</strong>, а не оператора квотирования LDAP.  Единственная причина, по которой это поле нуждается в квотировании, состоит в том, чтобы гарантировать его соответствие синтаксису Exim`a, который не разрешает пробелы вне кавычек. Например:</p>
<div class="highlight-python"><pre>PASS=${quote:$3}</pre>
</div>
<p>Аутентификационный механизм LDAP может использоваться для прокерки паролей, как часть SMTP-аутентификации. Смотрите условие ракрытия строки <strong>ldapauth</strong> в главе <a class="reference internal" href="ch11.html#ch11-00"><em>11</em></a>.</p>
</div>
<div class="section" id="ch09-18">
<span id="id19"></span><h2>Формат данных возвращённых LDAP<a class="headerlink" href="#ch09-18" title="Ссылка на этот заголовок">¶</a></h2>
<p>Типы поиска <strong>ldapdn</strong> возвращают Distinguished Name (отличительное имя) из единственного элемента, как последовательность значений, например:</p>
<div class="highlight-python"><pre>cn=manager, o=University of Cambridge, c=UK</pre>
</div>
<p>Тип поиска <strong>ldap</strong> выводит ошибку, если более одного элемента соответствует фильтру поиска, тогда как <strong>ldapm</strong> разрешает этот случай, и вставляет новую строку в результат, до данных от различных входов. Это возможно для многочисленных значений возвращённых для обоих <strong>ldap</strong> и <strong>ldapm</strong>, но в первом случае вы знаете, что независимо от возвращённого значения, исходили из одиночного вхождения в директории.</p>
<p>В общем случае, где вы задаёте один аттрибут в вашем LDAP-запросе, результат не квотируется, и не содержит имя атрибута. Если атрибут имеет множественные значения, они разделются запятыми.</p>
<p>Если вы определяете множественные тарибуты, результат содержит разделённые пробелами, квотированные строки, каждая с предшествующим именем атрибута и символом равно. В пределах кавычек, символ двойной кавычки, обратного слэша и новой строки экранируется обратным слэшем, и запятые используются для разделения многочисленных значений атрибута. В части для экранирования, строка внутри кавычекпринимает такую же форму как вывод, когда запрашивается единственный атрибут. Если никакие атрибуты не заданы, это тоже самое, что и задание всех атрибутов.</p>
<p>Это - некотрые примеры формата вывода. Превая строка каждой пары - запрос LDAP, и вторая - возвращённые данные. Атрибут называемый <strong>attr1</strong> имеет два занчения, тогда как <strong>attr2</strong> - лишь одно:</p>
<div class="highlight-python"><pre>ldap:///o=base?attr1?sub?(uid=fred)
value1.1, value1.2

ldap:///o=base?attr2?sub?(uid=fred)
value two


ldap:///o=base?attr1,attr2?sub?(uid=fred)
attr1="value1.1, value1.2" attr2="value two"

ldap:///o=base??sub?(uid=fred)
objectClass="top" attr1="value1.1, value1.2" attr2="value two"</pre>
</div>
<p>Оператор <strong>extract</strong> в раскытиях строки может быть использован для выбора индивидуальных полей из данных, состоящих из пар <em>key=value</em>. Вы модете использовать параметр Exim`a <strong>-be</strong>, для хапуска теста раскрытия и таким образом проверить результаты поиска в LDAP.</p>
</div>
<div class="section" id="nis">
<span id="ch09-19"></span><h2>Дополнительные сведения о NIS+<a class="headerlink" href="#nis" title="Ссылка на этот заголовок">¶</a></h2>
<p>Запросы NIS+ состоят из <em>индексного имени</em> (<em>indexed name</em>) NIS+, сопровождаемого необязательным двоеточием и именем поля. Если это дано, разультат успешного запроса - содержимое именованного поля; иначе - результат состоит из объединённых пар <em>field-name=field-value</em>, разделённых пробелами. пустые значения и значения содержащие пробелы помещаются в двойные кавычки. Например, запрос</p>
<div class="highlight-python"><pre>[name=mg1456],passwd.org_dir</pre>
</div>
<p>мог бы вернуть строку</p>
<div class="highlight-python"><pre>name=mg1456 passwd="" uid=999 gid=999 gcos="Martin Guerre"
home=/home/mg1456 shell=/bin/bash shadow=""</pre>
</div>
<p>(разбито на две строки чтобы пометиться на странице), тогда как</p>
<div class="highlight-python"><pre>[name=mg1456],passwd.org_dir:gcos</pre>
</div>
<p>вернул бы лишь</p>
<div class="highlight-python"><pre>Martin Guerre</pre>
</div>
<p>без кавычек. Поиск NIS+ неудачен если NIS+ возвращает больше одного элемента таблицы для данного индексного ключа. Эффект оператора раскрытия <strong>quote_nisplus</strong> удваивает любые символы кавычек внутри текста.</p>
</div>
<div class="section" id="sql">
<span id="ch09-20"></span><h2>Поиски SQL<a class="headerlink" href="#sql" title="Ссылка на этот заголовок">¶</a></h2>
<p>Exim может поддерживать поиски в InterBase, MySQL, Oracle, PostgreSQL, и SQLite базах данных. Запросы для этих БД содержат SQL-выражения, таким образом, пример мог бы быть таким</p>
<div class="highlight-python"><pre>${lookup mysql{select mailbox from users where id='userx'}\
  {$value}fail}</pre>
</div>
<p>Если результат запроса содержит более одного поля, данные возвращаются для каждого поля, предшествуеиые его именем, таким образом, результат</p>
<div class="highlight-python"><pre>${lookup pgsql{select home,name from users where id='userx'}\
  {$value}}</pre>
</div>
<p>мог бы быть</p>
<div class="highlight-python"><pre>home=/home/userx name="Mister X"</pre>
</div>
<p>Пустые значения, и значения содержащие пробелы помещаются в двойные кавычки, внутренние кавычки экранируются обратным слэшем. Если результат запроса содержит лишь одно поле, значение возвращется дословно, без имени поля, например:</p>
<div class="highlight-python"><pre>Mister X</pre>
</div>
<p>Если результат запроса приводит более чем к одной строке, они все объединяются, с новой строкой между данными для каждой строки.</p>
</div>
<div class="section" id="mysql-postgresql-oracle-interbase">
<span id="ch09-21"></span><h2>Дополнительные сведения о MySQL, PostgreSQL, Oracle, и InterBase<a class="headerlink" href="#mysql-postgresql-oracle-interbase" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если используются какие-либо поиски в MySQL, PostgreSQL, Oracle, или InterBase, то должна быть установлен параметр <strong>mysql_servers</strong>, <strong>pgsql_servers</strong>, <strong>oracle_servers</strong> или <strong>ibase_servers</strong> (соответственно) в виде списка информации о сервере, разделённого двоеточиями. (Только для MySQL и PostgreSQL, глобальный параметр не должен быть установлен, если если все запросы содержат собственную информацию о сервере - смотрите раздел <a class="reference internal" href="#ch09-22"><em>9.22</em></a>) Каждый элемент в списке - разделённый слэшами список четырёх пунктов: имя хоста, имя БД, имя пользователя и пароль. В случае Oracle, поле имени хоста используется для “имени сервиса” (“service name”), поле имени базы данных не используется, и должно быть пустым. Например:</p>
<div class="highlight-python"><pre>hide oracle_servers = oracle.plc.example//userx/abcdwxyz</pre>
</div>
<p>Поскольку данные пароля секретны, вы всегда должны предшествовать настройку словом “hide”, для предотвращения просмотра установки неадминистративными пользователями при использовании параметра <strong>-bP</strong>. Вот пример, где перечислены два сервера MySQL:</p>
<div class="highlight-python"><pre>hide mysql_servers = localhost/users/root/secret:\
                     otherhost/users/root/othersecret</pre>
</div>
<p>Для MySQL и PostgreSQL, хост может быть задан как <em>&lt;name&gt;:&lt;port&gt;</em>, но т.к. это список значений разделённых двоеточиями, то оно должно быть удвоено. Для каждого запроса, эти параметры групп проверяются, в порядке успешности соединенией и запросов. Разультат запроса может такой, что данные не найдены, но сам запрос успешен. Другими словами, список серверов предоставляет средсво резервирования, а не список иных мест для поиска.</p>
<p>Операторы раскрытия <strong>quote_mysql</strong>, <strong>quote_pgsql</strong> и <strong>quote_oracle</strong> конвертируют новую строку, таб, возврат каретки и обратный слэш в <tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\t</span></tt>, <tt class="docutils literal"><span class="pre">\r</span></tt> и <tt class="docutils literal"><span class="pre">\b</span></tt> соответственно, и символы одиночной кавычки, двойной кавычки и обратного слэша экранируются обратным слэшем. Оператор раскрытия <strong>quote_pgsql</strong>, кроме того, экранирует символы процента и подчёркивания. Это нельзя делать для MySQL, поскольку эти символы экранирования не распознаются в контексте, где они они не экранируют специальные символы.</p>
</div>
<div class="section" id="ch09-22">
<span id="id20"></span><h2>Задание сервера в запросе<a class="headerlink" href="#ch09-22" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для поиска в MySQL и PostgreSQL (но, в данный момент не для Oracle и InterBase), возможно задать список серверов в каждом отдельном запросе. Это производиться путём создания такого начала запроса:</p>
<div class="highlight-python"><pre>servers=server1:server2:server3:...;</pre>
</div>
<p>Каждый элемент списка может иметь одну из двух форм:</p>
<ol class="arabic simple">
<li>Если он не содержит слэшей, то предполагается что это просто имя хоста. В соответствующей глобального параметра (<strong>mysql_servers</strong> или <strong>pgsql_servers</strong>) ищется хост с таким же именем, последующие параметры (база данных, пользователь, пароль) берутся оттуда.</li>
<li>Если в нём содержиться любой слэш, он принимается как полный набор параметров.</li>
</ol>
<p>Список серверов используется точно таким же способом как и глобальный список. Как только происходит успешное соединение с сервером и запрос успешно выполняется, происходит обработка поиска.</p>
<p>Эта особенность предназначена для использования в ситуациях master/slave, когда происходят обновления и вам предпочтительней обновить master, нежели чем slave. Если master в спике как запасной сервер для чтения, у вас могут быть глобальные установки типа таких:</p>
<div class="highlight-python"><pre>mysql_servers = slave1/db/name/pw:\
                slave2/db/name/pw:\
                master/db/name/pw</pre>
</div>
<p>В запросе обновления вы должны написать:</p>
<div class="highlight-python"><pre>${lookup mysql{servers=master; UPDATE ...} }</pre>
</div>
<p>Этот запрос будет послан только на мастер-сервер. Если, в другом случае, мастер не используется для чтения, и не присутствует в глобального параметра, вы всё равно можете провести обновление путём запроса такого вида:</p>
<div class="highlight-python"><pre>${lookup pgsql{servers=master/db/name/pw; UPDATE ...} }</pre>
</div>
</div>
<div class="section" id="mysql">
<span id="ch09-23"></span><h2>Специальные возможности MySQL<a class="headerlink" href="#mysql" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для MySQL, пустое имя хоста, или использование “localhost” в <strong>mysql_servers</strong> вызывает соединение с сервером на локальном хосте через сокет UNIX. Альтернативный сокет может быть указан в круглых скобках. полный синтаксис каждого элемента в <strong>mysql_servers</strong> таков:</p>
<div class="highlight-python"><pre>&lt;hostname&gt;::&lt;port&gt;(&lt;socket name&gt;)/&lt;database&gt;/&lt;user&gt;/&lt;password&gt;</pre>
</div>
<p>Любая из трёх частей первого поля может быть опущена. Для нормального использования на локальном хосте можно отсавить пробел, или установить лишь “localhost”.</p>
<p>Нет необходимости в указании БД, - если она тут отсутсвует, то должна быть дана в запросах.</p>
<p>Если запрос MySQL не возвращает никаких данных (команды insert, update, или delete), результат поиска - число затронутых строк.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Это может ввести в заблуждение. Если обновление ничего, фактически, не меняет (например, устанаваливая поле на то же самое значение), результат - ноль, поскольку нет затронутых строк.</p>
</div>
</div>
<div class="section" id="postgresql">
<span id="ch09-24"></span><h2>Специальные возможности PostgreSQL<a class="headerlink" href="#postgresql" title="Ссылка на этот заголовок">¶</a></h2>
<p>Поиски в PostgreSQL также могут использовать сокет UNIX для соединения с БД. Обычно, это быстрей, и стоит меньше процессорного времени, чем подключение по TCP/IP. Однако он может использоваться лишь в случае, если сервер БД работает на той же самой машине, что и почтовый сервер. Конфигурационная строка для PostgreSQL, через сокет UNIX, выглядит так:</p>
<div class="highlight-python"><pre>hide pgsql_servers = (/tmp/.s.PGSQL.5432)/db/user/password : ...</pre>
</div>
<p>Другими словами, вместо имени хоста даётся путь к сокету. путь заключён в круглые скобки так, чтобы его прямые слэши не были визуально перепутаны с разделителями других параметров сервера.</p>
<p>Если запрос PostgreSQL не возвращает никаких данных (команды insert, update, или delete), результат поиска - число затронутых строк.</p>
</div>
<div class="section" id="sqlite">
<span id="ch09-25"></span><h2>Дополнительные сведения о SQLite<a class="headerlink" href="#sqlite" title="Ссылка на этот заголовок">¶</a></h2>
<p>SQLite отличается от других поисков SQL, поскольку требуется имя файла, в дополнение к SQL-запросу. БД SQLite - один файл, и нет демона, как в других БД. Интерфейс Exim`a требует чтобы имя файла, как абсолютный путь, было задано в начале запроса. Оно отделяется от запроса пустым пространством. Это означает что путь и имя файла не могут содержать пустые символы. Вот пример раскрытия поиска:</p>
<div class="highlight-python"><pre>${lookup sqlite {/some/thing/sqlitedb \
  select name from aliases where id='userx';}}</pre>
</div>
<p>В списке, похожий синтаксис. Например:</p>
<div class="highlight-python"><pre>domainlist relay_domains = sqlite;/some/thing/sqlitedb \
   select * from relays where ip='$sender_host_address';</pre>
</div>
<p>Единственный символ, затрагиваемый оператором <strong>quote_sqlite</strong> - символ одиночной кавычки, которую он удваивает.</p>
<p>Библиотека SQLite обрабатывает множественные одновременные доступы к БД внутренне. Множественные чтения разрешены, но лишь один процесс может производить обновление. Попытки обращения к БД, во время обновления, отклоняются после таймаута ожидания, в течение которого библиотека SQLite ждёт освобождения блокировки. В Exim, таймаут по умолчанию установлен в 5 секунд, но это может быть изменено с помощью параметра <strong>sqlite_lock_timeout</strong>.</p>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>короче, не нужны они - прим. lissyara</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[2]</a></td><td>имеется ввиду - про <strong>ldapi</strong> - прим. lissyara</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Содержание</a></h3>
  <ul>
<li><a class="reference internal" href="#">Поиски в файлах и базах данных</a><ul>
<li><a class="reference internal" href="#ch09-01">Примеры различных синтаксисов поиска</a></li>
<li><a class="reference internal" href="#ch09-02">Типы поиска</a></li>
<li><a class="reference internal" href="#ch09-03">Одноключевые типы поиска</a></li>
<li><a class="reference internal" href="#ch09-04">Типы поиска в стиле запроса</a></li>
<li><a class="reference internal" href="#ch09-05">Временные ошибки в поисках</a></li>
<li><a class="reference internal" href="#ch09-06">Значения по умолчанию в одноключевых поисках</a></li>
<li><a class="reference internal" href="#ch09-07">Частичное совпадение в одноключевых поисках</a></li>
<li><a class="reference internal" href="#ch09-08">Кэширование поиска</a></li>
<li><a class="reference internal" href="#ch09-09">Экранирование данных поиска</a></li>
<li><a class="reference internal" href="#dnsdb">Дополнительные сведения о dnsdb</a></li>
<li><a class="reference internal" href="#ch09-11">Псевдо-“dnsdb” типы записей</a></li>
<li><a class="reference internal" href="#ch09-12">Множественные поиски dnsdb</a><ul>
<li><a class="reference internal" href="#ldap">Дополнительные сведения о LDAP</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ch09-14">Формат запросов LDAP</a></li>
<li><a class="reference internal" href="#ch09-15">Квотирование (использование двойных кавычек и спецсимволов) в LDAP</a></li>
<li><a class="reference internal" href="#ch09-16">Соединения LDAP</a></li>
<li><a class="reference internal" href="#ch09-17">Аутентификация LDAP и управляющая информация</a></li>
<li><a class="reference internal" href="#ch09-18">Формат данных возвращённых LDAP</a></li>
<li><a class="reference internal" href="#nis">Дополнительные сведения о NIS+</a></li>
<li><a class="reference internal" href="#sql">Поиски SQL</a></li>
<li><a class="reference internal" href="#mysql-postgresql-oracle-interbase">Дополнительные сведения о MySQL, PostgreSQL, Oracle, и InterBase</a></li>
<li><a class="reference internal" href="#ch09-22">Задание сервера в запросе</a></li>
<li><a class="reference internal" href="#mysql">Специальные возможности MySQL</a></li>
<li><a class="reference internal" href="#postgresql">Специальные возможности PostgreSQL</a></li>
<li><a class="reference internal" href="#sqlite">Дополнительные сведения о SQLite</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ch08.html" title="предыдущая глава">Регулярные выражения</a></li>
      <li>Next: <a href="ch10.html" title="следующая глава">Списки доменов, узлов, адресов и локальных частей [почтового] адреса</a></li>
  </ul></li>
</ul>
  <h3>На этой странице</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ch09.txt"
           rel="nofollow">Показать исходный текст</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Быстрый поиск</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Искать" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Введите слова для поиска или имя модуля, класса или функции.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2011, Exim Maintainers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>