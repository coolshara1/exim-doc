
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Шифрование соединений с использованием TLS/SSL &mdash; Specification of the Exim Mail Transfer Agent 4.70 documentation</title>
    
    <link rel="stylesheet" href="_static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.70',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Specification of the Exim Mail Transfer Agent 4.70 documentation" href="index.html" />
    <link rel="next" title="Списки Контроля Доступа" href="ch40.html" />
    <link rel="prev" title="Аутентификатор spa" href="ch38.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="_static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch40.html" title="Списки Контроля Доступа"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch38.html" title="Аутентификатор spa"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Specification of the Exim Mail Transfer Agent 4.70 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tls-ssl">
<span id="ch39-00"></span><h1>Шифрование соединений с использованием TLS/SSL<a class="headerlink" href="#tls-ssl" title="Ссылка на этот заголовок">¶</a></h1>
<p>Поддержка TLS (Transport Layer Security), прежде известной как SSL (Secure Sockets Layer), осуществлена с использованием библиотеки OpenSSL или библиотеки GnuTLS (Exim требует GnuTLS, версии 1.0 или более позднего). В дистрибутиве Exim&#8217;a нет никакого кода для непосредственного осуществления TLS. Для его использования, вы должны инсталлировать OpenSSL или GnuTLS, и, затем, собрать версию Exim&#8217;a в которую включена поддержка TLS (смотрите раздел <a class="reference internal" href="ch04.html#ch04-07"><em>4.7</em></a>). Также, вы должны понимать базовые концепции шифрования на организационном уровне, и, в частности, способы использования публичных ключей, частных ключей, и сертификатов.</p>
<p><span class="target" id="index-0"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc3207.html"><strong>RFC 3207</strong></a> задаёт, как SMTP-соединения могут использовать шифрование. Как только установлено подключение, клиент даёт команду STARTTLS. Если сервер её принимает, клиент и сервер договариваются о механизме шифрования. Если договорённость успешна, данные, впоследствии передаваемые между ними, - зашифрованы.</p>
<p>ACL Exim&#8217;a позволяют детектировать, зашифрован текущий сеанс, или нет, и, таким образом, какой метод шифрования используется, предоставил ли клиент сертификат, и был ли сертификат проверен. Это позволяет серверу Exim принимать или отклонять определённые команды основанные на состоянии шифрования.</p>
<div class="admonition warning">
<p class="first admonition-title">Предупреждение</p>
<p class="last">Определённые типы межсетевых экранов и определённые типы антивирусных продуктов могут прерывать  TLS-соединения. Вам необходимо выключить SMTP-сканирование для этих продуктов, чтобы TLS заработало.</p>
</div>
<div class="section" id="ssmtp-smtps">
<span id="ch39-01"></span><h2>Поддержка для наследственного ssmtp (или smtps) протокола<a class="headerlink" href="#ssmtp-smtps" title="Ссылка на этот заголовок">¶</a></h2>
<p>Ранние воплощения шифрованного SMTP использовали иной порт TCP, вместо обычного, и ожидали, что переговоры о шифровании начнутся немедленно, вместо ожидания команды клиента STARTTLS, использующего стандартный SMTP-порт. Протокол назывался “ssmtp” или “smtps”, и для этой цели был выделен 465 порт.</p>
<p>Этот подход был оставлен, когда было стандартизовано шифрованное SMTP, но, всё ещё есть клиенты, использующие его по наследству. Exim поддерживает этих клиентов путём глобального параметра <strong>tls_on_connect_ports</strong>. Её значение должно быть списком номеров портов; обычное использование - таково:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tls_on_connect_ports</span> <span class="o">=</span> <span class="mi">465</span>
</pre></div>
</div>
<p>Номер порта, определяемый этим параметром, применяется ко всем SMTP-соединениям, и через демона, и через <em>inetd</em>. Вам всё ещё необходимо задавать все порты используемые демоном (путём установки <strong>daemon_smtp_ports</strong> или <strong>local_interfaces</strong> или параметра командной строки <strong>-oX</strong>), поскольку <strong>tls_on_connect_ports</strong> не добавляет дополнительного порта, скорее, она определяет иное поведение на порту определённом в другом месте.</p>
<p>Также, есть параметр командной строки <strong>-tls-on-connect</strong>. Он переопределяет <strong>tls_on_connect_ports</strong>; он вызывает наследование поведения для всех портов.</p>
</div>
<div class="section" id="openssl-gnutls">
<span id="ch39-02"></span><h2>OpenSSL против GnuTLS<a class="headerlink" href="#openssl-gnutls" title="Ссылка на этот заголовок">¶</a></h2>
<p>Первая поддержка TLS в Exim`e была осуществлена с использованием OpenSSL. Поддержка GnuTLS последовала позднее, когда была выпущена первая версия GnuTLS. Для сборки Exim&#8217;a с использованием GnuTLS, вам необходимо установить</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">USE_GNUTLS</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>в <em>Local/Makefile</em>, в дополнение к</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SUPPORT_TLS</span><span class="o">=</span><span class="n">yes</span>
</pre></div>
</div>
<p>Также, вы должны установить TLS_LIBS и TLS_INCLUDE соответственно, так, чтобы были найдены файлы заголовков и библиотеки для GnuTLS.</p>
<p>Есть некоторые отличия при использовании GnuTLS вместо OpenSSL:</p>
<ul class="simple">
<li>Параметр <strong>tls_verify_certificates</strong> должна содержать имя файла, а не имя директории (для OpenSSL - это может быть любым).</li>
<li>Параметр <strong>tls_dhparam</strong> - игнорируется, поскольку ранние версии GnuTLS не имели средств для изменения параметров Diffie-Hellman. Я понимаю, что это изменилось, но Exim не был обновлён для предоставления этого средства.</li>
<li>Строка “выдающегося имени” (DN) сообщаемая библиотекой OpenSSL использует слэш для разделения полей; GnuTLS использует использует запятые, в соответствии с <span class="target" id="index-1"></span><a class="rfc reference external" href="http://tools.ietf.org/html/rfc2253.html"><strong>RFC 2253</strong></a>. Это вызываeтся значением переменной $tls_peerdn.</li>
<li>OpenSSL идентифицирует шифр используя дефисы, как разделители, например: DES-CBC3-SHA. GnuTLS использует подчёркивания, например: RSA_ARCFOUR_SHA. Что хуже - OpenSSL жалуется на присутствие символов подчёркивания в списке шифров. Чтобы упростить жизнь, Exim заменяет подчёркивания на дефисы для OpenSSL, и дефисы на подчёркивания для GnuTLS при обработке списков шифров в параметре <strong>tls_require_ciphers</strong> (глобальный параметр и транспортный параметр <strong>smtp</strong>).</li>
<li>Параметр <strong>tls_require_ciphers</strong> работают иначе, как описано в разделе <a class="reference internal" href="#ch39-04"><em>39.4</em></a> и <a class="reference internal" href="#ch39-05"><em>39.5</em></a>.</li>
</ul>
</div>
<div class="section" id="gnutls">
<span id="ch39-03"></span><h2>Вычисление параметра GnuTLS<a class="headerlink" href="#gnutls" title="Ссылка на этот заголовок">¶</a></h2>
<p>GnuTLS использует параметры D-H, которые требуют для вычисления существенного времени. Неблагоразумно вычислять их заново для каждой сессии TLS. Поэтому, Exim сохраняет эти данные в файле, в своей директории спула, называемой <em>gnutls-params</em>. Файл принадлежит пользователю Exim&#8217;a и читаем лишь его владельцем. Каждый процесс Exim&#8217;a, который запускает GnuTLS читает параметры D-H из этого файла. Если файл не существует, первый процесс Exim&#8217;a, которому он нужен, вычисляет данные и записывает их во временный файл, переименовываемый по завершении. Не имеет значения, если несколько процессов Exim&#8217;a делают это одновременно (кроме траты некоторых ресурсов). Как только файл помещён на место, новый процессы Exim&#8217;a немедленно начинают его использовать.</p>
<p>Для максимальной безопасности, параметры, которые сохраняются в этом файле, периодически, должны быть повторно вычислены, частота зависит от уровня вашей параноидальности. Упорядочивание этого - принципиально просто; просто удалите файл, когда вы хотите вычислить новое значение. Однако, могут быть проблемы. Для вычисления новых параметров необходимы случайные числа, и они берутся из <em>/dev/random</em>. Если система не очень активна, <em>/dev/random</em> может задержать возврат данных, пока не будет доступно достаточно хаоса. Это может вызывать зависание Exim&#8217;a на довольно существенное время, вызывая таймауты для входящих соединений.</p>
<p>Решение - создавать параметры снаружи Exim&#8217;a. Они сохраняются в <em>gnutls-params</em> в формате PEM, что означает, что они могут быть созданы внешне, используя команду <em>certtool</em>, которая является частью GnuTLS.</p>
<p>Для замены параметров новыми, вместо удаления файла и разрешения Exim`y пересоздать его, вы можете создавать новые параметры используя <em>certtool</em>, и, после завершения, заменить файл кэша Exim&#8217;a путём переименования. Уместные команды - что то типа этого:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># rm -f new-params</span>
<span class="c"># touch new-params</span>
<span class="c"># chown exim:exim new-params</span>
<span class="c"># chmod 0400 new-params</span>
<span class="c"># certtool --generate-privkey --bits 512 &gt;new-params</span>
<span class="c"># echo &quot;&quot; &gt;&gt;new-params</span>
<span class="c"># certtool --generate-dh-params --bits 1024 &gt;&gt; new-params</span>
<span class="c"># mv new-params gnutls-params</span>
</pre></div>
</div>
<p>Если Exim никогда не создает параметры самостоятельно, возможность остановки - удалена <a class="footnote-reference" href="#id9" id="id1">[1]</a>.</p>
</div>
<div class="section" id="openssl">
<span id="ch39-04"></span><h2>Требование специфических шифров в OpenSSL<a class="headerlink" href="#openssl" title="Ссылка на этот заголовок">¶</a></h2>
<p>В библиотеке OpenSSL есть функция, которая может передавать список наборов шифров до того, как имеет место переговор о шифре. Этим определяется, какие шифры доступны. Список - разделён двоеточиями, и может содержать имена типа DES-CBC3-SHA. Exim передаёт раскрытое значение <strong>tls_require_ciphers</strong> напрямую этому вызову функции. Следующее цитирование документации OpenSSL определяет, какие формы элементов допустимы в строке шифра:
* Он может состоять из одного шифра, типа RC4-SHA.
* Он может представлять список шифров содержащих определённый алгоритм, или шифры определённого типа. Например, SHA1 представляет все шифры используя алгоритм SHA1 и SSLv3 представляет все алгоримы SSL v3.
* Списки наборов шифров могут быть объединены в одну строку шифра, используя символ “+”. Это используется как логическая операция “и”. Например, SHA1+DES представляет все наборы шифров содержащие алгоритмы SHA1 и DES.</p>
<p>Каждой строке шифра, произвольно, может предшествовать один из символов “!” или “-” или “+”.
* Если используется “!” - шифр удаляется из списка. Удалённые шифры не могут вновь появляться в списке, даже если они явно заявлены.
* Если используется “-”, шифр удаляется из списка, но некоторые, или все шифры могут быть добавлены последующими параметрами позднее.
* Если используется “+”, шифр перемещается в конец списка. Этот параметр не добавляет новых шифров; она лишь перемещает существующие.
* Если не присутствует ни один из этих символов, строка интерпретируется как список шифров, который будет добавлен к текущему привилегированному списку. Если список включает какие-то шифры, которые уже присутствуют, они будут проигнорированы: т.е. они не будут перемещены в конец списка.</p>
</div>
<div class="section" id="ch39-05">
<span id="id2"></span><h2>Специфические шифры или другие параметры требующиеся в GnuTLS<a class="headerlink" href="#ch39-05" title="Ссылка на этот заголовок">¶</a></h2>
<p>Библиотека GnuTLS позволяет вызывающему определить список разрешённых методов обмена ключами, главный шифрующий алгоритм, алгоритмы MAC и протоколы. К несчастью, эти списки цифровые, и библиотека не имеет функций для преобразования имён в номера. Поэтому, список распознаваемых имён собран в приложение. Разрешённые методы обмена ключами, шифры, и алгоритмы MAC могут использоваться в любой комбинации с формой шифрования. Это - отличие от OpenSSL, где полное имя шифрования передаётся её управляющей функции.</p>
<p>Для совместимости с OpenSSL, параметр <strong>tls_require_ciphers</strong> может быть установлен в полное имя шифра, такое как RSA_ARCFOUR_SHA, но для GnuTLS этот параметр контролирует только алгоритм шифрования. Exim ищет каждый элемент в списке для имени доступного алгоритма. Например, если список содержит RSA_AES_SHA, тогда распознаётся AES, и поведение точно такое же как если задан просто AES.</p>
<p>Есть дополнительные параметры с именами <strong>gnutls_require_kx</strong>, <strong>gnutls_require_mac</strong>, и <strong>gnutls_require_protocols</strong> которые могут использоваться для ограничения методов обмена ключами, алгоритмов MAC, и протоколов, соответственно. При использовании OpenSSL эти параметры игнорируются.</p>
<p>Все четыре параметра доступны как глобальные параметры, контролирующие как Exim ведёт себя в роли сервера, и, также, как параметры транспорта <strong>smtp</strong> - контролирующие как Exim ведёт себя в роли клиента. Все значения - раскрываемые. После раскрытия, значение может быть списком разделённым двоеточием, разделитель может быть изменён обычным способом.</p>
<p>Каждый из четырёх списков начинается с набора алгоритмов по умолчанию. Если первый элемент в списке не начинается с восклицательного знака, все элементы по умолчанию удаляются. В этом случае, может использоваться только то, что точно задано. Если первый элемент в списке начинается с восклицательного знака, значения по умолчанию помещаются слева списка.</p>
<p>Тогда, любой элемент, начинающийся с восклицательного знака, вызывает удаление релевантных алгоритмов из списка, и любой элемент, не начинающийся с восклицательного знака, вызывает добавление релевантных алгоритмов в список. Неизвестные элементы списка - игнорируются. Таким образом,</p>
<div class="highlight-python"><pre>tls_require_ciphers = !ARCFOUR</pre>
</div>
<p>разрешают все значения по умолчанию, исключая ARCFOUR, тогда как</p>
<div class="highlight-python"><pre>tls_require_ciphers = AES : 3DES</pre>
</div>
<p>разрешает лишь шифрование использующее AES и 3DES.</p>
<p>Для <strong>tls_require_ciphers</strong> распознаваемые имена - AES_256, AES_128, AES (оба из предшествовавших), 3DES, ARCFOUR_128, ARCFOUR_40 и ARCFOUR (оба из предшествовавших). Список по умолчанию не содержит их всех; в нём находятся AES_256, AES_128, 3DES, и ARCFOUR_128.</p>
<p>Для <strong>gnutls_require_kx</strong> распознаваемые имена DHE_RSA, RSA (который включает DHE_RSA), DHE_DSS, и DHE (который включает оба DHE_RSA и DHE_DSS). Список по умолчанию содержит RSA, DHE_DSS, DHE_RSA.</p>
<p>Для <strong>gnutls_require_mac</strong> распознаваемые имена SHA (синоним SHA1), и MD5. Список по умолчанию содержит SHA, MD5.</p>
<p>Для <strong>gnutls_require_protocols</strong> распознаваемые имена TLS1 и SSL3. Список по умолчанию содержит TLS1 и SSL3.</p>
<p>В сервере, порядок списка не имеет значения. Сервер будет извещать о доступности всех допустимых методов шифрования. Однако, в клиенте, порядок в списке <strong>tls_require_ciphers</strong> определяет предпочтительный порядок алгоритмов шифрования. Первым пробуется первый из клиентского списка, о котором, также, извещал сервер. Порядок значений по умолчанию - перечислен выше.</p>
</div>
<div class="section" id="exim-tls">
<span id="ch39-06"></span><h2>Настройка сервера Exim для использования TLS<a class="headerlink" href="#exim-tls" title="Ссылка на этот заголовок">¶</a></h2>
<p>Когда Exim собран с поддержкой TLS, он извещает клиентские хосты, совпадающие с <strong>tls_advertise_hosts</strong> о доступности команды STARTTLS, но не какие-либо другие хосты. Значение по умолчанию этого параметра - не задано, что означает, что о STARTTLS никто не извещается. Такое значение по умолчанию выбрано, поскольку вы должны привести в порядок некоторые другие параметры, чтобы сделать доступным TLS, и, также, это разумно для систем, которые хотят использовать TLS лишь в роли клиента.</p>
<p>Если клиент выдаёт команду STARTTLS, и на сервере существует какая-то конфигурационная проблема, команда отклоняется с ошибкой 454. Если клиент упорствует в попытках подавать команды SMTP, все они, кроме QUIT, отклоняются с ошибкой:</p>
<div class="highlight-python"><pre>554 Security failure</pre>
</div>
<p>Если команда STARTTLS подаётся в пределах существующей TLS-сессии, она отклоняется с кодом ошибки 554.</p>
<p>Для включения операций TLS на сервере, вы должны установить параметр <strong>tls_advertise_hosts</strong> в соответствие каким-то хостам. Вы можете, разумеется, установить её в “*” - для соответствия всем хостам. Однако, это не всё, что вы должны сделать. TLS-сессии на сервере не будут работать без некоторого дальнейшей настройки в конце сервера.</p>
<p>По слухам известно, что все существующие клиенты, которые поддерживают TLS/SSL, используют шифрование RSA. Чтобы это работало, вам необходимо установить в сервере:</p>
<div class="highlight-python"><pre>tls_certificate =/some/file/name
tls_privatekey =/some/file/name</pre>
</div>
<p>Фактически, эти параметры - раскрываемые строки,таким образом, вы можете сделать их зависимыми от подключенного клиента, если захотите. Первый файл содержит сертификат X509 сервера, и, второй, содержит частный ключ, который с ним идёт. Эти файлы должны быть доступны для чтения пользователем Exim&#8217;a, и, всегда должны быть даны с полным путём. Это может быть один и тот же файл, если в нём содержатся сертификат и ключ. Если параметр <strong>tls_privatekey</strong> не задана, или если раскрытие принудительно неудачно, или результат - пустая строка, предполагается такой случай. Файл сертификата также может содержать промежуточные сертификаты, которые необходимы для отсылки клиенту, с целью аутентифицировать сертификаты сервера.</p>
<p>Если вы не понимаете о ключах и сертификатах, пожалуйста, попробуйте найти источник этой вводной информации, которая не является специфической для Exim&#8217;a. (Есть несколько комментариев ниже, в разделе <a class="reference internal" href="#ch39-11"><em>39.11</em></a>.)</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">Эти параметры не применяются когда Exim работает как клиент - они применяются лишь в случае сервера. Если вам необходимо использовать сертификат в Exim`e в роли клиента, вы должны установить параметры с теми же самыми названиями в транспорте <strong>smtp</strong>.</p>
</div>
<p>Только с этими параметрам, сервер Exim&#8217;a способен использовать TLS. Этим не требуется, чтобы клиент обладал сертификатом (но, смотрите ниже, как настоять на этом). Существует еще один параметр, который бывает необходим в других ситуациях. Если параметр</p>
<div class="highlight-python"><pre>tls_dhparam = /some/file/name</pre>
</div>
<p>установлен, библиотека SSL инициализируется для использования шифрования Diffie-Hellman, с параметрами, содержащимися в файле. Это увеличивает набор методов шифрования, поддерживаемых сервером. Смотрите команду</p>
<div class="highlight-python"><pre>openssl dhparam</pre>
</div>
<p>для способа генерации этих данных. В настоящее время, <strong>tls_dhparam</strong> используется лишь когда Exim собран с OpenSSL. При использовании GnuTLS, он игнорируется.</p>
<p>Строки, предоставляемые для этих трёх параметров, раскрываются при каждом подключении клиентского хоста. Поэтому возможно использовать различные сертификаты и ключи для разных хостов, если вы этого желаете, для управления раскрытием, путём использования клиентского IP-адреса в переменной $sender_host_address. Если строка раскрытия принудительно неудачна, Exim ведёт себя так, будто этот параметр не установлен.</p>
<p>В переменную $tls_cipher устанавливается метод шифрования, о котором договорились для входящего соединения TLS. Это включается в заголовок “Received:” входящего сообщения (по умолчанию - разумеется, вы можете это изменить), и, также, включается в в строку лога прибывающего сообщения, с ключом “X=”, если не выключен лог селектор <strong>tls_cipher</strong>. Условие <strong>encrypted</strong> может использоваться для тестирования специфического шифрования в ACL. (Для исходящих доставок SMTP переменная $tls_cipher сброшена - смотрите раздел <a class="reference internal" href="#ch39-09"><em>39.9</em></a>)</p>
<p>Как только соединение TLS установлено, ACL которые запускаются для последующих команд SMTP могут проверить имя метода шифрования и изменить свои действия соответствующим образом. Имена методов шифрования изменяемые, зависят от используемой библиотеки TLS. Например, OpenSSL использует имя DES-CBC3-SHA для шифрования, известного в другом контексте как TLS_RSA_WITH_3DES_EDE_CBC_SHA. Для дополнительных деталей проверьте документацию OpenSSL.</p>
</div>
<div class="section" id="ch39-07">
<span id="id3"></span><h2>Запрос и проверка клиентских сертификатов<a class="headerlink" href="#ch39-07" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вы хотите, чтобы сервер Exim&#8217;a запросил сертификат при переговорах о TLS-сессии с клиентом, вы должны установить или <strong>tls_verify</strong> или <strong>tls_try_verify_hosts</strong>. Разумеется, вы можете установить любой из них в “*”, для применения ко всем соединениям TLS. Для любого хоста, который совпадает с этими параметрами, Exim запрашивает сертификат как часть установки сессии TLS. Содержимое сертификата проверяется путём его сравнения со списком ожидаемых сертификатов. Они должны быть доступны в файле, или, только для OpenSSL (не для GnuTLS), каталоге, идентифицируемом путём  <strong>tls_verify_certificates</strong>.</p>
<p>Файл может содержать много сертификатов, связанных конец к концу. Если используется директория (только для OpenSSL), каждый сертификат должен быть в отдельном файле, с именем (или символической ссылкой) формы <em>&lt;hash&gt;.0</em>, где <em>&lt;hash&gt;</em> - значение хэша созданное из сертификата. Вы можете вычислить релевантный кэш путём запуска команды</p>
<div class="highlight-python"><pre>openssl x509 -hash -noout -in /cert/file</pre>
</div>
<p>где <em>/cert/file</em> - содержит один сертификат.</p>
<p>Различие между <strong>tls_verify_hosts</strong> и <strong>tls_try_verify_hosts</strong> - в том, что происходит если клиент не предоставляет сертификат, или если сертификат не совпадает ни с одним из сертификатов в коллекции из <strong>tls_verify_certificates</strong>. Если клиент совпадает с <strong>tls_verify_hosts</strong>, попытка установить TLS-сессию прерывается, и входящее соединение обрыватся. Если клиент совпадает с <strong>tls_try_verify_hosts</strong>, продолжается (шифрованная) SMTP-сессия. ACL`ы, запускаемые для последующих команд SMTP, могут детектировать факт, что сертификат не был проверен, и соответственно изменить свои действия. Например, вы можете настаивать на сертификате до принятия сообщения для доставки, но не когда сообщения предназначено для локальной доставки.</p>
<p>Когда клиент предоставляет сертификат, (проверенный, или нет), значение DN сертификата становится доступным в переменной $tls_peerdn в процессе последующей обработки сообщения.</p>
<p>Поскольку часто это - длинная текстовая строка, по умолчанию она не включается в строку лога или заголовок “Received:”. Вы можете принять меры для её записи в лог, установив ключ “DN=”,в лог селекторе <strong>tls_peerdn</strong>, и вы можете использовать <strong>received_header_text</strong> - для изменения заголовка “Received:”. Когда сертификат не предоставлен, переменная $tls_peerdn пуста.</p>
</div>
<div class="section" id="ch39-08">
<span id="id4"></span><h2>Отменённые сертификаты<a class="headerlink" href="#ch39-08" title="Ссылка на этот заголовок">¶</a></h2>
<p>Издатели сертификатов выпускают Списки Аннулированных Сертификатов (Certificate Revocation Lists - CRLs), когда сертификаты отменяются. Если у вас есть такой список, вы можете передать его серверу Exim&#8217;a используя глобальный параметр <strong>tls_crl</strong>, и клиенту Exim&#8217;a, используя параметр с идентичным названием для транспорта <strong>smtp</strong>. В каждом случае, значение параметра раскрывается, и должно быть именем файла содержащего CRL в формате PEM.</p>
</div>
<div class="section" id="exim-a-tls">
<span id="ch39-09"></span><h2>Настройка клиента Exim&#8217;a для использования TLS<a class="headerlink" href="#exim-a-tls" title="Ссылка на этот заголовок">¶</a></h2>
<p>Лог селекторы <strong>tls_ciphe</strong> и <strong>tls_peerdn</strong> применяются к исходящим SMTP-доставкам также, как и ко входящим, последние вызывают запись в лог DN сертификатов сервера. Оставшаяся клиентская конфигурация для TLS - вся в транспорте <strong>smtp</strong>.</p>
<p>Нет необходимости устанавливать какие-либо параметры для работы TLS в транспорте <strong>smtp</strong>. Если Exim собран с поддержкой TLS, и сервер оповестил о поддержке TLS, транспорт <strong>smtp</strong>.всегда пробует запустить TLS-сессию. Однако, это может быть предотвращено установкой <strong>hosts_avoid_tls</strong> (транспортный параметр) в список серверных хостов, с которыми не используется TLS.</p>
<p>Если вы не хотите чтобы Exim пытался отправить сообщения незашифрованными, когда попытка установки шифрованного соединения была неудачной, вы можете установить параметр <strong>hosts_require_tls</strong> в список хостов, для которых шифрования является обязательным. Для этих хостов, доставка всегда задерживается, если не может быть установлено шифрованное соединение. Если для адреса есть другие хосты, они пробуются обычным способом.</p>
<p>Когда хост сервера не находится в <strong>hosts_require_tls</strong>, Exim может попробовать доставить сообщение не шифрованным. Он всегда так делает, если ответ на STARTTLS - код 5xx. Для временного кода ошибки, или для ошибки переговоров о сессии TLS после успешного кода ответа, происходящее контролируется параметром <strong>tls_tempfail_tryclear</strong> транспорта <strong>smtp</strong>. Если она ложна, доставка к хосту задерживается, и пробуются другие хосты (если доступны). Если она истинна, Exim пытается доставить не шифрованное сообщение после 4xx ответа на STARTTLS, и, если STARTTLS принимается, но последующие переговоры о TLS неудачны, Exim закрывает текущее соединение (поскольку оно в неизвестном состоянии), открывает новое к тому же самому хосту, и, затем, пытается доставить сообщение не шифрованным.</p>
<p>Параметры <strong>tls_certificate</strong> и <strong>tls_privatekey</strong> транспорта <strong>smtp</strong> предоставляют клиенту сертификат, который он передаёт на сервер, если тот его запрашивает. Если сервер - Exim, то он будет просить сертификат лишь если клиент совпадает с параметром <strong>tls_verify_hosts</strong> или <strong>tls_try_verify_hosts</strong>.</p>
<p>Если для транспорта <strong>smtp</strong> установлен параметр <strong>tls_require_ciphers</strong>, она должна быть именем файла, или, только для OpenSSL (не для GnuTLS), директорией, которая содержаит коллекцию ожидаемых серверных сертификатов. Клиент проверяет сертификат сервера со своей коллекцией, принимая во внимание любые отозванные сертификаты, которые находятся в списке, заданном параметром <strong>tls_crl</strong>.</p>
<p>Если для транспорта <strong>smtp</strong> установлен параметр <strong>tls_require_ciphers</strong>, он должен содержать список разрешённых методов шифрования. Если любая из этих проверок неудачна, доставка к текущему хосту прекращается, и транспорт <strong>smtp</strong> пробует доставить на альтернативный хост, если он есть.</p>
<div class="admonition note">
<p class="first admonition-title">Примечание</p>
<p class="last">Эти параметры должны быть заданы в транспорте <strong>smtp</strong> Exim&#8217;a для использования TLS, когда он работает как клиент. Exim не предполагает, что сертификат сервера (установленный глобальным параметром с тем же самым именем) также должен использоваться при работе в роли клиента.</p>
</div>
<p>Все параметры TLS, в транспорте <strong>smtp</strong>, раскрываются до использования, с $host и $host_address содержащими имя и адрес сервера, на который подключился клиент. Принудительная ошибка раскрытия заставляет Exim вести себя так, как будто соответствующий параметр не задан.</p>
<p>До установления SMTP соединения, переменные $tls_cipher и $tls_peerdn - пусты. (В процессе первого соединения, оно содержат значения которые которые установлены при приёме сообщения) Если, в последствии, STARTTLS проходит успешно, эти переменные устанавливаются в соответствующие значения для исходящего соединения.</p>
</div>
<div class="section" id="tcp-ip">
<span id="ch39-10"></span><h2>Несколько сообщений через одно шифрованное TCP/IP соединение<a class="headerlink" href="#tcp-ip" title="Ссылка на этот заголовок">¶</a></h2>
<p>Exim посылает много сообщений по одному TCP/IP соединению путём запуска нового процесса для каждого сообщения, передавая сокет от одного процесса следующему. Эта реализация не очень хорошо для работы с TLS, поскольку есть много информации о состоянии, ассоциированной с соединением TLS, а не только идентификатор сокета. Передача всей информации о состоянии другому процессу - невыполнима. Следовательно, Exim завершает существующую сессию TLS до передачи сокета новому процессу. Новый процесс может попробовать запустить сеанс TLS, и, в случае успеха, может попробовать заново аутентифицироваться, если используется AUTH, до посылки следующего сообщения.</p>
<p>Из RFC неясно, действительно или нет, SMTP сессия продолжается в чистом виде после закрытия TLS, или же TLS может быть перезапущен позже, как было описано. Однако, если сервер - Exim, эта остановка и перезапуск - работает. Не известно, каким (или обоими) образом себя ведут другие сервера, если клиент закрывает сеанс TLS, и продолжает с не шифрованным SMTP, но, разумеется, есть те, которые не работают. Для таких серверов, Exim не должен передавать сокет другому процессу, поскольку неудача последующей попытки его использования заставила бы Exim записать в логи временную ошибку хоста, и задержать иные доставки на этот хост.</p>
<p>Для тестирования этого случая, Exim посылает команду EHLO на сервер после закрытия TLS сессии. Если она удачна, то соединение закрывается вместо передачи новому новому процессу доставки, но информация о повторе не записывается.</p>
<p>Также есть ручная отмена; вы можете установить параметр <strong>hosts_nopass_tls</strong> транспорта <strong>smtp</strong> в совпадение с этими хостами, для которых Exim не должен передавать соединение новому процессу, если используется TLS.</p>
</div>
<div class="section" id="ch39-11">
<span id="id5"></span><h2>Сертификаты и всё такое<a class="headerlink" href="#ch39-11" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для полного понимания работы TLS, вам необходимо знать о сертификатах, подписании сертификатов, и авторизаторах сертификатов. Это - не место для обучения <a class="footnote-reference" href="#id10" id="id6">[2]</a>, тем более, что я не очень много знаю об этом. Некоторое полезное введение может быть найдено в FAQ дополнения SSL к Apache, в настоящее время:</p>
<div class="highlight-python"><pre>http://www.modssl.org/docs/2.7/ssl_faq.html#ToC24</pre>
</div>
<p>Другие части документации по <em>modssl</em> - также полезны, и имеют ссылки на дальнейшие файлы. Книга Eric`a Rescorla`a - “SSL and TLS”, опубликованная Addison-Wesley (ISBN 0-201-61598-3), содержит введение и дополнительные всесторонние описания. Некотрые типовые программы, взятые из книги, доступны  по адресу:</p>
<div class="highlight-python"><pre>http: // www.rtfm.com/openssl-examples/</pre>
</div>
</div>
<div class="section" id="ch39-12">
<span id="id7"></span><h2>Цепочки сертификатов<a class="headerlink" href="#ch39-12" title="Ссылка на этот заголовок">¶</a></h2>
<p>Файл указанный в <strong>tls_certificate</strong> может содержать более одного сертификата. Это полезно в случае, когда посылаемый сертификат проверяется промежуточным сертификатом, которого не имеет другая сторона. Несколько сертификатов должны быть в правильном порядке в файле. Вначале, хост сертифицирует сам себя, затем, следующий сертификат для проверки выданного хостом, затем следующее - для проверки предыдущего, и так далее, до (не обязательно) - корневого сертификата. Корневой сертификат уже должен быть доверенным у получателя, для успешной проверки, разумеется, если он заранее не установлен, посылка корневого сертификата вместе с остальными делает его доступным пользователю для установки, если конечный получатель - пользовательский MUA, который может взаимодействовать с пользователем.</p>
</div>
<div class="section" id="ch39-13">
<span id="id8"></span><h2>Самоподписанные сертификаты<a class="headerlink" href="#ch39-13" title="Ссылка на этот заголовок">¶</a></h2>
<p>Вы можете создать самоподписанный сертификат, используя команду <em>req</em>, предоставляемую OpenSSL, например так:</p>
<div class="highlight-python"><pre>openssl req -x509 -newkey rsa:1024 -keyout file1 -out file2 \
            -days 9999 -nodes</pre>
</div>
<p><em>file1</em> и <em>file2</em> могут быть одним и тем же файлом; ключ и сертификат разграничены, и могут быть идентифицированы независимо. Параметр <strong>-days</strong> период, в течение которого сертификат действителен. Параметр <strong>-nodes</strong> - важна: если вы её не зададите, ключ шифруется с запрашиваемой у вас парольной фразой, и любое использование ключа вызывает запрос парольной фразы. Это бесполезно, если вы собираетесь использовать ключ в MTA, где запрос невозможен.</p>
<p>Самоподписанный сертификат, сделанный таким образом, вполне достаточен для тестирования, и может быть адекватен для всех ваших требований, если вы, главным образом, интересуетесь шифрованием передачи, а не секурной идентификацией.</p>
<p>Однако, многие клиенты требуют чтобы предоставленный сервером сертификат был пользовательским (также назваемый “leaf” или “site”) сертификатом, и не самоподписанным сертификатом. В этой ситуации, самоподписанный сертификат, должен быть установлен на клиентском хосте как доверенный корневой “авторитативный сертификат” (CA), и сертификат используемымй Exim`ом, должен быть пользовательским сертификатом, подписанным с этим самоподписанным сертификатом.</p>
<p>Для информации о создании самоподписанных сертификатов и использовании их для подписания пользовательских сертификатов, смотрите часть “General implementation overview” книги “Open-source PKI”, доступной по адресу <a class="reference external" href="http://ospkibook.sourceforge.net/">http://ospkibook.sourceforge.net/</a>.</p>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>наверное, имеется ввиду задержка при генерации - прим. lissyara</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>имеется ввиду - этот документ - прим. lissyara</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Содержание</a></h3>
  <ul>
<li><a class="reference internal" href="#">Шифрование соединений с использованием TLS/SSL</a><ul>
<li><a class="reference internal" href="#ssmtp-smtps">Поддержка для наследственного ssmtp (или smtps) протокола</a></li>
<li><a class="reference internal" href="#openssl-gnutls">OpenSSL против GnuTLS</a></li>
<li><a class="reference internal" href="#gnutls">Вычисление параметра GnuTLS</a></li>
<li><a class="reference internal" href="#openssl">Требование специфических шифров в OpenSSL</a></li>
<li><a class="reference internal" href="#ch39-05">Специфические шифры или другие параметры требующиеся в GnuTLS</a></li>
<li><a class="reference internal" href="#exim-tls">Настройка сервера Exim для использования TLS</a></li>
<li><a class="reference internal" href="#ch39-07">Запрос и проверка клиентских сертификатов</a></li>
<li><a class="reference internal" href="#ch39-08">Отменённые сертификаты</a></li>
<li><a class="reference internal" href="#exim-a-tls">Настройка клиента Exim&#8217;a для использования TLS</a></li>
<li><a class="reference internal" href="#tcp-ip">Несколько сообщений через одно шифрованное TCP/IP соединение</a></li>
<li><a class="reference internal" href="#ch39-11">Сертификаты и всё такое</a></li>
<li><a class="reference internal" href="#ch39-12">Цепочки сертификатов</a></li>
<li><a class="reference internal" href="#ch39-13">Самоподписанные сертификаты</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ch38.html" title="предыдущая глава">Аутентификатор <strong>spa</strong></a></li>
      <li>Next: <a href="ch40.html" title="следующая глава">Списки Контроля Доступа</a></li>
  </ul></li>
</ul>
  <h3>На этой странице</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ch39.txt"
           rel="nofollow">Показать исходный текст</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Быстрый поиск</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Искать" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Введите слова для поиска или имя модуля, класса или функции.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2011, Exim Maintainers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>