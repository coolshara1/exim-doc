
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Некоторые общие параметры конфигурации &mdash; Specification of the Exim Mail Transfer Agent 4.70 documentation</title>
    
    <link rel="stylesheet" href="static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.70',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="static/translations.js"></script>
    <link rel="top" title="Specification of the Exim Mail Transfer Agent 4.70 documentation" href="index.html" />
    <link rel="next" title="Использование Exim’a как клиента без очереди сообщений" href="ch48.html" />
    <link rel="prev" title="Настройка рикошетов и предупреждающих сообщений" href="ch46.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Просмотр</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Словарь-указатель"
             accesskey="I">словарь</a></li>
        <li class="right" >
          <a href="ch48.html" title="Использование Exim’a как клиента без очереди сообщений"
             accesskey="N">следующий</a> |</li>
        <li class="right" >
          <a href="ch46.html" title="Настройка рикошетов и предупреждающих сообщений"
             accesskey="P">предыдущий</a> |</li>
        <li><a href="index.html">Specification of the Exim Mail Transfer Agent 4.70 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ch47-00">
<span id="id1"></span><h1>Некоторые общие параметры конфигурации<a class="headerlink" href="#ch47-00" title="Ссылка на этот заголовок">¶</a></h1>
<p>В этой главе обсуждаются некоторые настройки конфигурации, которые кажутся наиболее общими. Дополнительные примеры и обсуждения могут быть найдены в книге о Exim.</p>
<div class="section" id="ch47-01">
<span id="id2"></span><h2>Отсылка почты на “умный” хост<a class="headerlink" href="#ch47-01" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вы хотите отсылать всю почту для нелокальных доменов на “умный хост” (“smart host”), вы должны заменить маршрутизатор по умолчанию <strong>dnslookup</strong>, на маршрутизатор явно задающий маршрут:</p>
<div class="highlight-python"><pre>send_to_smart_host:
  driver = manualroute
  route_list = !+local_domains smart.host.name
  transport = remote_smtp</pre>
</div>
<p>Если необходимо, вы можете использовать IP адрес умного хоста, вместо имени. Если вы используете Exim лишь для передачи сообщений на умный хост, а не для получения входящих сообщений, вы должны принять меры для синхронизации подачи, путём установки параметра <strong>mua_wrapper</strong> (смотрите главу <a class="reference internal" href="ch48.html#ch48-00"><em>48</em></a>).</p>
</div>
<div class="section" id="exim">
<span id="ch47-02"></span><h2>Использование Exim для обработки списков рассылки<a class="headerlink" href="#exim" title="Ссылка на этот заголовок">¶</a></h2>
<p>Exim может быть использован для запуска простого списка рассылки, но для больших и/или сложных требований, рекомендуется использование дополнительного ПО для управления списками рассылки, типа Majordomo или Mailman.</p>
<p>Маршрутизатор <strong>redirect</strong> может быть использован для обработки списков рассылки, где каждый список поддерживается в отдельном файле, который, поэтому, может управляться независмыми диспетчерами. Параметр <strong>domains</strong> маршрутизатора может использоваться для запуска этих списков в отдельных доменах, от нормальной почты. Например:</p>
<div class="highlight-python"><pre>lists:
  driver = redirect
  domains = lists.example
  file = /usr/lists/$local_part
  forbid_pipe
  forbid_file
  errors_to = $local_part-request@lists.example
  no_more</pre>
</div>
<p>Этот маршрутизатор пропущен для доменов, иных нежели <em>lists.example</em>. Для адресов в этих доменах, он ищет файл, совпадающий с локальной частью. Если файла нет, маршрутизация не выполняется, но, поскольку установлена <strong>no_more</strong>, последующие маршрутизаторы не проверяются, и вся доставка заканчивается неудачей.</p>
<p>Параметры <strong>forbid_pipe</strong> и <strong>forbid_file</strong> предотвращают раскрытие локальной части в доставку в трубу или файл, которая, обычно, неуместна в списках рассылки.</p>
<p>Параметр <strong>errors_to</strong> задаёт, что любые ошибки доставки, вызванные адресами взятыми из списка рассылки, должны быть отосланы на заданный адрес, а не оригинальному отправителю сообщения. Однако, до этого действия, Exim проверяет ошибочный адрес, и игнорирует, если его проверка неудачна.</p>
<p>Например, используя конфигурацию выше, почта посланная на <em>dicts&#64;lists.example</em> - передаётся на адреса содержащиеся в <em>/usr/lists/dicts</em>, с направлением сообщений о ошибках на  <em>dicts-request&#64;lists.example</em>, при условии, что этот адрес может быть проверен. Также возможно, что тут мог бы быть файл с именем <em>/usr/lists/dicts-request</em>, содержащий адрес(а) деспетчер(a|ов) данного специфического списка, но иным подходом, типа установки более раннего маршрутизатора (возможно, использующего параметры <strong>local_part_prefix</strong> или <strong>local_part_suffix</strong>) для обработки адресов в форме owner-xxx или xxx-request.</p>
</div>
<div class="section" id="ch47-03">
<span id="id3"></span><h2>Синтаксические ошибки в списках рассылки<a class="headerlink" href="#ch47-03" title="Ссылка на этот заголовок">¶</a></h2>
<p>Если вхождение в данных перенаправления содержит синтаксическую ошибку, Exim, обычно, задерживает доставку оригинального адреса. Это означает, что ошибка синтаксиса, в списке рассылки, задержит все доставки на этот список. Это может быть неподходящим, когда список обслуживается автоматически, из данных предоставленных пользователями, и адреса не проверены строго.</p>
<p>Если установлен параметр <strong>skip_syntax_errors</strong>, маршрутизатор <strong>redirect</strong> просто пропускает вхождения, которые не может разобрать, отмечая инцидент в логах. Если, дополнительно, <strong>syntax_errors_to</strong> установлена в адрес который можно проверить, сообщение посылается на него при каждом пропуске битого адреса. Обычно, <strong>syntax_errors_to</strong> устанавливается в тот же адрес, что и <strong>errors_to</strong>.</p>
</div>
<div class="section" id="ch47-04">
<span id="id4"></span><h2>Повторное раскрытие списков рассылки<a class="headerlink" href="#ch47-04" title="Ссылка на этот заголовок">¶</a></h2>
<p>Exim запоминает каждый индивидуальный адрес, на который было доставлено сообщение, для избежания дублирования, но, обычно, он сохраняет лишь оригинальный адрес получателя, сообщения. Если все доставки на список рассылки не могут быть завершены в первую попытку, список рассылки раскрывается повторно, когда происходит следующая попытка доставки. Это означает, что изменения списка примаются во внимание при каждой попытке доставки, таким образом, адреса, которые были добавлены к списку с того времени как пришло сообщение, также получат копию сообщения, несмотря на то, что оно предшествовало их подписке.</p>
<p>Если такое поведение - нежелательно, в маршрутизаторе <strong>redirect</strong> может быть установлен параметр <strong>one_time</strong>. Если это сделано, любые созданные маршрутизатором адреса, которые не удалось доставить при первой попытке, добавляются к сообщению как “верхний уровень” (“top level”) адресов, и, создавший их родительский адрес, помечается как “доставленный” (“delivered”). Таким образом, раскрытие списков рассылки не происходит заново, в последующие попытки доставки. Неудобство этого, в том, что если любой неудачный адрес - некорректен, его исправление в файле не имеет эффекта для предыдущих сообщений.</p>
<p>Оригинальный адрес высшего уровня запоминается с каждым созданным адресом, и выводится в логах. Однако, любые промежуточные родительские адреса - не записываются. Это делает различие для логов лишь если установлен селектор <strong>all_parents</strong>, но, так или иначе, для списков рассылки обычен лишь один уровень раскрытия.</p>
</div>
<div class="section" id="ch47-05">
<span id="id5"></span><h2>Закрытые списки рассылки<a class="headerlink" href="#ch47-05" title="Ссылка на этот заголовок">¶</a></h2>
<p>Примеры, пока, предполагали открытые списки рассылки, в которые любой может послать почту. Также возможно настроить закрытые списки, где почта принимается лишь от специфических отправителей. Это производится путём использования общего параметра <strong>senders</strong>, для ограничения маршрутизатора обрабатывающего список.</p>
<p>Следующий пример использует один и тот же файл как список получателей, и как список разрешённых отправителей. Он требует трёх маршрутизаторов:</p>
<div class="highlight-python"><pre>lists_request:
  driver = redirect
  domains = lists.example
  local_part_suffix = -request
  file = /usr/lists/$local_part$local_part_suffix
  no_more

lists_post:
  driver = redirect
  domains = lists.example
  senders = ${if exists {/usr/lists/$local_part}\
             {lsearch;/usr/lists/$local_part}{*}}
  file = /usr/lists/$local_part
  forbid_pipe
  forbid_file
  errors_to = $local_part-request@lists.example
  no_more

lists_closed:
  driver = redirect
  domains = lists.example
  allow_fail
  data = :fail: $local_part@lists.example is a closed mailing list</pre>
</div>
<p>Все три маршрутизатора имеют одну и ту же установку <strong>domains</strong>, таким образом, для любых других доменов, они пропущены. Первый маршрутизатор запускается лишь если локальная часть завершается на “-request”. Он обрабатывает сообщения к диспетчер(у|ам) списка, путём открытого списка рассылки.</p>
<p>Второй маршрутизатор запускается лишь если удовлетворено предварительное условие <strong>senders</strong>. Он проверяет существование списка соответствующего локальной части, и, затем, с помощью линейного поиска проверяет, что отправитель находится в списке. До попытки поиска по файлу, необходимо проверить его существование, поскольку иначе Exim подумает, что произошла конфигурационная ошибка. Если файл не существует, раскрытие <strong>senders</strong> приводит к “*”, что соответствует всем отправителям. Это означает, что маршрутизатор работает, но, поскольку нет списка, от него отказываются, и <strong>no_more</strong> гарантирует, что дальнейшие маршрутизаторы  не запускаются. Адрес неудачен с ошибкой “unrouteable address”.</p>
<p>Третий маршрутизатор запускается лишь если второй маршрутизатор пропущен, что происходит когда список рассылки существует, но отправитель не в нём. Этот маршрутизатор принудительно создаёт неудачу адреса, давая подходящее сообщение о ошибке.</p>
</div>
<div class="section" id="verp">
<span id="ch47-06"></span><h2>Переменные пути возврата конверта (VERP)<a class="headerlink" href="#verp" title="Ссылка на этот заголовок">¶</a></h2>
<p>Variable Envelope Return Paths – смотрите <a class="reference external" href="http://cr.yp.to/proto/verp.txt">http://cr.yp.to/proto/verp.txt</a> - являются способом помочь администраторам списков рассылок обнаружить, какой адрес подписки является причиной специфической неудачи доставки. Идея - в кодировании оригинального получателя адреса в исходящем адресе отправителя конверта, таким образом, если сообщение форвардится путём другого хоста, и, впоследствии, создаётся рикошет, оригинальный получатель может быть извлечён из адреса получателя рикошета.</p>
<p>Адрес отправителя конверта может быть модифицирован Exim`ом используя два различных средства: параметр <strong>errors_to</strong> в маршрутизаторе (как показано в предыдущих примерах списков рассылки), или транспортный параметр <strong>return_path</strong>. Второй из них эффективен лишь если сообщение успешно доставлено не иной хост; она не используется, для ошибок детектируемых на локальном хосте (смотрите описание <strong>return_path</strong> в главе <a class="reference internal" href="ch24.html#ch24-00"><em>24</em></a>). Вот - пример использования <strong>return_path</strong> для осуществления VERP в транспорте <strong>smtp</strong>:</p>
<div class="highlight-python"><pre>verp_smtp:
driver = smtp
max_rcpt = 1
return_path = \
  ${if match {$return_path}{^(.+?)-request@your.dom.example\$}\
  {$1-request+$local_part=$domain@your.dom.example}fail}</pre>
</div>
<p>Он имеет эффект перезаписи обратного пути (отправителя конверта) в исходящих SMTP сообщениях, если локальная часть оригинального получателя завершается на “-request”, и домен - <em>your.dom.example</em>. Перезапись вставляет локальную часть и домен получателя в путь возврата. Предположим, например, что сообщение, чей путь возврата установлен в <em>somelist-request&#64;your.dom.example</em> - посылается на <em>subscriber&#64;other.dom.example</em>. В транспорте, путь возврата переписывается как:</p>
<div class="highlight-python"><pre>somelist-request+subscriber=other.dom.example@your.dom.example</pre>
</div>
<p>Чтобы это работало, вы должны сказать Exim&#8217;y посылать несколько копий сообщений имеющих более одного получателя, чтобы каждая копия имела лишь одного получателя. Это достигается путём установки <strong>max_rcpt</strong> в 1. Без этого, одна копия сообщения может быть послана нескольким различным получателям в одном домене, когда $local_part недоступна в транспорте, поскольку она не уникальна.</p>
<p>Если ваш хост не только производит доставки списков рассылки, вы, вероятно, должны использовать отдельный транспорт для доставок VERP, чтобы не использовать дополнительные ресурсы для создания копий, по одной на получателя.. Это легко может быть сделано путём раскрытия параметра <strong>transport</strong> в маршрутизаторе:</p>
<div class="highlight-python"><pre>dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = \
    ${if match {$return_path}{^(.+?)-request@your.dom.example\$}\
               {verp_smtp}{remote_smtp}}
  no_more</pre>
</div>
<p>Если вы хотите изменить путь возврата используя <strong>errors_to</strong> в маршрутизаторе, вместо использования <strong>return_path</strong> в транспорте, вам необходимо установить <strong>errors_to</strong> во всех маршрутизаторах которые обрабатывают адреса списков рассылок. Это будет гарантировать, что все ошибки доставки, включая детектируемые на локальном хосте, посылаются на адреса VERP.</p>
<p>На хосте, который не делает локальных доставок, и не имеет ручной маршрутизации, в изменении нуждается лишь маршрутизатор <strong>dnslookup</strong>. Для доставки SMTP не нужен специальный транспорт. Каждый получатель списка рассылки имеет свой собственный путь возврата, и, таким образом, Exim должен передать их транспорту по одному. Вот - пример маршрутизатора <strong>dnslookup</strong>, который осуществляет VERP:</p>
<div class="highlight-python"><pre>verp_dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = remote_smtp
  errors_to = \
  ${if match {$return_path}{^(.+?)-request@your.dom.example\$}}
    {$1-request+$local_part=$domain@your.dom.example}fail}
  no_more</pre>
</div>
<p>До того, как вы начнёте рассылать сообщения с VERP путём возврата, вы, также, должны настроить Exim на приём рикошетов, которые возвращаются с таким путём. Обычно, это производится путём установки параметра <strong>local_part_suffix</strong> для маршрутизатора, и использования этого для маршрутизации сообщения туда, где вы его хотели бы обработать.</p>
<p>Накладные расходы, при использовании VERP, очень сильно зависят от размера сообщения, числа получателей адресов, которые резольвятся на один и тот же удалённый хост, и скорости соединения, через которое посылается сообщение. Если много адресов резольвятся на один и тот же хост, и соединение медленное, посылка отдельной копии сообщения для каждого адреса может быть существенно дольше, чем посылка одной копии сообщения с многими получателями (что не может быть использоваться с VERP).</p>
</div>
<div class="section" id="ch47-07">
<span id="id6"></span><h2>Виртуальные домены<a class="headerlink" href="#ch47-07" title="Ссылка на этот заголовок">¶</a></h2>
<p>Фраза “virtual domain”, к сожалению, используется для двух различных смыслов:</p>
<ul class="simple">
<li>Домен, для которого нет реальных почтовых ящиков; все действительные локальные части - синонимы для других почтовых адресов. Общие примеры - организационные домены верхнего уровня, и “тщеславные” (“vanity”) домены.</li>
<li>Один из множества независимых доменов, которые обрабатываются одним и тем же хостом, с почтовыми ящиками на этом хосте, но, где владельцы почтовых ящиков не обязательно обладают учетной записью на этом хосте.</li>
</ul>
<p>Первое использование, вероятно, наиболее часто, и действительно, кажется более “виртуальным” чем второе. Этот вид доменов может быть обработан Exim`ом прямой маршрутизацией синонимов. Один подход состоит в создании отдельного файла синонимов для каждого виртуального домена. Exim может проверять существование файла синонимов, для определения - существует ли домен. Тут полезен тип поиска <strong>dsearch</strong>, приводя к маршрутизатору такой формы:</p>
<div class="highlight-python"><pre>virtual:
  driver = redirect
  domains = dsearch;/etc/mail/virtual
  data = ${lookup{$local_part}lsearch{/etc/mail/virtual/$domain}}
  no_more</pre>
</div>
<p>Параметр <strong>domains</strong> определяет, что маршрутизатор будет пропущен, если нет файла в директории <em>/etc/mail/virtual</em>, чьё имя такое же, как и обрабатываемый домен Когда маршрутизатор работает, он ищет локальную часть в файле, для нахождения нового адреса (или списка адресов). Установка <strong>no_more</strong> обеспечивает, что если поиск неудачен (приводит к <strong>data</strong>, являющейся пустой строкой), Exim оставляет адрес, не пробуя последующие маршрутизаторы.</p>
<p>Этот маршрутизатор может обрабатывать все виртуальные домены, поскольку имена файлов синонимов следуют за фиксированным шаблоном. Разрешения могут быть розданы так, чтобы соответствующие люди могли редактировать различные файлы синонимов. Успешная операция подстановки синонима приводит к новому адресу получателя конверта, который, затем, маршрутизируется с начала.</p>
<p>Другой вид “виртуальных” доменов, также может быть обработан прямым методом. Один подход состоит в создании файла для каждого домена, содержащего список действительных локальных частей, и используется в маршрутизаторе типа такого:</p>
<div class="highlight-python"><pre>my_domains:
  driver = accept
  domains = dsearch;/etc/mail/domains
  local_parts = lsearch;/etc/mail/domains/$domain
  transport = my_mailboxes</pre>
</div>
<p>Адрес принимается если есть файл для домена, и локальная часть может быть найдена в файле. Параметр <strong>domains</strong> используется для проверки на существование файла, поскольку <strong>domains</strong> проверяется до параметра <strong>local_parts</strong> (смотрите раздел <a class="reference internal" href="ch03.html#ch03-12"><em>3.12</em></a>). Вы не можете использовать <strong>require_files</strong>, поскольку этот параметр проверяется после <strong>local_parts</strong>. Транспорт - таков:</p>
<div class="highlight-python"><pre>my_mailboxes:
  driver = appendfile
  file = /var/mail/$domain/$local_part
  user = mail</pre>
</div>
<p>Он использует директорию почтовых ящиков для каждого домена. Установка <strong>user</strong> - требуется, для задания какой uid будет использоваться для записи в почтовые ящики.</p>
<p>Конфигурация показанная здесь - лишь один пример, как вы можете поддерживать это требование. Есть много других путей, которыми может быть настроен этот вид конфигурации, например, путём использования ВД вместо раздельных файлов, для хранения всей информации о доменах.</p>
</div>
<div class="section" id="ch47-08">
<span id="id7"></span><h2>Многочисленные пользовательские почтовые ящики<a class="headerlink" href="#ch47-08" title="Ссылка на этот заголовок">¶</a></h2>
<p>Большие пользователи почты часто хотят работать с многими почтовыми ящиками, в которых входящая почта сортируется автоматически. Популярный способ обработать это - разрешить пользователям использовать несколько адресов отправителя, таким образом, ответы могут быть легко идентифицированы. Для этой цели, пользователям разрешают добавлять префиксы или суффиксы к их локальным частям. Для этой цели могут быть использованы средства групповых символов общих параметров маршрутизатора - <strong>local_part_prefix</strong> и <strong>local_part_suffix</strong>. Например, рассмотрите такой маршрутизатор:</p>
<div class="highlight-python"><pre>userforward:
  driver = redirect
  check_local_user
  file = $home/.forward
  local_part_suffix = -*
  local_part_suffix_optional
  allow_filter</pre>
</div>
<p>Он запускает пользовательский файл <em>.forward</em> для всех локальных частей формы <em>username-*</em>. В пределах файла фильтра, пользователь может различать различные случаи путём проверки переменной $local_part_suffix. Например:</p>
<div class="highlight-python"><pre>if $local_part_suffix contains -special then
   save /home/$local_part/Mail/special
endif</pre>
</div>
<p>Если файл фильтра не существует, или не имеет дело с такими адресами, они передаются следующим маршрутизаторам, и, предполагая, что далее не используется параметр <strong>local_part_suffix</strong>, они, по видимому, будут неудачны. Таким образом, пользователь может контролировать, какие суффиксы являются действительными.</p>
<p>Альтернативно, суффикс может использоваться для вызова другого файла <em>.forward</em> - который является способом воплощения подобного средства в другом MTA:</p>
<div class="highlight-python"><pre>userforward:
  driver = redirect
  check_local_user
  file = $home/.forward$local_part_suffix
  local_part_suffix = -*
  local_part_suffix_optional
  allow_filter</pre>
</div>
<p>Если нет никакого суффикса, используется <em>.forward</em>; если суффикс - <strong>-special</strong>, например, используется <em>.forward-special</em>. Ешё раз, если соответствующий файл не существует, или не имеет дела с адресом, он передаётся последующим маршрутизаторам, которые, если требуется, ищут неполный файл <em>.forward</em> и использовуют его по умолчанию.</p>
</div>
<div class="section" id="vacation">
<span id="ch47-09"></span><h2>Упрощённая обработка отпуска (vacation)<a class="headerlink" href="#vacation" title="Ссылка на этот заголовок">¶</a></h2>
<p>Традиционный способ запуска программы <em>vacation</em> для пользователей - установить команду трубы в файле <em>.forward</em> (для деталей синтаксиса, смотрите раздел <a class="reference internal" href="ch26.html#ch26-06"><em>26.6</em></a>). Это распространённая ошибка у неопытных пользователей. Есть две особенности Exim`a, которые могут быть использованы для упрощения этого процесса для пользователей:</p>
<ul>
<li><p class="first">Преффикс локальной части, типа “vacation-”, может быть задан в маршрутизаторе, который используется для непосредственной доставки сообщений к программе <em>vacation</em>, или, альтернативно, может использоваться транспорт Exim`a <strong>autoreply</strong>. Тогда, содержимое пользовательского файла <em>vacation</em>, намного более простое. Например:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">spqr</span><span class="p">,</span> <span class="n">vacation</span><span class="o">-</span><span class="n">spqr</span>
</pre></div>
</div>
</li>
<li><p class="first">Общий параметр маршрутизаторов, <strong>require_files</strong>, может использоваться для вызова доставки отпуска <a class="footnote-reference" href="#id15" id="id8">[1]</a>, путём проверки существования определённого файла в домашнем каталоге пользователя. Также должна использоваться общий параметр <strong>unseen</strong>, для гарантии, что произойдёт оригинальная доставка. В этом случае, все использующие это пользователи, должны создать файл, называемый, скажем “.vacation”, содержащий сообщение о отпуске.</p>
</li>
</ul>
<p>Другое преимущество обоих этих методов состоит в том, что они оба работают даже когда пользователям запрещено использование произвольных труб.</p>
</div>
<div class="section" id="ch47-10">
<span id="id9"></span><h2>Отбор копий сообщений<a class="headerlink" href="#ch47-10" title="Ссылка на этот заголовок">¶</a></h2>
<p>Некоторые инсталляции требуют, чтобы была сделана полная архивная копия всех сообщений. Одна копия каждого сообщения может быть легко взята путём соответствующей команды в системном фильтре, который мог бы, например, использовать для каждого дня разные файлы.</p>
<p>Также, есть теневой транспортный механизм, который может использоваться для отбора копий сообщения, которые успешно доставлены локальными транспортами, одна копия на доставку. Это может использоваться, кроме прочего, для осуществления автоматического уведомления о доставке, сайтам <a class="footnote-reference" href="#id16" id="id10">[2]</a> которые наставивают на таких вещах.</p>
</div>
<div class="section" id="ch47-11">
<span id="id11"></span><h2>Периодически подключенные хосты<a class="headerlink" href="#ch47-11" title="Ссылка на этот заголовок">¶</a></h2>
<p>Для хостов, стало весьма обычным (опскольку дешевле), подключаться к интернету периодически, а не всё время быть подключенными. Обычная настройка для таких хостов - что поста для них накапливается на системе постоянно соединённой с интернетом.</p>
<p>Exim был разработан для использования на постоянно подключенных хостах, и, таким образом, не особенно подходит для использования на периодически подключаемых хостах. Однако, есть особенности, которые могут использоваться.</p>
</div>
<div class="section" id="ch47-12">
<span id="id12"></span><h2>Exim на вышестоящих серверных хостах<a class="headerlink" href="#ch47-12" title="Ссылка на этот заголовок">¶</a></h2>
<p>Exim принимает меры, чтобы входящая почта для периодически подключаемых хостов оставалася в очереди Exim`a, пока клиент не подключится. Однако, этот подход не очень хорошо масштабируется. Два различных вида ожидания сообщения смешиваются в одной очереди - те, которые нельзя доставить из-за каких-то вреемнных проблем, и тех, которые ждут соединения их хоста предназначения. Это делает тяжёлым управление очередью, так же как и растрату ресурсов, поскольку каждый обработчик очереди сканирует всю очередь.</p>
<p>Лучший подход состоит в отделении тех сообщений, которые ждут временно подключаемых хостов. Это может быть сделано путём доставки этих сообщений в локальные файлы пакетного SMTP, “mailstore”, или иной формат сохраняющий конверт, из которого они передаются путём иного программного обеспечения к их месту назначения. Это облегчает сборку всей почты для одного хоста в одной директории, и применения правил локального таймаута на основании сообщений, если требуется.</p>
<p>Для очень небольшого масштаба, можно сделать чтобы Exim оставлял почту в очереди. Если вы это делаете, вы должны сконфигурировать Exim с длинным периодом повтора для временно подключенных хостов. Например:</p>
<div class="highlight-python"><pre>cheshire.wonderland.fict.example    *   F,5d,24h</pre>
</div>
<p>Этим останавливается множество неудачных попыток доставки, но Exim запоминает какие сообщения находились в очереди для этого хоста. Как только непостоянный хост появляется в сети, принудительная доставка одного сообщения (или используя параметры <strong>-M</strong> или <strong>-R</strong>, или путём использования команды ETRN SMTP (смотрите раздел <a class="reference internal" href="ch45.html#ch45-08"><em>45.8</em></a>)) вызывает доставку всех находящихся в очереди сообщений, часто - по одному соединению. Когда хост остаётся на связи, любые новые сообщения доставляются немедленно.</p>
<p>Если подключающиеся хосты не имеют фиксированного IP-адреса, т.е. хост появляется каждый раз с различным IP-адресом, механизмы повтора на хосте-владельце <a class="footnote-reference" href="#id17" id="id13">[3]</a> запутываются, поскольку IP-адрес, обычно, используется как часть ключевой строки для информации повторов. Этого можно избежать, путём сброса <strong>retry_include_ip_address</strong> в <strong>smtp</strong> транспорте. Так как это неудобно для хостов постоянно связанных с интернет, для периодически связанных хостов лучше организовать отдельный транспорт.</p>
</div>
<div class="section" id="ch47-13">
<span id="id14"></span><h2>Exim на периодически подключаемом клиентском хосте<a class="headerlink" href="#ch47-13" title="Ссылка на этот заголовок">¶</a></h2>
<p>Значение <strong>smtp_accept_queue_per_connection</strong>, вероятно, должно быть увеличено, или даже установлено в  ноль (т.е. отключено) на периодически подключаемых хостах, для того, чтобы все входящие сообщения немедленно отсылались по одному соединению.</p>
<p>Почта ожидающая отсылки с периодически подключаемого хоста, вероятно, не будет маршрутизироватся, поскольку без соединения с DNS, поиски невозможны. Это означает, что нормальная обработка очереди завершается за время соединения, каждое сообщение, вероятно, будет отправлено в отдельной SMTP-сессии. Этого можно избежать, путём запуска обработки очереди с параметров командной строки начинающихся с <strong>-qq</strong> вместо <strong>-q</strong>. В этом случае, очередь сканируется дважды. В первый проход, завершается маршрутизация, но доставки не происходит. Во второй проход - нормальная обработка очереди; так как все сообщения предварительно были смаршрутизированы, то предназначенные для одного и того же хоста, вероятно, будут отосланы в одном SMTP соединении.</p>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[1]</a></td><td>:) - прим. lissyara</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[2]</a></td><td>серверам - прим. lissyara</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[3]</a></td><td>почты - прим. lissyara</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Содержание</a></h3>
  <ul>
<li><a class="reference internal" href="#">Некоторые общие параметры конфигурации</a><ul>
<li><a class="reference internal" href="#ch47-01">Отсылка почты на “умный” хост</a></li>
<li><a class="reference internal" href="#exim">Использование Exim для обработки списков рассылки</a></li>
<li><a class="reference internal" href="#ch47-03">Синтаксические ошибки в списках рассылки</a></li>
<li><a class="reference internal" href="#ch47-04">Повторное раскрытие списков рассылки</a></li>
<li><a class="reference internal" href="#ch47-05">Закрытые списки рассылки</a></li>
<li><a class="reference internal" href="#verp">Переменные пути возврата конверта (VERP)</a></li>
<li><a class="reference internal" href="#ch47-07">Виртуальные домены</a></li>
<li><a class="reference internal" href="#ch47-08">Многочисленные пользовательские почтовые ящики</a></li>
<li><a class="reference internal" href="#vacation">Упрощённая обработка отпуска (vacation)</a></li>
<li><a class="reference internal" href="#ch47-10">Отбор копий сообщений</a></li>
<li><a class="reference internal" href="#ch47-11">Периодически подключенные хосты</a></li>
<li><a class="reference internal" href="#ch47-12">Exim на вышестоящих серверных хостах</a></li>
<li><a class="reference internal" href="#ch47-13">Exim на периодически подключаемом клиентском хосте</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="ch46.html" title="предыдущая глава">Настройка рикошетов и предупреждающих сообщений</a></li>
      <li>Next: <a href="ch48.html" title="следующая глава">Использование Exim&#8217;a как клиента без очереди сообщений</a></li>
  </ul></li>
</ul>
  <h3>На этой странице</h3>
  <ul class="this-page-menu">
    <li><a href="sources/ch47.txt"
           rel="nofollow">Показать исходный текст</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Быстрый поиск</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Искать" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Введите слова для поиска или имя модуля, класса или функции.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2011, Exim Maintainers.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>